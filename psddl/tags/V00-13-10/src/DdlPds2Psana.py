#--------------------------------------------------------------------------
# File and Version Information:
#  $Id$
#
# Description:
#  Module DdlPds2Psana...
#
#------------------------------------------------------------------------

"""DDL parser which generates pds2psana C++ code.

This software was developed for the SIT project.  If you use all or 
part of it, please give an appropriate acknowledgment.

@see RelatedModule

@version $Id$

@author Andrei Salnikov
"""


#------------------------------
#  Module's version from CVS --
#------------------------------
__version__ = "$Revision$"
# $Source$

#--------------------------------
#  Imports of standard modules --
#--------------------------------
import sys
import os
import types

#---------------------------------
#  Imports of base class module --
#---------------------------------

#-----------------------------
# Imports for other modules --
#-----------------------------
import jinja2 as ji
from psddl.Attribute import Attribute
from psddl.Enum import Enum
from psddl.Package import Package
from psddl.Type import Type
from psddl.Template import Template as T
from psddl.TemplateLoader import TemplateLoader

#----------------------------------
# Local non-exported definitions --
#----------------------------------

# jinja environment
_jenv = ji.Environment(loader=TemplateLoader(), trim_blocks=True,
                       line_statement_prefix='$', line_comment_prefix='$$')

def _TEMPL(template):
    return _jenv.get_template('pds2psana.tmpl?'+template)

def _interpolate(expr):
    expr = expr.replace('{xtc-config}.', 'cfgPtr->')
    expr = expr.replace('@config.', 'cfgPtr->')
    expr = expr.replace('{self}.', "m_xtcObj->")
    expr = expr.replace('@self.', "m_xtcObj->")
    return expr

def _dimargs(shape):
    if not shape : return []
    return ', '.join(['uint32_t i%d'%i for i, r in enumerate(shape.dims)])

def _dimexpr(shape):
    return ''.join(['[i%d]'%i for i in range(len(shape.dims))])

def _dimarray(shape):
    return ', '.join([_interpolate(str(s)) for s in shape.dims])

def _hasconfig(str):
    return '{xtc-config}' in str or '@config' in str

#------------------------
# Exported definitions --
#------------------------

#---------------------
#  Class definition --
#---------------------
class DdlPds2Psana ( object ) :

    @staticmethod
    def backendOptions():
        """ Returns the list of options supported by this backend, returned value is 
        either None or a list of triplets (name, type, description)"""
        return [
            ('psana-inc', 'PATH', "directory for Psana includes, default: psddl_psana"),
            ('pdsdata-inc', 'PATH', "directory for pdsdata includes, default: pdsdata"),
            ('psana-ns', 'STRING', "namespace for Psana types, default: Psana"),
            ('pdsdata-ns', 'STRING', "namespace for pdsdata types, default: Pds"),
            ]


    #----------------
    #  Constructor --
    #----------------
    def __init__ ( self, backend_options, log ) :
        '''Constructor
        
           @param backend_options  dictionary of options passed to backend
           @param log              message logger instance
        '''
        self.incname = backend_options['global:header']
        self.cppname = backend_options['global:source']
        self.incdirname = backend_options.get('global:gen-incdir', "")
        self.top_pkg = backend_options.get('global:top-package')
        
        self.psana_inc = backend_options.get('psana-inc', "psddl_psana")
        self.pdsdata_inc = backend_options.get('pdsdata-inc', "pdsdata")
        self.psana_ns = backend_options.get('psana-ns', "Psana")
        self.pdsdata_ns = backend_options.get('pdsdata-ns', "Pds")

        self._log = log

        #include guard
        g = os.path.split(self.incname)[1]
        if self.top_pkg: g = self.top_pkg + '_' + g
        self.guard = g.replace('.', '_').upper()

    #-------------------
    #  Public methods --
    #-------------------

    def parseTree ( self, model ) :
        
        # open output files
        self.inc = file(self.incname, 'w')
        self.cpp = file(self.cppname, 'w')

        # include guard to header
        print >>self.inc, "#ifndef", self.guard 
        print >>self.inc, "#define", self.guard, "1"

        msg = "\n// *** Do not edit this file, it is auto-generated ***\n"
        print >>self.inc, msg
        print >>self.cpp, msg

        print >>self.inc, "#include <vector>"
        print >>self.inc, "#include <boost/shared_ptr.hpp>"

        inc = os.path.join(self.incdirname, os.path.basename(self.incname))
        print >>self.cpp, T("#include \"$inc\"\n")(locals())
        print >>self.cpp, "#include <cstddef>\n"
        print >>self.cpp, "#include <stdexcept>\n"

        # headers for psana and pdsdata includes
        inc = os.path.join(self.psana_inc, os.path.basename(self.incname))
        print >>self.inc, T("#include \"$inc\"")(locals())
        inc = os.path.join(self.pdsdata_inc, os.path.basename(self.incname))
        print >>self.inc, T("#include \"$inc\"")(locals())

        # headers for other included packages
        for use in model.use:
            path = use['file']
            headers = use['cpp_headers']
            if not headers:
                header = os.path.splitext(path)[0]
                if not header.endswith('.ddl'): header += '.ddl'
                header = header + '.h'
                header = os.path.join(self.incdirname, os.path.basename(header))
                headers = [header]
            for header in headers:
                print >>self.inc, T("#include \"$header\"")(locals())

        if self.top_pkg : 
            print >>self.inc, T("namespace $top_pkg {")[self]
            print >>self.cpp, T("namespace $top_pkg {")[self]

        # regular enums
        for enum in model.enums() :
            if not enum.included :
                self._genEnum(enum)

        # loop over packages and types in the model
        for ns in model.namespaces() :
            if isinstance(ns, Package) :
                if not ns.included :
                    self._parsePackage(ns)
            elif isinstance(ns, Type) :
                if not ns.external:
                    self._parseType(type = ns)

        if self.top_pkg : 
            print >>self.inc, T("} // namespace $top_pkg")[self]
            print >>self.cpp, T("} // namespace $top_pkg")[self]

        # close include guard
        print >>self.inc, "#endif //", self.guard

        # close all files
        self.inc.close()
        self.cpp.close()


    def _parsePackage(self, pkg):

        # open namespaces
        print >>self.inc, T("namespace $name {")[pkg]
        print >>self.cpp, T("namespace $name {")[pkg]

        # regular enums
        for enum in pkg.enums() :
            if not enum.included :
                self._genEnum(enum)

        # loop over packages and types
        for ns in pkg.namespaces() :
            
            if isinstance(ns, Package) :
                
                self._parsePackage(ns)
            
            elif isinstance(ns, Type) :
    
                self._parseType(type = ns)

        # close namespaces
        print >>self.inc, T("} // namespace $name")[pkg]
        print >>self.cpp, T("} // namespace $name")[pkg]

    def _genEnum(self, enum):

        self._log.debug("_genEnum: type=%s", repr(enum))

        if not enum.name: return

        pdstype = enum.fullName('C++', self.pdsdata_ns)
        psanatype = enum.fullName('C++', self.psana_ns)
        
        print >>self.cpp, _TEMPL('enum_pds_to_psana').render(locals())


    def _parseType(self, type):

        self._log.debug("_parseType: type=%s", repr(type))

        # skip included types
        if type.included : return

        # regular enums
        for enum in type.enums() :
            self._genEnum(enum)

        if not type.value_type :
            
            self._genAbsType(type)
            
        else:
            
            self._genValueType(type)


    def _genValueType(self, type):

        self._log.debug("_genValueType: type=%s", repr(type))

        typename = type.fullName('C++')

        # need to call a non-default constructor on a type
        ctor = None
        for c in type.ctors:
            if c.args or 'auto' in c.tags:
                if ctor:
                    self._log.warning('Constructor overload for %s, using first constructor', typename)
                else:
                    ctor = c

        if not ctor : 
            self._log.warning('No suitable constructor defined for %s', typename)
            return

        self._log.debug("_genValueType: ctor args=%s", repr(ctor.args))
        
        ctor_args = []
        for arg in ctor.args:

            atype = arg.type

            if not arg.method:
                raise ValueError('attribute %s has no access method' % arg.dest.name)

            expr = "pds."+arg.method.name+"()"
            if isinstance(arg.dest, Attribute) and arg.dest.shape:
                if atype.name == 'char':
                    # accessor returns char* and takes few indices
                    idx = ','.join(['0']*(len(arg.dest.shape.dims)-1))
                    expr = "pds."+arg.method.name+"("+idx+")"
                elif atype.value_type:
                    # accessor returns ndarray, we need pointer
                    expr = "pds."+arg.method.name+"().data()"
                
            if not atype.basic and not atype.external or isinstance(atype, Enum):
                expr = T("pds_to_psana($expr)")(expr=expr)
            ctor_args.append(expr)

        ctor_args = ', '.join(ctor_args)


        print >>self.inc, T("$psana_ns::$typename pds_to_psana($pdsdata_ns::$typename pds);\n")\
            (self.__dict__, typename=typename)

        print >>self.cpp, T("$psana_ns::$typename pds_to_psana($pdsdata_ns::$typename pds)\n{")\
            (self.__dict__, typename=typename)
        print >>self.cpp, T("  return $psana_ns::$typename($ctor_args);")\
            (locals(), psana_ns=self.psana_ns)
        print >>self.cpp, "}\n"
        

    def _genAbsType(self, type):
        
        def _types(type):
            """Generator for the type list of the given type plus all it bases"""
            if type.base:
                for t in _types(type.base): yield t
            yield type
        
        self._log.debug("_genAbsType: type=%s", repr(type))

        pdstypename = type.fullName('C++', self.pdsdata_ns)
        psanatypename = type.fullName('C++', self.psana_ns)

        declarations = [] 
        implementations = [] 

        implementations += self._genCtorImpl(type)
        
        if type.xtcConfig:
            implementations += ["template <typename Config>", \
                                T("$name<Config>::~$name()\n{\n}\n")[type]]
        else:
            implementations += [T("$name::~$name()\n{\n}\n")[type]]

        # declarations for public methods
        for t in _types(type):
            for meth in t.methods(): 
                if meth.access == 'public': 
                    decls, impls = self._genMethod(meth, type)
                    declarations += decls
                    implementations += impls

        # generate _shape() methods for array attributes
        for t in _types(type):
            for attr in t.attributes() :
                decls, impls = self._genAttrShapeDecl(attr, type)
                declarations += decls
                implementations += impls

        members = []

        # declarations for data members
        for attr in type.attributes() :
            members += self._genAttrDecl(attr)
        
        print >>self.inc, _TEMPL('abs_type_decl').render(locals())

        for cfg in type.xtcConfig:
            implementations += [T("template class $name<$config>;")(name=type.name, config=cfg.fullName('C++', self.pdsdata_ns))]

        for impl in implementations:
            print >>self.cpp, impl


    def _genMethod(self, meth, type):
        """Generate method declaration and definition, return 2-tuple 
        of lists, first list is declarations, second list is implementations"""

        self._log.debug("_genMethod: meth: %s", meth)
        
        if meth.attribute:
            
            # generate access method for a named attribute
            
            attr = meth.attribute

            if attr.type.basic:
                
                cfgNeeded = _hasconfig(str(attr.offset))
                cvt = attr.type is not attr.stor_type
                shptr = False

                args = []
                rettype = attr.type.fullName('C++', self.psana_ns)
                if attr.shape :
                    cfgNeeded = cfgNeeded or any(_hasconfig(str(d)) for d in attr.shape.dims)
                    if attr.type.name == 'char':
                        rettype = "const char*"
                        args = [('i%d'%i, type.lookup('uint32_t')) for i in range(len(attr.shape.dims)-1)]
                    else:
                        rettype = attr.stor_type.fullName('C++', self.psana_ns)
                        cvt = False
                        shptr = True
                        rettype = T("ndarray<const $type, $rank>")(type=rettype, rank=len(attr.shape.dims))
                return self._genFwdMeth(meth.name, rettype, type, cfgNeeded, cvt, args=args, shptr=shptr)
            
            else:

                decls = []
                impls = []

                psana_type = attr.type.fullName('C++', self.psana_ns)
                classname = type.name
                if type.xtcConfig:
                    classname += '<Config>'
                    impls += ['template <typename Config>']

                if not attr.shape:
                    
                    # attribute is a regular non-array object
                    decls += [T("virtual const $type& $name() const;")(type=psana_type, name=meth.name)]
                    impls += [T("const $type& $classname::$name() const { return $attr; }")\
                            (type=psana_type, classname=classname, name=meth.name, attr=attr.name)]
                        
                elif attr.type.value_type:
                    
                    # attribute is an array accessed through ndarray
                    ndarray = T("ndarray<const $type, $rank>")(type=psana_type, rank=len(attr.shape.dims))
                    decls += [T("virtual $type $name() const;")(type=ndarray, name=meth.name)]
                    expr = T("${name}_ndarray_storage_")(name=attr.name)
                    impls += [T("$type $classname::$name() const { return $expr; }")\
                            (type=ndarray, classname=classname, name=meth.name, expr=expr)]
                        
                else:
    
                    # attribute is an array object, return pointer for basic types,
                    # or reference to elements for composite types
                    expr = attr.name + _dimexpr(attr.shape)
                    decls += [T("virtual const $type& $meth($args) const;")\
                              (type=psana_type, meth=meth.name, args=_dimargs(attr.shape))]
                    impls += [T("const $type& $classname::$meth($args) const { return $expr; }")\
                              (type=psana_type, classname=classname, meth=meth.name, args=_dimargs(attr.shape), expr=expr)]
                    
                return decls, impls

        else:

            # explicitly declared method with optional expression
            
            if meth.name == "_sizeof" : return [], []
            
            # check if config object is needed
            body = meth.code.get("C++")
            if not body : body = meth.code.get("Any")
            if not body :
                expr = meth.expr.get("C++")
                if not expr : expr = meth.expr.get("Any")
                if expr:
                    body = expr
                    if type: body = T("return $expr;")(locals())
            cfgNeeded = body and _hasconfig(body)

            # if no type given then it does not return anything
            rettype = meth.type
            cvt = False
            if rettype is None:
                rettype = "void"
            elif isinstance(rettype, Enum):
                if meth.rank > 0:
                    # use base integer type for returning arrays of enums
                    rettype = rettype.base.fullName('C++', self.psana_ns)
                    rettype = T("ndarray<const $type, $rank>")(type=rettype, rank=meth.rank)
                else:
                    cvt = True
                    rettype = rettype.fullName('C++', self.psana_ns)
            elif rettype.basic and not isinstance(rettype, Enum):
                rettype = rettype.fullName('C++', self.psana_ns)
                if meth.rank > 0:
                    rettype = T("ndarray<const $type, $rank>")(type=rettype, rank=meth.rank)
            else:
                cvt = True
                rettype = rettype.fullName('C++', self.psana_ns)
                if meth.rank > 0:
                    rettype = T("ndarray<const $type, $rank>")(type=rettype, rank=meth.rank)

            return self._genFwdMeth(meth.name, rettype, type, cfgNeeded, cvt, meth.args)

    def _genFwdMeth(self, name, typedecl, type, cfgNeeded=False, cvt=False, args=None, shptr=False):
        """Generate forwarding method declaration and definition, return 2-tuple 
        of lists, first list is declarations, second list is implementations"""
        
        args = args or []
        
        argdecl = ['%s %s' % (atype.fullName('C++'), aname) for aname, atype in args]
        argdecl = ', '.join(argdecl)
        
        passargs = [aname for aname, _ in args]
        if cfgNeeded : passargs = ['*m_cfgPtr'] + passargs
        if shptr: passargs += ['m_xtcObj']
        passargs = ', '.join(passargs)
        
        return [T("virtual $type $meth($args) const;")(type=typedecl, meth=name, args=argdecl)],\
            [_TEMPL('fwd_method_impl').render(locals())]

    def _genAttrDecl(self, attr):
        ''' return list of member declarations for attributes '''
        
        # basic types do not need conversion
        if attr.type.basic: return []
        
        # need corresponding psana type
        if attr.type.value_type:
            psana_type =  attr.type.fullName('C++', self.psana_ns)
        else :
            psana_type = attr.type.fullName('C++', self.top_pkg)
            if attr.type.xtcConfig: psana_type += '<Config>'

        if not attr.shape:
            
            return [T("$type $attr;")(type=psana_type, attr=attr.name)]

        elif attr.type.value_type:
            
            # for value types we return ndarray which needs contiguous memory
            return [T("ndarray<$type, $rank> ${attr}_ndarray_storage_;")(type=psana_type, attr=attr.name, rank=len(attr.shape.dims))]

        else :

            atype = psana_type
            for d in attr.shape.dims:
                atype = "std::vector< %s >" % atype
            return [T("$type $attr;")(type=atype, attr=attr.name)]


    def _genCtorImpl(self, type):

        self._log.debug("_genCtor: type: %s", type)

        base = type.fullName('C++', self.psana_ns)
        impls = []
            
        if type.size.value is not None:
            
            # member initialization
            memberinit = []
            for attr in type.attributes() :
                memberinit += self._genAttrInitNonArray(attr)

            # other code for initialization
            initcode = []
            for attr in type.attributes() :
                initcode += self._genAttrInitArray(attr)
                
            # if size is None manual implementation of the constructor will be provided
            impls += [_TEMPL('ctor_impl').render(locals())]
            
        return impls

    def _genAttrInitNonArray(self, attr):
        '''Returns the list of lines to be added afer constructor for 
        attribute data member initialization'''

        # all basic types are forwarded to xtc 
        if attr.type.basic: return []
        
        # arrays are initialized inside constructor
        if attr.shape: return []

        # how to get access to member
        if attr.access == 'public' :
            expr = T("xtcPtr->$name")[attr]
        elif attr.accessor is not None:
            expr = T("xtcPtr->$name()")[attr.accessor]

        # may need to mangle name
        name = attr.name

        if attr.type.external:
            return [T("$name($expr)")(locals())]
        elif attr.type.value_type:
            ns = attr.type.parent.fullName('C++', self.top_pkg)
            return [T("$name($ns::pds_to_psana($expr))")(locals())]
        elif attr.type.xtcConfig :
            xtc_type = attr.type.fullName('C++', self.pdsdata_ns)
            return [T("$name(boost::shared_ptr<const $xtc_type>(xtcPtr, &$expr), cfgPtr)")(locals())]
        else :
            xtc_type = attr.type.fullName('C++', self.pdsdata_ns)
            return [T("$name(boost::shared_ptr<const $xtc_type>(xtcPtr, &$expr))")(locals())]


    def _genAttrInitArray(self, attr):

        def subscr(r):
            return "".join(['[i%d]'%i for i in range(r)])
        def subscr_comma(r):
            return ",".join(['i%d'%i for i in range(r)])

        # all basic types are forwarded to xtc 
        if attr.type.basic: return []
        
        if not attr.shape: return []

        # may need to mangle name
        name = attr.name

        ndims = len(attr.shape.dims)

        # for value types we do ndarrays in separate method
        if attr.type.value_type: 
            return self._genAttrInitNDArray(attr)

        # config objects may be needed
        cfgNeeded = _hasconfig(str(attr.offset)) or _hasconfig(str(attr.type.size))

        code = ["  {"]
        
        cfg = ''
        if any(_hasconfig(str(d)) for d in attr.shape.dims):
            cfg = "*cfgPtr"
        code += [T("    const std::vector<int>& dims = xtcPtr->$meth($cfg);")(meth=attr.shape_method, cfg=cfg)]

        for r in range(ndims):
            idx = 'i%d'%r
            offset = "  "*(r+1)
            code += [offset+T("  $name$subscr.reserve(dims[$dim]);")(name=name, subscr=subscr(r), dim=r)]
            code += [offset+T("  for (int $i=0; $i != dims[$dim]; ++$i) {")(i=idx, dim=r)] 
            if r != ndims-1:
                code += [offset+T("    $name$subscr.resize(dims[$dim]);")(name=name, subscr=subscr(r), dim=r)]
            else:
                # how to get access to member
                if attr.access == 'public' :
                    expr = T("xtcPtr->$attr$subscr")(attr=attr.name, subscr=subscr(r+1))
                elif attr.accessor is not None:
                    if cfgNeeded:
                        expr = T("xtcPtr->$meth(*cfgPtr, $subscr)")(meth=attr.accessor.name, subscr=subscr_comma(r+1))
                    else:
                        expr = T("xtcPtr->$meth($subscr)")(meth=attr.accessor.name, subscr=subscr_comma(r+1))
                if attr.type.external:
                    pass
                elif attr.type.value_type:
                    ns = attr.type.parent.fullName('C++', self.top_pkg)
                    expr = T("$ns::pds_to_psana($expr)")(locals())
                else:
                    attrXtcType = attr.type.fullName('C++', self.pdsdata_ns)
                    code += [offset+T("    const $type& d = $expr;")(type=attrXtcType, expr=expr)]
                    code += [offset+T("    boost::shared_ptr<const $type> dPtr(m_xtcObj, &d);")(type=attrXtcType)]
                    expr = "dPtr"
                    typename = attr.type.fullName('C++', self.top_pkg)
                    if attr.type.xtcConfig: 
                        expr += ", cfgPtr"
                        typename += '<Config>'
                    expr = T("$type($expr)")(type=typename, expr=expr)
                code += [offset+T("    $name$subscr.push_back($expr);")(name=name, subscr=subscr(r), expr=expr)]

        for r in range(ndims):
            offset = "  "*(ndims-r)
            code += [offset+"  }"] 

        code += ["  }"]
        
        return code 

    def _genAttrInitNDArray(self, attr):

        pdstypename = attr.type.fullName('C++', self.pdsdata_ns)
        psanatypename = attr.type.fullName('C++', self.psana_ns)

        cfgNeeded = _hasconfig(str(attr.offset)) or any(_hasconfig(str(d)) for d in attr.shape.dims)
        cfg = "*cfgPtr" if cfgNeeded else ""

        cvt = None
        if not attr.type.external:
            cvt = attr.type.parent.fullName('C++', self.top_pkg) + '::pds_to_psana'

        # ndarray initialization
        return [_TEMPL('attr_init_ndarray').render(locals())]


    def _genAttrShapeDecl(self, attr, type):
        """Generate shape method declaration and definition, return 2-tuple 
        of lists, first list is declarations, second list is implementations"""

        if not attr.shape_method: return [], [] 
        if not attr.accessor: return [], []
        
        # value-type arrays return ndarrays which do not need shape method
        if attr.type.value_type and attr.type.name != 'char': return [], []

        if attr.type.basic:

            cfgNeeded = attr.shape and any(_hasconfig(str(d)) for d in attr.shape.dims)
            return self._genFwdMeth(attr.shape_method, "std::vector<int>", type, cfgNeeded)
            
        else:

            decls = [T("virtual std::vector<int> $meth() const;")(meth=attr.shape_method)]
            impls = [_TEMPL('shape_meth_impl').render(locals())]

            return decls, impls

#
#  In case someone decides to run this module
#
if __name__ == "__main__" :

    # In principle we can try to run test suite for this module,
    # have to think about it later. Right now just abort.
    sys.exit ( "Module is not supposed to be run as main module" )
