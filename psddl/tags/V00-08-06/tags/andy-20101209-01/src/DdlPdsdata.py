#--------------------------------------------------------------------------
# File and Version Information:
#  $Id$
#
# Description:
#  Module DdlPdsdata...
#
#------------------------------------------------------------------------

"""DDL parser which generates pdsdata C++ code.

This software was developed for the SIT project.  If you use all or 
part of it, please give an appropriate acknowledgment.

@see RelatedModule

@version $Id$

@author Andrei Salnikov
"""


#------------------------------
#  Module's version from CVS --
#------------------------------
__version__ = "$Revision$"
# $Source$

#--------------------------------
#  Imports of standard modules --
#--------------------------------
import sys
import os
import logging
import types

#---------------------------------
#  Imports of base class module --
#---------------------------------

#-----------------------------
# Imports for other modules --
#-----------------------------
from psddl.ExprVal import ExprVal
from psddl.Package import Package
from psddl.Type import Type

#----------------------------------
# Local non-exported definitions --
#----------------------------------

def _interpolate(expr, typeobj):
    
    expr = expr.replace('{xtc-config}', 'cfg')
    expr = expr.replace('{type}.', typeobj.name+"::")
    expr = expr.replace('{self}.', "this->")
    return expr

def _typename(type):
    
    return type.fullName().replace('.', '::')

#------------------------
# Exported definitions --
#------------------------

#---------------------
#  Class definition --
#---------------------
class DdlPdsdata ( object ) :

    #----------------
    #  Constructor --
    #----------------
    def __init__ ( self, incname, cppname ) :
        """Constructor
        
            @param incname  include file name
            @param cppname  source file name
        """
        self.incname = incname
        self.cppname = cppname

        #include guard
        w = os.path.split(self.incname)
        g = w[1]
        w = os.path.split(w[0])
        g = w[1] + '_' + g
        self.guard = g.replace('.', '_').upper()

    #-------------------
    #  Public methods --
    #-------------------

    def parseTree ( self, model ) :
        
        # open output files
        self.inc = file(self.incname, 'w')
        self.cpp = file(self.cppname, 'w')
        
        # include guard to header
        print >>self.inc, "#ifndef", self.guard 
        print >>self.inc, "#define", self.guard, "1"

        msg = "\n// *** Do not edit this file, it is auto-generated ***\n"
        print >>self.inc, msg
        print >>self.cpp, msg

        # add necessary includes
        print >>self.inc, "#include \"pdsdata/xtc/TypeId.hh\"\n"
        print >>self.cpp, "#include \"%s\"\n" % os.path.basename(self.incname)
        print >>self.cpp, "#include <cstddef>\n"

        # headers for other included packages
        for use in model.use:
            header = os.path.splitext(use)[0] + '.hh'
            print >>self.inc, "#include \"%s\"" % header

        # loop over packages in the model
        for pkg in model.packages() :
            logging.debug("parseTree: package=%s", repr(pkg))
            self._parsePackage(pkg)

        # close include guard
        print >>self.inc, "#endif //", self.guard

        # close all files
        self.inc.close()
        self.cpp.close()


    def _parsePackage(self, pkg):

        # open namespaces
        print >>self.inc, "namespace %s {" % pkg.name

        # enums for constants
        for const in pkg.constants() :
            if not const.external :
                print >>self.inc, "  enum {%s = %s};" % (const.name, const.value)

        # regular enums
        for enum in pkg.enums() :
            if not enum.external :
                print >>self.inc, "  enum %s {" % (enum.name or "",)
                for const in enum.constants():
                    val = ""
                    if const.value is not None : val = " = " + const.value
                    print >>self.inc, "    %s%s," % (const.name, val)
                print >>self.inc, "  };"

        # loop over packages and types
        for ns in pkg.namespaces() :
            
            if isinstance(ns, Package) :
                
                self._parsePackage(ns)
            
            elif isinstance(ns, Type) :
    
                type = ns
                logging.debug("_parsePackage: type=%s", repr(type))
    
                # skip external methods
                if type.external : continue
    
                # class-level comment
                print >>self.inc, "\n/** Class: %s\n  %s\n*/\n" % (type.name, type.comment)
    
                # declare config classes if needed
                for cfg in type.xtcConfig:
                    print >>self.inc, "class %s;" % cfg
    
                # C++ needs pack pragma
                if type.pack : 
                    print >>self.inc, "#pragma pack(push,%s)" % type.pack
    
                # start class declaration
                print >>self.inc, "\nclass %s {\npublic:" % type.name
    
                # enums for version and typeId
                if type.version is not None: print >>self.inc, "  enum {Version = %s};" % type.version
                if type.type_id is not None: print >>self.inc, "  enum {TypeId = Pds::TypeId::%s};" % type.type_id
    
                # enums for constants
                for const in type.constants() :
                    print >>self.inc, "  enum {%s = %s};" % (const.name, const.value)
    
                # regular enums
                for enum in type.enums() :
                    print >>self.inc, "  enum %s {" % (enum.name or "",)
                    for const in enum.constants() :
                        val = ""
                        if const.value is not None : val = " = " + const.value
                        print >>self.inc, "    %s%s," % (const.name, val)
                    print >>self.inc, "  };"
                        
                # data members
                access = "public"
                for attr in type.attributes() :
                    newaccess = attr.access or "private"
                    if newaccess != access:
                        print >>self.inc, "%s:" % newaccess
                        access = newaccess
                    self._genAttrDecl(attr)
    
                # all methods
                if type.methods: print >>self.inc, "public:"
                for meth in type.methods() :
                    self._genMethDecl(meth)
    
                # declaration/definition for next() methods
                self._genNextDecl(type)
    
                # close class declaration
                print >>self.inc, "};"
    
                # close pragma pack
                if type.pack : 
                    print >>self.inc, "#pragma pack(pop)"

        # close namespaces
        print >>self.inc, "} // namespace %s" % pkg.name

    def _genAttrDecl(self, attr):
        """Generate attribute declaration"""
        
        logging.debug("_genAttrDecl: attr: %s", attr)
        
        def _dims(shape):
            return ''.join(['[%s]'%d for d in shape.dims])
        
        if not attr.dimensions :
            decl = "  %s\t%s;" % (_typename(attr.type), attr.name)
        elif attr.isfixed():
            dim = _interpolate(_dims(attr.dimensions), attr.parent)
            decl = "  %s\t%s%s;" % (_typename(attr.type), attr.name, dim)
        else :
            dim = _interpolate(_dims(attr.dimensions), attr.parent)
            decl = "  //%s\t%s%s;" % (_typename(attr.type), attr.name, dim)
        if attr.comment : decl += "\t/** %s */" % attr.comment.strip()
        print >>self.inc, decl


    def _genMethDecl(self, meth):
        """Generate method declaration and definition"""
        
        attr = meth.attribute
        if attr:
            if not attr.dimensions:
                print >>self.inc, "  %s %s() const { return %s; }" % (_typename(attr.type), meth.name, attr.name)
            elif attr.isfixed():
                print >>self.inc, "  const %s* %s() const { return %s; }" % (_typename(attr.type), meth.name, attr.name)
            else :
                
                offset = str(attr.offset)
                cfgNeeded = offset.find('{xtc-config}') >= 0
                offset = _interpolate(offset, meth.parent)

                if cfgNeeded :

                    if not meth.parent.xtcConfig :
                        raise ValueError('xtc-config is not defined')
                    
                    for cfg in meth.parent.xtcConfig:
                        self._genAccessMethod(_typename(meth.parent), meth.name, _typename(attr.type), offset, cfg)

                else:
                    
                    self._genAccessMethod(_typename(meth.parent), meth.name, _typename(attr.type), offset)

        elif meth.bitfield:

            bf = meth.bitfield
            expr = bf.expr()
            cfgNeeded = expr.find('{xtc-config}') >= 0
            expr = _interpolate(expr, meth.parent)

            if cfgNeeded :

                if not meth.parent.xtcConfig :
                    raise ValueError('xtc-config is not defined')
                
                for cfg in meth.parent.xtcConfig:
                    self._genMethodExpr(meth.name, _typename(meth.type), expr, cfg)

            else:
                self._genMethodExpr(meth.name, _typename(meth.type), expr)

        else:
            print >>self.inc, "  %s %s() const;" % (meth.type, meth.name)


    def _genAccessMethod(self, typename, methname, rettype, offset, cfg=None):
        
        if cfg: 
            cfg = "const %s& cfg" % cfg
        else:
            cfg = ""
        
        print >>self.inc, "  const %s* %s(%s) const;" % (rettype, methname, cfg)
        
        print >>self.cpp, "const %s* %s::%s(%s) const {" % (rettype, typename, methname, cfg)
        print >>self.cpp, "  ptrdiff_t offset=%s;" % (offset,)
        print >>self.cpp, "  return (const %s*)(((const char*)this)+offset);" % (rettype,)  
        print >>self.cpp, "}\n"


    def _genMethodExpr(self, methname, rettype, expr, cfg=None):
        
        if cfg:
            cfg = "const %s& cfg" % cfg
        else:
            cfg = ""
        
        print >>self.inc, "  %s %s(%s) const {" % (rettype, methname, cfg)
        print >>self.inc, "    return %s(%s);" % (rettype, expr)
        print >>self.inc, "  }\n"

        

    def _genNextDecl(self, typeobj):
        """Generate declarations and definitions for next() method"""

        if not typeobj.repeat: return

        # check if we need config object
        objSize = str(typeobj.size)
        cfgNeeded = objSize.find('{xtc-config}') >= 0
        objSize = _interpolate(objSize, typeobj)
                    
        if cfgNeeded :
            
            if not typeobj.xtcConfig :
                raise ValueError('xtc-config is not defined')

            for cfg in typeobj.xtcConfig:
                self._genAccessMethod(_typename(typeobj), "next", _typename(typeobj), objSize, cfg)

        else:
            self._genAccessMethod(_typename(typeobj), "next", _typename(typeobj), objSize)



#
#  In case someone decides to run this module
#
if __name__ == "__main__" :

    # In principle we can try to run test suite for this module,
    # have to think about it later. Right now just abort.
    sys.exit ( "Module is not supposed to be run as main module" )
