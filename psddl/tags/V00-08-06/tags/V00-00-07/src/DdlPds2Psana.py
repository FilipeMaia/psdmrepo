#--------------------------------------------------------------------------
# File and Version Information:
#  $Id$
#
# Description:
#  Module DdlPds2Psana...
#
#------------------------------------------------------------------------

"""DDL parser which generates pds2psana C++ code.

This software was developed for the SIT project.  If you use all or 
part of it, please give an appropriate acknowledgment.

@see RelatedModule

@version $Id$

@author Andrei Salnikov
"""


#------------------------------
#  Module's version from CVS --
#------------------------------
__version__ = "$Revision$"
# $Source$

#--------------------------------
#  Imports of standard modules --
#--------------------------------
import sys
import os
import logging
import types

#---------------------------------
#  Imports of base class module --
#---------------------------------

#-----------------------------
# Imports for other modules --
#-----------------------------
from psddl.Attribute import Attribute
from psddl.Enum import Enum
from psddl.Package import Package
from psddl.Type import Type

#----------------------------------
# Local non-exported definitions --
#----------------------------------

def _interpolate(expr):
    expr = expr.replace('{xtc-config}.', 'cfgPtr->')
    expr = expr.replace('{self}.', "m_xtcObj->")
    return expr

def _dimargs(shape):
    if not shape : return []
    return ', '.join(['uint32_t i%d'%i for i, r in enumerate(shape.dims)])

def _dimexpr(shape):
    return ''.join(['[i%d]'%i for i in range(len(shape.dims))])

def _dimarray(shape):
    return ', '.join([_interpolate(str(s)) for s in shape.dims])

#------------------------
# Exported definitions --
#------------------------

#---------------------
#  Class definition --
#---------------------
class DdlPds2Psana ( object ) :

    #----------------
    #  Constructor --
    #----------------
    def __init__ ( self, incname, cppname, backend_options ) :
        """Constructor
        
            @param incname  include file name
        """
        self.incname = incname
        self.cppname = cppname
        self.incdirname = backend_options.get('gen-incdir', "")
        self.top_pkg = backend_options.get('top-package')
        self.psana_inc = backend_options.get('psana-inc', "")
        self.pdsdata_inc = backend_options.get('pdsdata-inc', "")
        self.psana_ns = backend_options.get('psana-ns', "")
        self.pdsdata_ns = backend_options.get('pdsdata-ns', "")

        #include guard
        g = os.path.split(self.incname)[1]
        if self.top_pkg: g = self.top_pkg + '_' + g
        self.guard = g.replace('.', '_').upper()

    #-------------------
    #  Public methods --
    #-------------------

    def parseTree ( self, model ) :
        
        # open output files
        self.inc = file(self.incname, 'w')
        self.cpp = file(self.cppname, 'w')

        # include guard to header
        print >>self.inc, "#ifndef", self.guard 
        print >>self.inc, "#define", self.guard, "1"

        msg = "\n// *** Do not edit this file, it is auto-generated ***\n"
        print >>self.inc, msg
        print >>self.cpp, msg

        print >>self.inc, "#include <vector>"
        print >>self.inc, "#include <boost/shared_ptr.hpp>"

        inc = os.path.join(self.incdirname, os.path.basename(self.incname))
        print >>self.cpp, "#include \"%s\"\n" % inc
        print >>self.cpp, "#include <cstddef>\n"
        print >>self.cpp, "#include <stdexcept>\n"

        # headers for psana and pdsdata includes
        inc = os.path.join(self.psana_inc, os.path.basename(self.incname))
        print >>self.inc, "#include \"%s\"" % inc
        inc = os.path.join(self.pdsdata_inc, os.path.basename(self.incname))
        print >>self.inc, "#include \"%s\"" % inc

        # headers for other included packages
        for use in model.use:
            path = use['file']
            headers = use['cpp_headers']
            if not headers:
                header = os.path.splitext(path)[0] + '.h'
                header = os.path.join(self.incdirname, os.path.basename(header))
                headers = [header]
            for header in headers:
                print >>self.inc, "#include \"%s\"" % header

        if self.top_pkg : 
            print >>self.inc, "namespace %s {" % self.top_pkg
            print >>self.cpp, "namespace %s {" % self.top_pkg

        # loop over packages in the model
        for pkg in model.packages() :
            if not pkg.included :
                logging.debug("parseTree: package=%s", repr(pkg))
                self._parsePackage(pkg)

        if self.top_pkg : 
            print >>self.inc, "} // namespace %s" % self.top_pkg
            print >>self.cpp, "} // namespace %s" % self.top_pkg

        # close include guard
        print >>self.inc, "#endif //", self.guard

        # close all files
        self.inc.close()
        self.cpp.close()


    def _parsePackage(self, pkg):

        # open namespaces
        print >>self.inc, "namespace %s {" % pkg.name
        print >>self.cpp, "namespace %s {" % pkg.name

        # regular enums
        for enum in pkg.enums() :
            if not enum.included :
                self._genEnum(enum)

        # loop over packages and types
        for ns in pkg.namespaces() :
            
            if isinstance(ns, Package) :
                
                self._parsePackage(ns)
            
            elif isinstance(ns, Type) :
    
                self._parseType(type = ns)

        # close namespaces
        print >>self.inc, "} // namespace %s" % pkg.name
        print >>self.cpp, "} // namespace %s" % pkg.name

    def _genEnum(self, enum):

        logging.debug("_genEnum: type=%s", repr(enum))

        if not enum.name: return

        pdstypename = enum.fullName('C++', self.pdsdata_ns)
        psanatypename = enum.fullName('C++', self.psana_ns)
        
        print >>self.cpp, "%s pds_to_psana(%s e)\n{\n  return %s(e);\n}\n" % \
            (psanatypename, pdstypename, psanatypename)


    def _parseType(self, type):

        logging.debug("_parseType: type=%s", repr(type))

        # skip included types
        if type.included : return

        # regular enums
        for enum in type.enums() :
            self._genEnum(enum)

        if not type.value_type :
            
            self._genAbsType(type)
            
        else:
            
            self._genValueType(type)


    def _genValueType(self, type):

        # find attribute for a given name
        def name2attr(name, type):
            
            if not name: return None
            
            # try argument name
            attr = type.localName(name)
            if isinstance(attr, Attribute): return attr
            
            # look for bitfield names also
            for attr in type.attributes():
                for bf in attr.bitfields:
                    if bf.name == name: return bf

        logging.debug("_genValueType: type=%s", repr(type))

        typename = type.fullName('C++')

        # need to call a non-default constructor on a type
        ctor = None
        for c in type.ctors:
            if c.args or 'auto' in c.tags:
                if ctor:
                    logging.warning('Constructor overload for %s, using first constructor', typename)
                else:
                    ctor = c

        if not ctor : 
            logging.warning('No suitable constructor defined for %s', typename)
            return

        args = []
        if 'auto' in ctor.tags:
            # make one argument per type attribule
            for attr in type.attributes():
                name = "arg_"+attr.name
                atype = attr.type
                dest = attr
                args.append((name, atype, dest))
        else:
            # convert destination names to attribute objects
            args = [(name, atype, name2attr(dest, type)) for name, atype, dest in ctor.args]

        logging.debug("_genValueType: ctor args=%s", repr(args))
        
        ctor_args = []
        for aname, atype, dest in args:

            if not atype: atype = dest.type
            
            if isinstance(dest,Attribute) and dest.access == 'public':
                expr = "pds."+dest.name
            elif dest.accessor:
                expr = "pds."+dest.accessor.name+"()"
            else:
                raise ValueError('attribute %s has no access method' % dest.name)
                
            if not atype.basic and not isinstance(atype, Enum):
                expr = "pds_to_psana(%s)" % expr
            ctor_args.append(expr)

        ctor_args = ', '.join(ctor_args)


        print >>self.inc, "%s::%s pds_to_psana(%s::%s pds);\n" % \
            (self.psana_ns, typename, self.pdsdata_ns, typename)

        print >>self.cpp, "%s::%s pds_to_psana(%s::%s pds)\n{" % \
            (self.psana_ns, typename, self.pdsdata_ns, typename)
        print >>self.cpp, "  return %s::%s(%s);" % \
            (self.psana_ns, typename, ctor_args)
        print >>self.cpp, "}\n"
        

    def _genAbsType(self, type):
        
        def _types(type):
            """Generator for the type list of the given type plus all it bases"""
            if type.base:
                for t in _types(type.base): yield t
            yield type
        
        logging.debug("_genAbsType: type=%s", repr(type))

        pdstypename = type.fullName('C++', self.pdsdata_ns)
        psanatypename = type.fullName('C++', self.psana_ns)

        print >>self.inc, "\nclass %s : public %s {\npublic:" % (type.name, psanatypename)

        print >>self.inc, "  typedef %s XtcType;" % (pdstypename, )
        print >>self.inc, "  typedef %s PsanaType;" % (psanatypename)
        
        configs = type.xtcConfig or [None]
        for cfgnum, cfg in enumerate(configs):
            self._genCtor(type, cfg, cfgnum)
        
        print >>self.inc, "  virtual ~%s();" % type.name
        print >>self.cpp, "%s::~%s()\n{\n}\n" % (type.name, type.name)

        # declarations for public methods 
        for t in _types(type):
            for meth in t.methods(): 
                if meth.access == 'public': self._genMethDecl(meth, type)

        # generate method declaration for public members without accessors
        for t in _types(type):
            for attr in t.attributes() :
                if attr.access == "public" and attr.accessor is None:
                    self._genPubAttrMethod(attr, type)

        # generate _shape() methods for array attributes
        for t in _types(type):
            for attr in t.attributes() :
                self._genAttrShapeDecl(attr, type)

        print >>self.inc, "  const XtcType& _xtcObj() const { return *m_xtcObj; }"

        print >>self.inc, "private:"

        print >>self.inc, "  boost::shared_ptr<const XtcType> m_xtcObj;"
        
        # declaration for config pointers
        configs = type.xtcConfig or []
        for cfgnum, cfg in enumerate(configs):
            print >>self.inc, "  boost::shared_ptr<const %s> m_cfgPtr%i;" % \
                (cfg.fullName('C++', self.pdsdata_ns), cfgnum)
        
        # declarations for data members
        for attr in type.attributes() :
            self._genAttrDecl(attr)

        # close class declaration
        print >>self.inc, "};\n"


    def _genMethDecl(self, meth, type):
        """Generate method declaration and definition"""

        logging.debug("_genMethDecl: meth: %s", meth)
        
        if meth.attribute:
            
            # generate access method for a named attribute
            
            attr = meth.attribute

            if attr.type.basic:
                
                cfgNeeded = False
                if '{xtc-config}' in str(attr.offset) : cfgNeeded = True

                rettype = attr.type.fullName('C++')
                if attr.shape:
                    rettype = "const "+rettype+'*'
                self._genFwdMeth(meth.name, rettype, type, cfgNeeded)
            
            else:

                psana_type = attr.type.fullName('C++', self.psana_ns)

                if not attr.shape:
                    
                    # attribute is a regular non-array object
                    print >>self.inc, "  virtual const %s& %s() const;" % \
                            (psana_type, meth.name)
                    print >>self.cpp, "\nconst %s& %s::%s() const { return %s; }" % \
                            (psana_type, type.name, meth.name, attr.name)
                        
                else:
    
                    # attribute is an array object, return pointer for basic types,
                    # or reference to elements for composite types
                    expr = attr.name + _dimexpr(attr.shape)
                    print >>self.inc, "  virtual const %s& %s(%s) const;" % \
                            (psana_type, meth.name, _dimargs(attr.shape))
                    print >>self.cpp, "\nconst %s& %s::%s(%s) const { return %s; }" % \
                            (psana_type, type.name, meth.name, _dimargs(attr.shape), expr)

        else:

            # explicitly declared method with optional expression
            
            if meth.name == "_sizeof" : return
            
            expr = meth.expr.get("C++")
            if not expr : expr = meth.expr.get("Any")
            cfgNeeded = False
            if expr: 
                cfgNeeded = expr.find('{xtc-config}') >= 0

            # if no type given then it does not return anything
            rettype = meth.type
            cvt = False
            if rettype is None:
                rettype = "void"
            elif rettype.basic and not isinstance(rettype, Enum):
                rettype = rettype.fullName('C++')
            else:
                cvt = True
                rettype = rettype.fullName('C++', self.psana_ns)

            self._genFwdMeth(meth.name, rettype, type, cfgNeeded, cvt, meth.args)

    def _genFwdMeth(self, name, typedecl, type, cfgNeeded=False, cvt=False, args=None):
        args = args or []
        
        argdecl = ['%s %s' % (atype.fullName('C++'), aname) for aname, atype in args]
        argdecl = ', '.join(argdecl)
        
        passargs = [aname for aname, atype in args]
        passargs = ', '.join(passargs)
        
        print >>self.inc, "  virtual %s %s(%s) const;" % (typedecl, name, argdecl)
        cfg = ''
        if cfgNeeded :
            print >>self.cpp, "\n%s %s::%s(%s) const {" % (typedecl, type.name, name, argdecl)
            for i in range(len(type.xtcConfig)):
                if cvt:
                    print >>self.cpp, "  if (m_cfgPtr%i.get()) return pds_to_psana(m_xtcObj->%s(*m_cfgPtr%i));" % (i, name, i)
                else:
                    print >>self.cpp, "  if (m_cfgPtr%i.get()) return m_xtcObj->%s(*m_cfgPtr%i);" % (i, name, i)
            print >>self.cpp, "  throw std::runtime_error(\"%s::%s: config object pointer is zero\");" % (type.name, name)    
            print >>self.cpp, "}\n"
        else:
            if cvt:
                print >>self.cpp, "\n%s %s::%s(%s) const { return pds_to_psana(m_xtcObj->%s(%s)); }" % \
                        (typedecl, type.name, name, argdecl, name, passargs)
            else:
                print >>self.cpp, "\n%s %s::%s(%s) const { return m_xtcObj->%s(%s); }" % \
                        (typedecl, type.name, name, argdecl, name, passargs)

    def _genAttrDecl(self, attr):
        
        if attr.type.basic: return
        
        # need corresponding psana type
        if 'value-type' not in attr.type.tags:
            psana_type = attr.type.fullName('C++', self.top_pkg)
        else :
            psana_type =  attr.type.fullName('C++', self.psana_ns)

        # may need to mangle name
        name = attr.name
        if attr.access == 'public' : name += "_pub_member_"
        
        if not attr.shape:
            
            print >>self.inc, "  %s %s;" % (psana_type, name)

        else :

            atype = psana_type     
            for d in attr.shape.dims:
                atype = "std::vector< %s >" % atype
            print >>self.inc, "  %s %s;" % (atype, name)


    def _genCtor(self, type, cfg, cfgnum):

        logging.debug("_genCtor: type: %s", type)

        args = "const boost::shared_ptr<const XtcType>& xtcPtr"
        if cfg :
            cfgName = cfg.fullName('C++', self.pdsdata_ns)
            args += ", const boost::shared_ptr<const %s>& cfgPtr" % cfgName
        if type.size.value is None:
            # special case when the data size have to be guessed from XTC size
            args += ", size_t xtcSize"
            
        print >>self.inc, "  %s(%s);" % (type.name, args)
        
        if type.size.value is not None:
            
            # if size is None manual implementation of the constructor will be provided
            
            print >>self.cpp, "%s::%s(%s)" % (type.name, type.name, args)
            print >>self.cpp, "  : %s()" % (type.fullName('C++', self.psana_ns))
            print >>self.cpp, "  , m_xtcObj(xtcPtr)"
            if cfg : print >>self.cpp, "  , m_cfgPtr%i(cfgPtr)" % cfgnum
            
            # member initialization
            for attr in type.attributes() :
                self._genAttrInitNonArray(attr)
            
            print >>self.cpp, "{"
    
            # member initialization
            for attr in type.attributes() :
                self._genAttrInitArray(attr)
                
            print >>self.cpp, "}"


    def _genAttrInitNonArray(self, attr):

        # all basic types are forwarded to xtc 
        if attr.type.basic: return
        
        # arrays are initialized inside constructor
        if attr.shape: return

        # how to get access to member
        if attr.access == 'public' :
            expr = "xtcPtr->%s" % attr.name
        elif attr.accessor is not None:
            expr = "xtcPtr->%s()" % attr.accessor.name

        # may need to mangle name
        name = attr.name
        if attr.access == 'public' : name += "_pub_member_"

        if attr.type.external:
            print >>self.cpp, "  , %s(%s)" % (name, expr)
        elif attr.type.value_type:
            ns = attr.type._parent.fullName('C++', self.top_pkg)
            print >>self.cpp, "  , %s(%s::pds_to_psana(%s))" % (name, ns, expr)
        else :
            xtc_type = attr.type.fullName('C++', self.pdsdata_ns)
            print >>self.cpp, "  , %s(boost::shared_ptr<const %s>(xtcPtr, &%s))" % (name, xtc_type, expr)


    def _genAttrInitArray(self, attr):

        def subscr(r):
            return "".join(['[i%d]'%i for i in range(r)])
        def subscr_comma(r):
            return ",".join(['i%d'%i for i in range(r)])

        # all basic types are forwarded to xtc 
        if attr.type.basic: return
        
        # arrays are initialized inside constructor
        if not attr.shape: return
        
        # may need to mangle name
        name = attr.name
        if attr.access == 'public' : name += "_pub_member_"

        ndims = len(attr.shape.dims)

        print >>self.cpp, "  {"
        
        cfgNeeded = False
        if str(attr.offset).find('{xtc-config}') >= 0:
            cfgNeeded = True
        if str(attr.type.size).find('{xtc-config}') >= 0:
            cfgNeeded = True
        
        cfg = ''
        for d in attr.shape.dims:
            if '{xtc-config}' in str(d) : cfg = "*cfgPtr"
        print >>self.cpp, "    const std::vector<int>& dims = xtcPtr->%s(%s);" % (attr.shape_method, cfg)

        for r in range(ndims):
            idx = 'i%d'%r
            offset = "  "*(r+1)
            print >>self.cpp, offset+"  %s%s.reserve(dims[%d]);" % (name, subscr(r), r)
            print >>self.cpp, offset+"  for (int %s=0; %s != dims[%d]; ++%s) {" % (idx, idx, r, idx) 
            if r != ndims-1:
                print >>self.cpp, offset+"    %s%s.resize(dims[%d]);" % (name, subscr(r), r)
            else:
                # how to get access to member
                if attr.access == 'public' :
                    expr = "xtcPtr->%s%s" % (attr.name, subscr(r+1))
                elif attr.accessor is not None:
                    if cfgNeeded:
                        expr = "xtcPtr->%s(*cfgPtr, %s)" % (attr.accessor.name, subscr_comma(r+1))
                    else:
                        expr = "xtcPtr->%s(%s)" % (attr.accessor.name, subscr_comma(r+1))
                if attr.type.external:
                    pass
                elif attr.type.value_type:
                    ns = attr.type._parent.fullName('C++', self.top_pkg)
                    expr = "%s::pds_to_psana(%s)" % (ns, expr)
                else:
                    attrXtcType = attr.type.fullName('C++', self.pdsdata_ns)
                    print >>self.cpp, offset+"    const %s& d = %s;" % (attrXtcType, expr)
                    print >>self.cpp, offset+"    boost::shared_ptr<const %s> dPtr(m_xtcObj, &d);" % attrXtcType
                    expr = "dPtr"
                    if attr.type.xtcConfig: expr += ", cfgPtr"
                    expr = "%s(%s)" % (attr.type.fullName('C++', self.top_pkg), expr)
                print >>self.cpp, offset+"    %s%s.push_back(%s);" % (name, subscr(r), expr)

        for r in range(ndims):
            offset = "  "*(ndims-r)
            print >>self.cpp, offset+"  }" 

        print >>self.cpp, "  }" 


    def _genAttrShapeDecl(self, attr, type):

        if not attr.shape_method: return 
        
        if attr.type.basic:

            cfgNeeded = False
            if attr.shape:
                for d in attr.shape.dims:
                    if '{xtc-config}' in str(d) : cfgNeeded = True
            self._genFwdMeth(attr.shape_method, "std::vector<int>", type, cfgNeeded)
            
        else:

            # may need to mangle name
            name = attr.name
            if attr.access == 'public' : name += "_pub_member_"

            shape = attr.shape.dims

            print >>self.inc, "  virtual std::vector<int> %s() const;" % (attr.shape_method)
            
            print >>self.cpp, "std::vector<int> %s::%s() const\n{" % (type.name, attr.shape_method)
            print >>self.cpp, "  std::vector<int> shape;" 
            print >>self.cpp, "  shape.reserve(%d);" % len(shape)
            v = name
            for s in shape:
                print >>self.cpp, "  shape.push_back(%s.size());" % v
                v += '[0]'
            print >>self.cpp, "  return shape;\n}\n"

    def _genPubAttrMethod(self, attr, type):
        """Generate virtual method declaration for accessing public attribute"""

        def subscr(r):
            return "".join(['[i%d]'%i for i in range(r)])
        def subscr_comma(r):
            return ",".join(['int i%d'%i for i in range(r)])

        logging.debug("_genPubAttrMethod: attr: %s", attr)
        
        if attr.type.basic:
            
            rettype = attr.type.fullName('C++')
            if attr.shape:
                rettype = "const "+rettype+'*'

            print >>self.inc, "  virtual %s %s() const;" % (rettype, attr.name)
            print >>self.cpp, "\n%s %s::%s() const { return m_xtcObj->%s; }" % (rettype, type.name, attr.name, attr.name)

        else:

            rettype = attr.type.fullName('C++', self.psana_ns)

            name = attr.name + "_pub_member_"
            
            argexpr = ''
            subexpr = ''
            if attr.shape:
                rank = len(attr.shape.dims)
                argexpr = subscr_comma(rank)
                subexpr = subscr(rank)
            
            print >>self.inc, "  virtual const %s& %s(%s) const;" % (rettype, attr.name, argexpr)
            print >>self.cpp, "\nconst %s& %s::%s(%s) const { return %s%s; }" % \
                    (rettype, type.name, attr.name, argexpr, name, subexpr)
                

#
#  In case someone decides to run this module
#
if __name__ == "__main__" :

    # In principle we can try to run test suite for this module,
    # have to think about it later. Right now just abort.
    sys.exit ( "Module is not supposed to be run as main module" )
