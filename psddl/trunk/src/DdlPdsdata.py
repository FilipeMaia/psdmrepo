#--------------------------------------------------------------------------
# File and Version Information:
#  $Id$
#
# Description:
#  Module DdlPdsdata...
#
#------------------------------------------------------------------------

"""DDL parser which generates pdsdata C++ code.

This software was developed for the SIT project.  If you use all or 
part of it, please give an appropriate acknowledgment.

@see RelatedModule

@version $Id$

@author Andrei Salnikov
"""


#------------------------------
#  Module's version from CVS --
#------------------------------
__version__ = "$Revision$"
# $Source$

#--------------------------------
#  Imports of standard modules --
#--------------------------------
import sys
import os
import logging
import types

#---------------------------------
#  Imports of base class module --
#---------------------------------

#-----------------------------
# Imports for other modules --
#-----------------------------
from psddl.ExprVal import ExprVal

#----------------------------------
# Local non-exported definitions --
#----------------------------------

def _interpolate(expr, typeobj):
    
    expr = expr.replace('{xtc-config}', 'cfg')
    expr = expr.replace('{type}.', typeobj.name+"::")
    expr = expr.replace('{self}.', "this->")
    return expr

#------------------------
# Exported definitions --
#------------------------

#---------------------
#  Class definition --
#---------------------
class DdlPdsdata ( object ) :

    #----------------
    #  Constructor --
    #----------------
    def __init__ ( self, incname, cppname ) :
        """Constructor
        
            @param incname  include file name
            @param cppname  source file name
        """
        self.incname = incname
        self.cppname = cppname

        #include guard
        w = os.path.split(self.incname)
        g = w[1]
        w = os.path.split(w[0])
        g = w[1] + '_' + g
        self.guard = g.replace('.', '_').upper()

    #-------------------
    #  Public methods --
    #-------------------

    def parseTree ( self, model ) :
        
        # open output files
        self.inc = file(self.incname, 'w')
        self.cpp = file(self.cppname, 'w')
        
        # include guard to header
        print >>self.inc, "#ifndef", self.guard 
        print >>self.inc, "#define", self.guard, "1"

        msg = "\n// *** Do not edit this file, it is auto-generated ***\n"
        print >>self.inc, msg
        print >>self.cpp, msg

        # add necessary includes
        print >>self.inc, "#include \"pdsdata/xtc/TypeId.hh\"\n"
        print >>self.cpp, "#include \"%s\"\n" % os.path.basename(self.incname)
        print >>self.cpp, "#include <cstddef>\n"

        # loop over packages in the model
        for pkg in model.packages() :
            self._parsePackage(pkg)

        # close include guard
        print >>self.inc, "#endif //", self.guard

        # close all files
        self.inc.close()
        self.cpp.close()


    def _parsePackage(self, pkg):

        # open namespaces
        print >>self.inc, "namespace %s {" % pkg.name
        print >>self.cpp, "namespace %s {" % pkg.name

        # enums for constants
        for const in pkg.constants() :
            print >>self.inc, "  enum {%s = %s};" % const

        # regular enums
        for enum in pkg.enums() :
            print >>self.inc, "  enum %s {" % (enum[0] or "",)
            for const in enum[1]:
                val = ""
                if const[1] : val = " = " + const[1]
                print >>self.inc, "    %s%s," % (const[0], val)
            print >>self.inc, "  };"
                    

        # loop over types/classes
        for type in pkg.types() :

            # calculate offsets for the data members
            self._calcOffsets(type)

            # class-level comment
            print >>self.inc, "\n/** Class: %s\n  %s\n*/\n" % (type.name, type.comment)

            # declare config classes if needed
            for cfg in type.xtcConfig:
                print >>self.inc, "class %s;" % cfg

            # C++ needs pack pragma
            if type.pack : 
                print >>self.inc, "#pragma pack(push,%s)" % type.pack

            # start class declaration
            print >>self.inc, "\nclass %s {\npublic:" % type.name

            # enums for version and typeId
            if type.version is not None: print >>self.inc, "  enum {Version = %s};" % type.version
            if type.type_id is not None: print >>self.inc, "  enum {TypeId = Pds::TypeId::%s};" % type.type_id

            # enums for constants
            for const in type.constants() :
                print >>self.inc, "  enum {%s = %s};" % (const.name, const.value)

            # regular enums
            for enum in type.enums() :
                print >>self.inc, "  enum %s {" % (enum.name or "",)
                for const in enum.constants() :
                    val = ""
                    if const.value is not None : val = " = " + const.value
                    print >>self.inc, "    %s%s," % (const.name, val)
                print >>self.inc, "  };"
                    
            # data members
            access = "public"
            for attr in type.attributes() :
                newaccess = attr.access or "private"
                if newaccess != access:
                    print >>self.inc, "%s:" % newaccess
                    access = newaccess
                self._genAttrDecl(attr)

            # all methods
            if type.methods: print >>self.inc, "public:"
            for meth in type.methods() :
                self._genMethDecl(meth)

            # declaration/definition for next() methods
            self._genNextDecl(type)

            # close class declaration
            print >>self.inc, "};"

            # close pragma pack
            if type.pack : 
                print >>self.inc, "#pragma pack(pop)"

        # loop over packages
        for spkg in pkg.packages() :
            self._parsePackage(spkg)
            
        # close namespaces
        print >>self.inc, "} // end namespace %s" % pkg.name
        print >>self.cpp, "} // end namespace %s" % pkg.name

    def _genAttrDecl(self, attr):
        """Generate attribute declaration"""
        
        logging.debug("_genAttrDecl: attr: %s", attr)
        
        def _dims(shape):
            return ''.join(['[%s]'%d for d in shape.dims])
        
        if not attr.dimensions :
            decl = "  %s\t%s;" % (attr.type.name, attr.name)
        elif attr.isfixed():
            dim = _interpolate(_dims(attr.dimensions), attr.parent)
            decl = "  %s\t%s%s;" % (attr.type.name, attr.name, dim)
        else :
            dim = _interpolate(_dims(attr.dimensions), attr.parent)
            decl = "  //%s\t%s%s;" % (attr.type.name, attr.name, dim)
        if attr.comment : decl += "\t/** %s */" % attr.comment.strip()
        print >>self.inc, decl


    def _genMethDecl(self, meth):
        """Generate method declaration and definition"""
        
        attr = meth.attribute
        if attr:
            if not attr.dimensions:
                print >>self.inc, "  %s %s() const { return %s; }" % (attr.type.name, meth.name, attr.name)
            elif attr.isfixed():
                print >>self.inc, "  const %s* %s() const { return %s; }" % (attr.type.name, meth.name, attr.name)
            else :
                
                offset = str(attr.offset)
                cfgNeeded = offset.find('{xtc-config}') >= 0
                offset = _interpolate(offset, meth.parent)

                if cfgNeeded :

                    if not meth.parent.xtcConfig :
                        raise ValueError('xtc-config is not defined')
                    
                    for cfg in meth.parent.xtcConfig:
                        self._genAccessMethod(meth.parent.name, meth.name, attr.type.name, offset, cfg)

                else:
                    
                    self._genAccessMethod(meth.parent.name, meth.name, attr.type.name, offset)

        else:
            print >>self.inc, "  %s %s() const;" % (meth.type, meth.name)


    def _genAccessMethod(self, typename, methname, rettype, offset, cfg=None):
        
        if cfg: 
            cfg = "const %s& cfg" % cfg
        else:
            cfg = ""
        
        print >>self.inc, "  const %s* %s(%s) const;" % (rettype, methname, cfg)
        
        print >>self.cpp, "const %s* %s::%s(%s) const {" % (rettype, typename, methname, cfg)
        print >>self.cpp, "  ptrdiff_t offset=%s;" % (offset,)
        print >>self.cpp, "  return (const %s*)(((const char*)this)+offset);" % (rettype,)  
        print >>self.cpp, "}\n"

        

    def _genNextDecl(self, typeobj):
        """Generate declarations and definitions for next() method"""

        if not typeobj.repeat: return

        # check if we need config object
        objSize = str(typeobj.size)
        cfgNeeded = objSize.find('{xtc-config}') >= 0
        objSize = _interpolate(objSize, typeobj)
                    
        if cfgNeeded :
            
            if not typeobj.xtcConfig :
                raise ValueError('xtc-config is not defined')

            for cfg in typeobj.xtcConfig:
                self._genAccessMethod(typeobj.name, "next", typeobj.name, objSize, cfg)

        else:
            self._genAccessMethod(typeobj.name, "next", typeobj.name, objSize)


    def _calcOffsets(self, typeobj):
        """Calculate offsets for all members of the type"""

        logging.debug("_calcOffsets: type=%s", typeobj)

        offset = ExprVal(0)
        maxalign = 1
        for attr in typeobj.attributes():

            logging.debug("_calcOffsets: offset=%s attr=%s", offset, attr)

            align = attr.align()
            if align : maxalign = max(maxalign, align)

            if attr.offset is None:
                
                # need to calculate offset for this attribute
            
                if type(offset.value) == types.IntType:
                
                    # no explicit offset - use implicit but check alignment
                    align = attr.align()
                    if align is None:
                        logging.warning('unknown alignment for %s %s.%s', attr.type.name, typeobj.name, attr.name)
                    else :
                        if typeobj.pack: align = min(align, typeobj.pack)
                        if offset.value % align != 0:
                            logging.error('unaligned attribute %s %s.%s', attr.type.name, typeobj.name, attr.name)
                            logging.error('implicit offset = %s, alignment = %s', offset, align)
                            logging.error('use pack="N" or add padding attributes')
                            raise TypeError('%s.%s unaligned attribute' % (typeobj.name, attr.name))
    
                    attr.offset = offset

                else:
    
                    # attribute has no offset defined, current offset is an expression
                    # no way now to evaluate expression and check it's alignment, so we 
                    # just accept 
                    attr.offset = offset

            else:

                # attribute already has an offset defined

                if type(attr.offset) is types.IntType and type(offset.value) is types.IntType:
                    
                    if attr.offset < offset.value :
                        logging.error('offset specification mismatch for %s.%s', typeobj.name, attr.name)
                        logging.error('implicit offset = %s, explicit offset = %s', offset, attr.offset)
                        raise TypeError('%s.%s offset mismatch' % (typeobj.name, attr.name))
                    elif attr.offset > offset.value :
                        # need padding
                        pad = attr.offset - offset
                        logging.error('extra padding needed before %s.%s', typeobj.name, attr.name)
                        raise TypeError('%s.%s extra padding needed' % (typeobj.name, attr.name))
                    else:
                        # this is what we expect
                        pass

                else:
                    
                    # at least one of them is an expression, currently there is no way 
                    # to verify that two expressions are the same
                    
                    logging.warning('%s.%s has pre-defined offset, make sure it has right value', typeobj.name, attr.name)
                    logging.warning('pre-defined offset = %s, computed offset = %s', attr.offset, offset)

                    # safer to reset offset to a pre-defined value
                    offset = ExprVal(attr.offset)

            # move to a next attribute
            offset = offset+attr.sizeBytes()

        if typeobj.pack: maxalign = min(maxalign, typeobj.pack)
        logging.debug("_calcOffsets: type=%s size=%s align=%s", repr(typeobj), offset, maxalign)
        typeobj.align = maxalign
        
        if typeobj.size:
            # size was already pre-defined
            if type(typeobj.size) is types.IntType and type(offset.value) is types.IntType:
                if typeobj.size != offset.value :
                    logging.error('object size mismatch for %s', typeobj.name)
                    logging.error('implicit size = %d, explicit size = %d', offset, typeobj.size)
                    raise TypeError('%s size mismatch' % typeobj.name)
            else:
                logging.warning('%s has pre-defined size, make sure it has right value', typeobj.name)
                logging.warning('pre-defined size = %s, computed size = %s', typeobj.size, offset)
        else:
            
            # set it to calculate value
            typeobj.size = offset

#
#  In case someone decides to run this module
#
if __name__ == "__main__" :

    # In principle we can try to run test suite for this module,
    # have to think about it later. Right now just abort.
    sys.exit ( "Module is not supposed to be run as main module" )
