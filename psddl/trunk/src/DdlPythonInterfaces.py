#--------------------------------------------------------------------------
# File and Version Information:
#  $Id: DdlPythonInterfaces.py 3643 2012-05-26 04:23:12Z jbarrera@SLAC.STANFORD.EDU $
#
# Description:
#  Module DdlPythonInterfaces...
#
#------------------------------------------------------------------------

"""DDL parser which generates psana C++ interfaces.

This software was developed for the SIT project.  If you use all or 
part of it, please give an appropriate acknowledgment.

@see RelatedModule

@version $Id: DdlPythonInterfaces.py 3643 2012-05-26 04:23:12Z jbarrera@SLAC.STANFORD.EDU $

@author Andrei Salnikov, Joseph S. Barrera III
"""


#------------------------------
#  Module's version from CVS --
#------------------------------
__version__ = "$Revision: 3643 $"
# $Source$

#--------------------------------
#  Imports of standard modules --
#--------------------------------
import sys
import os
import logging
import types
import string
import re

#---------------------------------
#  Imports of base class module --
#---------------------------------

#-----------------------------
# Imports for other modules --
#-----------------------------
from psddl.Attribute import Attribute
from psddl.ExprVal import ExprVal
from psddl.Method import Method
from psddl.Package import Package
from psddl.Template import Template as T
from psddl.Type import Type

#----------------------------------
# Local non-exported definitions --
#----------------------------------

def _interpolate(expr, typeobj):
    expr = expr.replace('{xtc-config}', 'cfg')
    expr = expr.replace('{type}.', typeobj.name+"::")
    expr = expr.replace('{self}.', "this->")
    return expr

def _typename(type, top_ns=None):
    if type is None: return 'void'
    return type.fullName('C++', top_ns)

def _typedecl(type, top_ns=None):
    typename = _typename(type, top_ns)
    if not type.basic : typename = "const "+typename+'&'
    return typename

def _argdecl(name, type):    
    return _typedecl(type) + ' ' + name

def _argdecl2(name, type):    
    return name

def _dims(dims):
    return ''.join(['[%s]'%d for d in dims])

def _dimargs(rank, type):
    int_type = type.lookup('uint32_t')
    return [('i%d'%i, int_type) for i in range(rank)]

def _dimexpr(dims):
    return ''.join(['[i%d]'%i for i in range(len(dims))])

#------------------------
# Exported definitions --
#------------------------

#---------------------
#  Class definition --
#---------------------
class DdlPythonInterfaces ( object ) :

    #----------------
    #  Constructor --
    #----------------
    def __init__ ( self, incname, cppname, backend_options ) :
        """Constructor
        
            @param incname  include file name
        """
        self.incname = incname
        self.cppname = cppname
        self.incdirname = backend_options.get('gen-incdir', "")
        self.top_pkg = backend_options.get('top-package')
        self.psana_ns = backend_options.get('psana-ns', "Psana")
        self.generics = {}

        #include guard
        g = os.path.split(self.incname)[1]
        if self.top_pkg: g = self.top_pkg + '_' + g
        self.guard = g.replace('.', '_').upper()

    #-------------------
    #  Public methods --
    #-------------------

    def parseTree ( self, model ) :
        
        # open output files
        self.inc = file(self.incname, 'w')
        self.cpp = file(self.cppname, 'w')

        warning = "/* Do not edit this file, as it is auto-generated */\n"
        print >>self.inc, warning
        print >>self.cpp, warning

        # include guard to header
        print >>self.inc, "#ifndef", self.guard 
        print >>self.inc, "#define", self.guard, "1"
        print >>self.inc, ""

        inc = os.path.join(self.incdirname, os.path.basename(self.incname))
        inc_base = self.incname
        index = inc_base.rfind("/")
        if index != -1:
            inc_base = inc_base[index+1:]
            print inc_base

        # add necessary includes to include file
        print >>self.inc, '#include <vector>'
        print >>self.inc, '#include "psddl_python/DdlWrapper.h"'
        print >>self.inc, '#include "psddl_python/Converter.h"'
        print >>self.inc, '#include "ndarray/ndarray.h"'
        print >>self.inc, '#include "pdsdata/xtc/TypeId.hh"'
        inc_psana = "psddl_psana/" + string.replace(inc_base, ".wrapper", "")
        print >>self.inc, '#include "%s" // inc_psana' % inc_psana
        print >>self.inc, ""

        # add necessary includes to source file
        print >>self.cpp, '#include <boost/make_shared.hpp>'
        inc_python = "psddl_python/" + inc_base
        print >>self.cpp, '#include "%s" // inc_python' % inc_python
        print >>self.cpp, '#include "psddl_python/ConverterMap.h"'
        print >>self.cpp, ""

        # headers for other included packages
        for use in model.use:
            path = use['file']
            headers = use['cpp_headers']
            if not headers:
                header = os.path.splitext(path)[0] + '.h'
                header = os.path.join(self.incdirname, os.path.basename(header))
                headers = [header]
            for header in headers:
                if "/" in header:
                    print >>self.inc, "#include <%s>" % header
                else:
                    print >>self.inc, "#include <psddl_psana/%s>" % header
                    wrapper_header = header[:len(header)-1] + "wrapper.h"
                    print >>self.inc, "#include <psddl_python/%s>" % wrapper_header

        if self.top_pkg : 
            print >>self.cpp, T("namespace $top_pkg {")[self]
            print >>self.inc, T("namespace $top_pkg {")[self]

        # loop over packages in the model
        for pkg in model.packages() :
            if not pkg.included :
                logging.debug("parseTree: package=%s", repr(pkg))
                self._parsePackage(pkg)

        if self.top_pkg : 
            print >>self.inc, T("} // namespace $top_pkg")[self]
            print >>self.cpp, T("} // namespace $top_pkg")[self]

        # close include guard
        print >>self.inc, "#endif //", self.guard

        # close all files
        self.inc.close()
        self.cpp.close()

    def namespace_prefix(self):
        prefix = self.pkg.name + "::"
        if self.top_pkg: prefix = self.top_pkg + "::" + prefix
        return prefix

    def _parsePackage(self, pkgX):
        self.pkg = pkgX

        # open namespaces
        print >>self.inc, T("namespace $name {")[self.pkg]
        print >>self.inc, ""
        print >>self.inc, "using namespace boost::python;"
        print >>self.inc, "using boost::python::api::object;"
        print >>self.inc, "using boost::shared_ptr;"
        print >>self.inc, "using std::vector;"
        print >>self.inc, ""
        print >>self.inc, "void createWrappers(PyObject* module);"

        print >>self.cpp, T("namespace $name {")[self.pkg]
        print >>self.cpp, ""

        print >>self.cpp, 'namespace {'
        # loop over types
        for ns in self.pkg.namespaces() :
            if isinstance(ns, Type) :
                type = ns
                cname = type.name
                wrapped = type.fullName('C++', self.psana_ns)
                print >>self.cpp, T('PyObject* method_typeid_$cname() {')(locals())
                print >>self.cpp, T('  static PyObject* ptypeid = PyCObject_FromVoidPtr((void*)&typeid($wrapped), 0);')(locals())
                print >>self.cpp, T('  Py_INCREF(ptypeid);\n  return ptypeid;\n}\n')(locals())
        print >>self.cpp, '} // namespace'


        print >>self.cpp, "void createWrappers(PyObject* module) {"

        # create sub-module for everything inside
        print >>self.cpp, T('  PyObject* submodule = Py_InitModule3( "psana.$name", 0, "The Python wrapper module for $name types");')[self.pkg]
        print >>self.cpp, '  Py_INCREF(submodule);'
        print >>self.cpp, T('  PyModule_AddObject(module, "$name", submodule);')[self.pkg]
        print >>self.cpp, '  scope mod = object(handle<>(borrowed(submodule)));'
        
        # loop over packages and types
        ndconverters = set()
        for ns in self.pkg.namespaces() :
            if isinstance(ns, Package) :
                print "Error: nested packages not supported:", ns
                continue
            if isinstance(ns, Type) :
                self._parseType(ns, ndconverters)

        # make the unversioned objects containing versioned types
        unmap = dict()
        for type in self.pkg.namespaces() :
            if isinstance(type, Type) and type.version is not None:
                vstr = "V"+str(type.version)
                if type.name.endswith(vstr):
                    unvtype = type.name[:-len(vstr)]
                    unmap.setdefault(unvtype, []).append(type.name)
        for unvtype, types in unmap.items():
            print >>self.cpp, T('  {\n    PyObject* unvlist = PyList_New($len);')(len=len(types))
            for i, type in enumerate(types):
                print >>self.cpp, T('    PyList_SET_ITEM(unvlist, $i, PyObject_GetAttrString(submodule, "$type"));')(locals())
            print >>self.cpp, T('    PyObject_SetAttrString(submodule, "$unvtype", unvlist);')(locals())
            print >>self.cpp, T('    Py_CLEAR(unvlist);\n  }')(locals())


        for type, ndim in ndconverters:
            print >>self.cpp, T('  detail::register_ndarray_to_numpy_cvt<const $type, $ndim>();')(locals())

        # end createWrappers()
        print >>self.cpp, ""
        print >>self.cpp, "} // createWrappers()"
        # now create converter classes
        for ns in self.pkg.namespaces() :
            if isinstance(ns, Type) :
                self._createConverterClass(type = ns)

        # close namespaces
        print >>self.inc, T("} // namespace $name")[self.pkg]
        print >>self.cpp, T("} // namespace $name")[self.pkg]

    def _parseType(self, type, ndconverters):

        logging.debug("_parseType: type=%s", repr(type))

        # skip included types
        if type.included : return

        self.codegen(type, ndconverters)

    def _createConverterClass(self, type):

        type_name = type.name
        psana_type_name = type.fullName('C++', self.psana_ns)

        print >>self.inc, ''
        print >> self.inc, T('  class ${type_name}_Converter : public psddl_python::Converter {')(locals())
        print >> self.inc, '  public:'
        print >> self.inc, T('    const std::type_info* typeinfo() const { return &typeid(${psana_type_name});}')(locals())
        print >> self.inc, T('    const char* getTypeName() const { return "${psana_type_name}";}')(locals())
        if type.version is not None:
            print >> self.inc, T('    int getVersion() const { return ${psana_type_name}::Version; }')(locals())
        if type.type_id is not None:
            print >> self.inc, T('    int pdsTypeId() const { return Pds::TypeId::${type_id}; }')(type_id=type.type_id)
        print >> self.inc, T('    object convert(const boost::shared_ptr<void>& vdata) const {')(locals())
        print >> self.inc, T('      shared_ptr<${psana_type_name}> result = boost::static_pointer_cast<${psana_type_name}>(vdata);')(locals())
        if type.value_type:
            print >> self.inc, T('      return result.get() ? object(*result) : object();')(locals())
        else:
            print >> self.inc, T('      return result.get() ? object(${type_name}_Wrapper(result)) : object();')(locals())
        print >> self.inc, '    }'
        print >> self.inc, '  };'

    def codegen(self, type, ndconverters):
        # type is abstract by default but can be reset with tag "value-type"
        abstract = not type.value_type

        self._type = type
        self._pkg_name = self.pkg.name

        logging.debug("codegen: type=%s", repr(type))
        #print "codegen: type=%s" % repr(type)

        # declare config classes if needed
        for cfg in type.xtcConfig:
            print >>self.inc, T("class $name;")[cfg]

        # base class
        base = ""

        # this class (class being generated)
        wrapped = type.fullName('C++', self.psana_ns)
        name = type.name + "_Wrapper"

        prefix = self.namespace_prefix()
        cname = type.name
        
        if not abstract:
            bclass = wrapped
        else:
            bclass = prefix + name
        
        print >>self.cpp, T('  class_<$bclass>("$cname", no_init)')(locals())

        if not type.value_type:
            # start class declaration
            print >>self.inc, T("\nclass $name$base {")(name = name, base = base)
            access = "private"
    
            # shared_ptr and C++ pointer to wrapped object
            print >>self.inc, T("  shared_ptr<const $wrapped> m_obj;")(wrapped = wrapped)
    
            # enums for version and typeId
            access = self._access("public", access)
            if type.type_id is not None: 
                print >>self.inc, T("  enum { TypeId = Pds::TypeId::$type_id };")(type_id=type.type_id)
            if type.version is not None: 
                print >>self.inc, T("  enum { Version = $version };")(version=type.version)
    
            # constructor
            access = self._access("public", access)
            print >>self.inc, T("  $name(const shared_ptr<const $wrapped>& obj) : m_obj(obj) {}")(locals())

        # generate methods (for public methods and abstract class methods only)
        for method in type.methods(): 
            if not type.value_type: access = self._access("public", access)
            if not abstract or method.access == "public": self._genMethod(type, method, bclass, ndconverters)

        # generate _shape() methods for array attributes
        for attr in type.attributes() :
            if not type.value_type: access = self._access("public", access)
            self._genAttrShapeAndListDecl(type, attr, bclass)

        # close class declaration
        print >>self.cpp, T('    .def("__typeid__", &method_typeid_$cname)')(locals())
        print >>self.cpp, T('    .staticmethod("__typeid__")')(locals())
        print >>self.cpp, '  ;'
        if not type.value_type: print >>self.inc, "};"

        print >>self.cpp, T('  psddl_python::ConverterMap::instance().addConverter(boost::make_shared<${type_name}_Converter>());')(type_name=type.name)
        print >>self.cpp, ""

    def _access(self, newaccess, oldaccess):
        if newaccess != oldaccess:
            print >>self.inc, newaccess+":"
        return newaccess
        
    def _genAttrDecl(self, attr):
        """Generate attribute declaration"""
        
        logging.debug("_genAttrDecl: attr: %s", attr)
        
        doc = ""
        if attr.comment : doc = T("\t/**< $comment */")(comment = attr.comment.strip())
        
        if not attr.shape :
            if attr.isfixed():
                decl = T("  $type\t$name;$doc")(type=_typename(attr.type), name=attr.name, doc=doc)
            else:
                decl = T("  //$type\t$name;")(type=_typename(attr.type), name=attr.name)
        else:
            if attr.isfixed():
                dim = _interpolate(_dims(attr.shape.dims), attr.parent)
                decl = T("  $type\t$name$shape;$doc")(type=_typename(attr.type), name=attr.name, shape=dim, doc=doc)
            else :
                dim = _interpolate(_dims(attr.shape.dims), attr.parent)
                decl = T("  //$type\t$name$shape;")(type=_typename(attr.type), name=attr.name, shape=dim)
        print >>self.inc, decl


    def _genMethod(self, type, method, bclass, ndconverters):
        """Generate method declaration and definition"""

        logging.debug("_genMethod: method: %s", method)
        
        method_name = method.name
        policy = None
        args = method.args
        margs = ', '.join([_argdecl2(*arg) for arg in args])
        
        if method_name == '_sizeof': 
            # not needed in Python
            return
        
        # generate code for a method
        if method.type is None:
            
            # method which does not return anything
            rettype = 'void'
            body = T('m_obj->$method_name($margs);')(locals())

        elif not method.rank:
            
            # attribute is a regular non-array object, it is returned by value or cref
            # non-basic types are returned by cref from wrapped method if method has 
            # corresponding attribute
            if method.attribute:
                rettype = _typedecl(method.type, self.psana_ns)
                policy = None if method.type.basic else "return_value_policy<copy_const_reference>()"
            else:
                rettype = _typename(method.type, self.psana_ns)
            body = T('return m_obj->$method_name($margs);')(locals())

        elif method.type.name == 'char':
            
            # char array is actually a string
            rettype = "const char*"
            args = _dimargs(method.rank-1, type)
            margs = ', '.join([_argdecl2(*arg) for arg in args])
            body = T('return m_obj->$method_name($margs);')(locals())
            
        elif method.type.value_type and method.type.basic:
            
            # wrapped method returns ndarray and we should convert it into numpy array
            rettype = "PyObject*"
            body = T('return detail::ndToNumpy(m_obj->$method_name($margs), m_obj);')(locals())
            
            # should also add boost converter for this ndarray type
            ctype = method.type.fullName('C++', self.psana_ns)
            ndim = method.rank
            ndconverters.add((ctype, ndim))

        elif method.type.value_type:

            # wrapped method returns ndarray and we should convert it into regular Python list
            rettype = "boost::python::list"
            body = T('return detail::ndToList(m_obj->$method_name($margs));')(locals())

        else:

            # array of non-value types, method will accept a set of indices.
            # wrapped method returns a const reference to an object wholly "contained" 
            # in the wrapped object, so set policy correctly. 
            rettype = _typename(method.type) + "_Wrapper"
            ctype = method.type.fullName('C++', self.psana_ns)
            args = _dimargs(method.rank, type)
            margs = ', '.join([_argdecl2(*arg) for arg in args])
            body = T('return $rettype(boost::shared_ptr<const $ctype>(m_obj, &m_obj->$method_name($margs)));')(locals())
            policy = "return_value_policy<return_by_value, return_internal_reference<> >()"

        self._genMethodWithBody(type, bclass, method_name, rettype, body, args=args, policy=policy)


    def _genMethodWithBody(self, type, bclass, method_name, rettype, body, policy='', args=[], static=False):

        policy = ', ' + policy if policy else ''

        print >>self.cpp, T('    .def("$method_name", &$bclass::$method_name$policy)')(locals())

        # we do not generate wrappers for value types
        if type.value_type: return

        argsspec = ', '.join([_argdecl(*arg) for arg in args])

        if static:
            static = "static "
            const = ""
        else:
            static = ""
            const = "const"


        if not body:

            # declaration only, implementation provided somewhere else
            print >>self.inc, T("  $static$rettype $method_name($argsspec) $const;")(locals())

        else:
            
            # inline method
            print >>self.inc, T("  $static$rettype $method_name($argsspec) $const { $body }")(locals())


    def isString(self, o):
        return type(o) == type("")

    def _genAttrShapeAndListDecl(self, type, attr, bclass):
        if not attr.shape_method: return
        if not attr.accessor: return
        
        # value-type arrays return ndarrays which do not need shape method
        if attr.type.value_type and attr.type.name != 'char': return

        # generate shape method
        shape_method = attr.shape_method
        body = 'boost::python::list res;'
        body += T(' const vector<int>& sh=m_obj->$shape_method();')(locals())
        body += ' for (vector<int>::const_iterator i = sh.begin(); i != sh.end(); ++ i) res.append(*i);'
        body += ' return res;'
        self._genMethodWithBody(type, bclass, shape_method, "boost::python::list", body)


        dimensions = []
        for dim in attr.shape.dims:
            if self.isString(dim) and (('{xtc-config}' in dim) or ('{self}' in dim)):
                dimensions.append(dim)

        if len(dimensions) == 0:
            return
        if len(dimensions) > 2:
            print "Error: cannot generate '%s' method: shape has more than 2 dimensions." % shape_method
            sys.exit(1)

        # now generate data_list() method if applicable.
        shape_method = attr.shape_method
        method_name = attr.accessor.name
        list_method_name = method_name + "_list"
        if not type.value_type: 
            print >> self.inc, T("  boost::python::list ${list_method_name}() { boost::python::list l; const int n = m_obj->${shape_method}()[0]; for (int i = 0; i < n; i++) l.append(${method_name}(i)); return l; }")(locals())
        print >>self.cpp, T('    .def("$list_method_name", &$bclass::$list_method_name)')(locals())

#
#  In case someone decides to run this module
#
if __name__ == "__main__" :

    # In principle we can try to run test suite for this module,
    # have to think about it later. Right now just abort.
    sys.exit ( "Module is not supposed to be run as main module" )
