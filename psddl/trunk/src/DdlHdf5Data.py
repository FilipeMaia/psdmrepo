#--------------------------------------------------------------------------
# File and Version Information:
#  $Id$
#
# Description:
#  Module DdlHdf5Data...
#
#------------------------------------------------------------------------

"""DDL parser which generates C++ code for HDF5 data classes.

This software was developed for the SIT project.  If you use all or 
part of it, please give an appropriate acknowledgment.

@see RelatedModule

@version $Id$

@author Andy Salnikov
"""


#------------------------------
#  Module's version from CVS --
#------------------------------
__version__ = "$Revision$"

#--------------------------------
#  Imports of standard modules --
#--------------------------------
import sys
import os
import logging

#---------------------------------
#  Imports of base class module --
#---------------------------------

#-----------------------------
# Imports for other modules --
#-----------------------------
from psddl.Attribute import Attribute
from psddl.Enum import Enum
from psddl.Package import Package
from psddl.Type import Type
from psddl.H5Type import H5Type
from psddl.H5Dataset import H5Dataset
from psddl.H5Attribute import H5Attribute
from psddl.Template import Template as T

#----------------------------------
# Local non-exported definitions --
#----------------------------------

def _interpolate(expr, typeobj):
    
    expr = expr.replace('{xtc-config}.', 'm_cfg->')
    expr = expr.replace('{type}.', typeobj.name+"::")
    expr = expr.replace('{self}.', "this->")
    return expr

def _typename(type):
    
    return type.fullName('C++')

def _typedecl(type):
    typename = _typename(type)
    if not type.basic : typename = "const "+typename+'&'
    return typename

def _argdecl(name, type):    
    return _typedecl(type) + ' ' + name


def _schemas(pkg):
    '''generator function for all schemas inside a package'''
    for ns in pkg.namespaces() :
        if isinstance(ns, Package) :
            for schema in _schemas(ns): yield schema        
        elif isinstance(ns, Type) :
            for schema in ns.h5schemas: yield schema

#------------------------
# Exported definitions --
#------------------------

#---------------------
#  Class definition --
#---------------------
class DdlHdf5Data ( object ) :

    #----------------
    #  Constructor --
    #----------------
    def __init__(self, incname, cppname, backend_options):
        """Constructor
        
            @param incname  include file name
            @param cppname  source file name
        """
        self.incname = incname
        self.cppname = cppname
        self.incdirname = backend_options.get('gen-incdir', "")
        self.top_pkg = backend_options.get('top-package')
        self.psana_inc = backend_options.get('psana-inc', "psddl_psana")
        self.psana_ns = backend_options.get('psana-ns', "Psana")

        #include guard
        g = os.path.split(self.incname)[1]
        if self.top_pkg: g = self.top_pkg + '_' + g
        self.guard = g.replace('.', '_').upper()

    #-------------------
    #  Public methods --
    #-------------------

    def parseTree(self, model):
        
        # open output files
        self.inc = file(self.incname, 'w')
        self.cpp = file(self.cppname, 'w')
        
        # include guard to header
        print >>self.inc, "#ifndef", self.guard 
        print >>self.inc, "#define", self.guard, "1"

        msg = "\n// *** Do not edit this file, it is auto-generated ***\n"
        print >>self.inc, msg
        print >>self.cpp, msg

        inc = os.path.join(self.incdirname, os.path.basename(self.incname))
        print >>self.cpp, "#include \"%s\"" % inc
        inc = os.path.join(self.psana_inc, os.path.basename(self.incname))
        print >>self.inc, "#include \"%s\"" % inc

        # add necessary includes
        print >>self.inc, "#include \"hdf5pp/Group.h\""
        print >>self.inc, "#include \"hdf5pp/Type.h\""
        print >>self.inc, "#include \"PSEvt/Proxy.h\""
        print >>self.cpp, "#include \"hdf5pp/CompoundType.h\""
        print >>self.cpp, "#include \"hdf5pp/EnumType.h\""
        print >>self.cpp, "#include \"hdf5pp/Utils.h\""
        print >>self.cpp, "#include \"PSEvt/DataProxy.h\""


        # headers for other included packages
        for use in model.use:
            path = use['file']
            headers = use['cpp_headers']
            if not headers:
                header = os.path.splitext(path)[0] + '.h'
                header = os.path.join(self.incdirname, os.path.basename(header))
                headers = [header]
            for header in headers:
                print >>self.inc, "#include \"%s\"" % header

        # headers for externally implemented schemas or datasets
        for pkg in model.packages():
            for schema in _schemas(pkg):
                if 'external' in schema.tags:
                    print >>self.inc, "#include \"%s\"" % schema.tags['external']
                for ds in schema.datasets:
                    if 'external' in ds.tags:
                        print >>self.inc, "#include \"%s\"" % ds.tags['external']

        if self.top_pkg : 
            ns = "namespace %s {" % self.top_pkg
            print >>self.inc, ns
            print >>self.cpp, ns

        # loop over packages in the model
        for pkg in model.packages() :
            logging.debug("parseTree: package=%s", repr(pkg))
            self._parsePackage(pkg)

        if self.top_pkg : 
            ns = "} // namespace %s" % self.top_pkg
            print >>self.inc, ns
            print >>self.cpp, ns

        # close include guard
        print >>self.inc, "#endif //", self.guard

        # close all files
        self.inc.close()
        self.cpp.close()


    def _parsePackage(self, pkg):
        
        if pkg.included: return

        # open namespaces
        print >>self.inc, "namespace %s {" % pkg.name
        print >>self.cpp, "namespace %s {" % pkg.name

        # enums for constants
        for const in pkg.constants() :
            if not const.included :
                self._genConst(const)

        # regular enums
        for enum in pkg.enums() :
            if not enum.included :
                self._genEnum(enum)

        # loop over packages and types
        for ns in pkg.namespaces() :
            
            if isinstance(ns, Package) :
                
                self._parsePackage(ns)
            
            elif isinstance(ns, Type) :
    
                self._parseType(type = ns)

        # close namespaces
        print >>self.inc, "} // namespace %s" % pkg.name
        print >>self.cpp, "} // namespace %s" % pkg.name


    def _genConst(self, const):
        
        print >>self._inc, "  enum {\n    %s = %s /**< %s */\n  };" % \
                (const.name, const.value, const.comment)

    def _genEnum(self, enum):
        
        if enum.comment: print >>self.inc, "\n  /** %s */" % (enum.comment)
        print >>self.inc, "  enum %s {" % (enum.name or "",)
        for const in enum.constants() :
            val = ""
            if const.value is not None : val = " = " + const.value
            doc = ""
            if const.comment: doc = ' /**< %s */' % const.comment
            print >>self.inc, "    %s%s,%s" % (const.name, val, doc)
        print >>self.inc, "  };"

    def _parseType(self, type):

        logging.debug("_parseType: type=%s", repr(type))

        # skip included types
        if type.included : return

        if not type.h5schemas:
            type.h5schemas = [self._defaultSchema(type)]

        for schema in type.h5schemas:
            self._genSchema(type, schema)

        psanatypename = type.fullName('C++', self.psana_ns)
        typename = type.name

        configs = type.xtcConfig or [None]

        for config in configs:
            
            cfgArgDecl = ''
            if config:
                cfgArgDecl = T(', const boost::shared_ptr<$cfgtypename>& cfg')(cfgtypename=config.fullName('C++', self.psana_ns))
            
            # make factory methods
            print >>self.inc, T("boost::shared_ptr<PSEvt::Proxy<$psanatypename> > make_$typename(int version, hdf5pp::Group group, hsize_t idx$cfgArgDecl);")(locals())
            print >>self.cpp, T("boost::shared_ptr<PSEvt::Proxy<$psanatypename> > make_$typename(int version, hdf5pp::Group group, hsize_t idx$cfgArgDecl) {")(locals())
            print >>self.cpp, "  switch (version) {"
            for schema in type.h5schemas:
                classname = T("${name}_v${version}")[schema]
                print >>self.cpp, T("  case $version:")[schema]
                if type.value_type:
                    proxytype = T('Proxy_${name}_v${version}')[schema]
                    print >>self.cpp, T("    return boost::make_shared<$proxytype>(group, idx);")(locals())
                else:
                    proxytype = T('PSEvt::DataProxy<$psanatypename> ')(locals())
                    if config:
                        cfgclassname = config.fullName('C++', self.psana_ns)
                        classname = T('$classname<$cfgclassname> ')(locals())
                        print >>self.cpp, T("    return boost::make_shared<$proxytype>(boost::make_shared<$classname>(group, idx, cfg));")(locals())
                    else:
                        print >>self.cpp, T("    return boost::make_shared<$proxytype>(boost::make_shared<$classname>(group, idx));")(locals())
            proxytype = T('PSEvt::DataProxy<$psanatypename> ')(locals())
            print >>self.cpp, T("  default:\n    return boost::make_shared<$proxytype>(boost::shared_ptr<$psanatypename>());")(locals())
            print >>self.cpp, "  }\n}"


    def _genSchema(self, type, schema):

        logging.debug("_genSchema: %s", repr(schema))

        if 'external' in schema.tags:
            logging.debug("_genSchema: skip schema - external")
            return

        for ds in schema.datasets:
            # generate datasets classes
            self._genDs(ds, schema)
            
        if type.value_type :
            self._genValueType(type, schema)
        else:
            self._genAbsType(type, schema)
            

    def _genDs(self, ds, schema):


        logging.debug("_genDs: %s", repr(ds))
        
        logging.debug("_genDs: schema %s", schema)

        if 'external' in ds.tags:
            logging.debug("_genDs: skip dataset - external")
            return

        ns = schema.nsName()
        dsClassName = ds.className()

        print >>self.inc, "\nnamespace %s {" % ns
        
        print >>self.inc, "struct %s {" % dsClassName

        self._genH5TypeFunc(ds, ns, dsClassName, "stored")
        self._genH5TypeFunc(ds, ns, dsClassName, "native")

        for attr in ds.attributes:
            if isinstance(attr.type, Enum):
                # enum types are mapped to uint32 for now, can use shorter
                # presentation if optimization is necessary
                attr_type_name = "int32_t"
            elif not attr.type.basic:
                attr_type_name = attr._h5ds_typename
            else:
                attr_type_name = attr.type.name
            if attr.rank > 0 and attr_type_name == 'char': 
                attr_type_name = attr_type_name +'*'
            elif attr.rank > 0:
                print >>self.inc, T("  size_t vlen_$name;")(name=attr.name)
                attr_type_name = attr_type_name +'*'
            print >>self.inc, T("  $type $name;")(type=attr_type_name, name=attr.name)


        # if schema contains single dataset and corresponding data type is a value type
        # then add conversion function from this dataset class to a data type
        try:
            if len(schema.datasets) == 1 and schema.pstype.value_type:
                
                # find a constructor with some arguments
                ctors = [ctor for ctor in schema.pstype.ctors if (ctor.args or 'auto' in ctor.tags)]
                if len(ctors) == 1:
                    ctor = ctors[0]
    
                    # map ctor parameters to dataset attributes
                    dsattrs = []
                    for aname, atype, attr in ctor.args:
                        if not attr.accessor: raise TypeError("Attribute " + attr.name + " does not have access method")
                        dsattrs += [dsattr.name for dsattr in ds.attributes if dsattr.method == attr.accessor.name]
                    if len(dsattrs) != len(ctor.args): raise TypeError("Failed to find HDF5 attributes for constructor arguments")

                    typename = schema.pstype.fullName('C++', self.psana_ns)
                    args = ', '.join(dsattrs)
                    print >>self.inc, T("  operator $typename() const { return $typename($args); }")(locals())

        except Exception, ex:
            # if we fail just ignore it
            logging.debug('_genDs: exception for conv operator: %s', ex)


        print >>self.inc, "}; // class %s" % dsClassName
        
        print >>self.inc, "} // namespace %s" % ns


    def _genH5TypeFunc(self, ds, ns, className, func):
        """
        Generate native_type()/stored_type() static method for dataset class.
        """

        print >>self.inc, T("  static hdf5pp::Type ${func}_type();")(locals())

        print >>self.cpp, T("\nhdf5pp::Type ${ns}_${className}_${func}_type()\n{")(locals())
        print >>self.cpp, T("  typedef $ns::$className DsType;")(locals())
        print >>self.cpp, "  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>() ;"
        for attr in ds.attributes:
            self._genH5TypeFuncAttr(attr, func);
        print >>self.cpp, "  return type;\n}"

        print >>self.cpp, T("\nhdf5pp::Type ${ns}::${className}::${func}_type()\n{")(locals())
        print >>self.cpp, T("  static hdf5pp::Type type = ${ns}_${className}_${func}_type();")(locals())
        print >>self.cpp, "  return type;\n}"

    def _genH5TypeFuncAttr(self, attr, func):

        if attr.type.basic:
            name = attr.name
            if isinstance(attr.type, Enum):
                base_type = "int32_t"
                enum_type = T("${name}_enum")(locals())
                print >>self.cpp, T('  hdf5pp::EnumType<$base_type> $enum_type = hdf5pp::EnumType<$base_type>::enumType();')(locals())
                for c in attr.type.constants():
                    # take enum values from psana
                    ename = c.name
                    type_name = attr.type.parent.fullName('C++', self.psana_ns)
                    print >>self.cpp, T('  $enum_type.insert("$ename", $type_name::$ename);')(locals())
                print >>self.cpp, T('  type.insert("$name", offsetof(DsType, $name), $enum_type);')(locals())
            else:
                type_name = attr.type.name
                if attr.rank > 0 and type_name == 'char': 
                    type_name = 'const char*'
                print >>self.cpp, T('  type.insert_$func<$type_name>("$name", offsetof(DsType, $name));')(locals())

        else:

            # for non-basic type (like composite types) find corresponding h5 schema,
            # if it has only one dataset then use it here
            aschema = [sch for sch in attr.type.h5schemas if sch.version == attr.schema_version]
            if not aschema:
                raise ValueError('No schema found for attribute %s' % attr.name)
            aschema = aschema[0]
            if len(aschema.datasets) != 1:
                raise ValueError('Attribute schema has number of datasets != 1: %d' % len(aschema.datasets))

            attr_type_name = '::'.join([aschema.nsName(), aschema.datasets[0].className()])
            attr_type_name = attr.type.parent.fullName('C++') + '::' + attr_type_name

            # remember it for use in other places
            attr._h5schema = aschema 
            attr._h5ds = aschema.datasets[0]
            attr._h5ds_typename = attr_type_name

            name = attr.name
            print >>self.cpp, T('  type.insert("$name", offsetof(DsType, $name), ${attr_type_name}::${func}_type());')(locals())


    def _genValueType(self, type, schema):
        """Generate code for value types"""
        
        # generator for all HFD5 attributes
        def _schemaAttributes(schema):
            for ds in schema.datasets:
                for dsattr in ds.attributes:
                    yield ds, dsattr

        
        logging.debug("_genValueType: type=%r", type)

        proxyName = T("Proxy_${name}_v${version}")[schema]
        psanatypename = type.fullName('C++', self.psana_ns)

        print >>self.inc, T("\nclass $proxyName : public PSEvt::Proxy<$psanatypename> {\npublic:")(locals())

        print >>self.inc, T("  typedef $psanatypename PsanaType;")(locals())

        print >>self.inc, T("  $proxyName(hdf5pp::Group group, hsize_t idx)")(locals())
        print >>self.inc, "    : m_group(group), m_idx(idx) {}"
        
        print >>self.inc, T("  virtual ~$proxyName();")(locals())
        print >>self.cpp, T("$proxyName::~$proxyName()\n{\n}\n")(locals())

        print >>self.inc, "protected:"

        print >>self.inc, "  virtual boost::shared_ptr<PsanaType> getTypedImpl(PSEvt::ProxyDictI* dict, "\
                          "const Pds::Src& source, const std::string& key);"

        print >>self.inc, "private:"

        print >>self.inc, "  mutable hdf5pp::Group m_group;"
        print >>self.inc, "  hsize_t m_idx;"
        print >>self.inc, "  boost::shared_ptr<PsanaType> m_data;"
        
        # close class declaration
        print >>self.inc, "};\n"

        # implementation of getTypedImpl()
        print >>self.cpp, T("boost::shared_ptr<$psanatypename>")(locals())
        print >>self.cpp, T("$proxyName::getTypedImpl(PSEvt::ProxyDictI* dict, const Pds::Src& source, const std::string& key)\n{")(locals())
        
        # get all datasets
        for ds in schema.datasets:
            dsClassName = '::'.join([schema.nsName(), ds.className()])
            dsName = ds.name
            print >>self.cpp, T("  boost::shared_ptr<$dsClassName> m_ds_$dsName = hdf5pp::Utils::readGroup<$dsClassName>(m_group, \"$dsName\", m_idx);")(locals())

        # find a constructor with some arguments
        ctors = [ctor for ctor in type.ctors if (ctor.args or 'auto' in ctor.tags)]
        if not ctors: raise TypeError("Type " + type.name + " does not have constructor defined")
        if len(ctors) > 1: raise TypeError("Type " + type.name + " has multiple constructors defined")
        ctor = ctors[0]

        # map ctor parameters to schema objects
        dsattrs = []
        for aname, atype, attr in ctor.args:
            if not attr.accessor: raise TypeError("Attribute " + attr.name + " does not have access method")
            for ds, dsattr in _schemaAttributes(schema):
                if attr.accessor.name == dsattr.method:
                    dsattrs.append((ds, dsattr))
        if len(dsattrs) != len(ctor.args): raise TypeError("Failed to find HDF5 attributes for constructor arguments in type "+type.name)

        args = ['m_ds_'+ds.name+'->'+dsattr.name for ds, dsattr in dsattrs]
        print >>self.cpp, "  return boost::make_shared<PsanaType>(%s);" % (', '.join(args),)

        print >>self.cpp, "}\n"

    def _genAbsType(self, type, schema):
        """Generate code for abstract types"""
        
        def _types(type):
            """Generator for the type list of the given type plus all it bases"""
            if type.base:
                for t in _types(type.base): yield t
            yield type
        
        logging.debug("_genAbsType: type=%s", repr(type))

        className = T("${name}_v${version}")[schema]
        psanatypename = type.fullName('C++', self.psana_ns)

        print >>self.inc, '\n'
        if type.xtcConfig:
            print >>self.inc, T("template <typename Config>")(locals())
        print >>self.inc, T("class $className : public $psanatypename {\npublic:")(locals())

        print >>self.inc, T("  typedef $psanatypename PsanaType;")(locals())
        
        # constructor
        if type.xtcConfig:
            print >>self.inc, T("  $className(hdf5pp::Group group, hsize_t idx, const boost::shared_ptr<Config>& cfg)")(locals())
            print >>self.inc, "    : m_group(group), m_idx(idx), m_cfg(cfg) {}"
        else:
            print >>self.inc, T("  $className(hdf5pp::Group group, hsize_t idx)")(locals())
            print >>self.inc, "    : m_group(group), m_idx(idx) {}"
        
        # destructor
        print >>self.inc, T("  virtual ~$className() {}")(locals())

        # declarations for public methods 
        for t in _types(type):
            for meth in t.methods(): 
                if meth.access == 'public': self._genMethod(meth, type, schema, className)

        print >>self.inc, "private:"

        print >>self.inc, "  mutable hdf5pp::Group m_group;"
        print >>self.inc, "  hsize_t m_idx;"
        if type.xtcConfig:
            print >>self.inc, "  boost::shared_ptr<Config> m_cfg;"


        for ds in schema.datasets:
            dsClassName = '::'.join([schema.nsName(), ds.className()])
            dsName = ds.name
            print >>self.inc, T("  mutable boost::shared_ptr<$dsClassName> m_ds_$dsName;")(locals())
            print >>self.inc, T("  void read_ds_$dsName() const;")(locals())
            if type.xtcConfig:
                print >>self.cpp, T("template <typename Config>\nvoid $className<Config>::read_ds_$dsName() const {")(locals())
            else:
                print >>self.cpp, T("void $className::read_ds_$dsName() const {")(locals())
            print >>self.cpp, T("  m_ds_$dsName = hdf5pp::Utils::readGroup<$dsClassName>(m_group, \"$dsName\", m_idx);")(locals())
            print >>self.cpp, "}"

            # user-defined data may need local storge as it is returned by reference
            for attr in ds.attributes:
                if not attr.type.basic and attr.rank == 0:
                    typename = attr.type.fullName('C++', self.psana_ns)
                    attrName = attr.name
                    print >>self.inc, T("  mutable $typename m_ds_storage_${dsName}_${attrName};")(locals())
                elif not attr.type.basic and attr.rank > 0:
                    typename = attr.type.fullName('C++', self.psana_ns)
                    attrName = attr.name
                    print >>self.inc, T("  mutable std::vector<$typename> m_ds_storage_${dsName}_${attrName};")(locals())

        # explicitely instantiate class with known config types
        for config in type.xtcConfig:
            cfgClassName = config.fullName('C++', self.psana_ns)
            print >>self.cpp, T("template class $className<$cfgClassName>;")(locals())

        # close class declaration
        print >>self.inc, "};\n"


    def _genMethod(self, meth, type, schema, className):
        """Generate method declaration and definition"""

        def _method2ds(method, schema):
            """Map method to a dataset and attribute"""
            for ds in schema.datasets:
                for attr in ds.attributes:
                    if attr.method == meth.name:
                        return (ds, attr)
            return (None, None)


        if meth.name == "_sizeof" : return

        logging.debug("_genMethod: meth: %s", meth)
        

        ds, attr = _method2ds(meth, schema)
        logging.debug("_genMethod: h5ds: %s, h5attr: %s, schema: %s", ds, attr, schema)

        if attr :
            
            
            # data is stored in a dataset
            args = []
            ret_type = attr.type.fullName('C++', self.psana_ns)
            if attr.rank:
                if attr.type.name == 'char':
                    ret_type = "const char*"
                    args = [('i%d'%i, type.lookup('uint32_t')) for i in range(attr.rank-1)]
                else:
                    ret_type = T("ndarray<$type, $rank>")(type=ret_type, rank=attr.rank)
            elif not attr.type.basic:
                ret_type = T("const ${ret_type}&")(locals())
                
            meth_name = meth.name
            print >>self.inc, T("  virtual $ret_type $meth_name() const;")(locals())
            if type.xtcConfig:
                print >>self.cpp, T("template <typename Config>\n$ret_type $className<Config>::$meth_name() const {")(locals())
            else:
                print >>self.cpp, T("$ret_type $className::$meth_name() const {")(locals())
            print >>self.cpp, T("  if (not m_ds_$name.get()) read_ds_$name();")[ds]
            if attr.rank and attr.type.basic:
                if attr.type.name == 'char':
                    print >>self.cpp, T("  return ($type)(m_ds_$name->$attr_name);")(name=ds.name, attr_name=attr.name, type=ret_type)
                else:
                    shape = _interpolate(str(meth.attribute.shape), type)
                    print >>self.cpp, T("  return make_ndarray(m_ds_$name->$attr_name,$shape);")(name=ds.name, attr_name=attr.name, type=ret_type, shape=shape)
            elif attr.rank and not attr.type.basic:
                dsName = ds.name
                attrName = attr.name
                memberName = T("m_ds_storage_${dsName}_${attrName}")(locals());
                shape = _interpolate(str(meth.attribute.shape), type)
                print >>self.cpp, T("  if (m_ds_$dsName->vlen_$attrName and not $memberName.data()) {")(locals())
                print >>self.cpp, T("    $memberName.insert($memberName.end(), m_ds_$dsName->$attrName, m_ds_$dsName->$attrName+m_ds_$dsName->vlen_$attrName);\n  }")(locals())
                print >>self.cpp, T("  return make_ndarray($memberName.data(),$shape);")(locals())
            elif not attr.type.basic:
                dsName = ds.name
                attrName = attr.name
                memberName = T("m_ds_storage_${dsName}_${attrName}")(locals());
                ret_type = attr.type.fullName('C++', self.psana_ns)
                print >>self.cpp, T("  $memberName = $ret_type(m_ds_$dsName->$attrName);")(locals())
                print >>self.cpp, T("  return $memberName;")(locals())
            else:
                print >>self.cpp, T("  return $type(m_ds_$name->$attr_name);")(name=ds.name, attr_name=attr.name, type=ret_type)
            print >>self.cpp, "}"

            
        else:
            
            # data is not stored, if method defines body then use it, otherwise skip
            # definition but declare it anyway
            
            # if no return type given then it does not return anything
            rettype = meth.type
            if rettype is None:
                rettype = "void"
            else:
                rettype = rettype.fullName('C++', self.psana_ns)
                if meth.rank > 0:
                    rettype = "ndarray<%s, %d>" % (rettype, meth.rank)

            # make method body
            body = meth.code.get("C++")
            if not body : body = meth.code.get("Any")
            if not body :
                expr = meth.expr.get("C++")
                if not expr : expr = meth.expr.get("Any")
                if expr:
                    body = expr
                    if rettype: body = "return %s;" % expr
                
            # config objects may be needed 
            cfgNeeded = False
            if body: 
                body = _interpolate(body, meth.parent)

            # default is not inline, can change with a tag
            inline = 'inline' in meth.tags
            
            template = "Config" if type.xtcConfig else None
            self._genMethodBody(meth.name, rettype, className, body, meth.args, inline, static=meth.static, doc=meth.comment, template=template)

    def _genMethodBody(self, methname, rettype, classname, body, args=[], inline=False, static=False, doc=None, template=None):
        """ Generate method, both declaration and definition, given the body of the method"""
        
        # make argument list
        argsspec = ', '.join([_argdecl(*arg) for arg in args])

        if static:
            static = "static "
            const = ""
        else:
            static = ""
            const = "const"
        

        if doc: print >>self.inc, T('  /** $doc */')(locals())

        if not body:

            # declaration only, implementation provided somewhere else
            print >>self.inc, T("  $static$rettype $methname($argsspec) $const;")(locals())

        elif inline:
            
            # inline method
            print >>self.inc, T("  $static$rettype $methname($argsspec) $const { $body }")(locals())
        
        else:
            
            # out-of-line method
            print >>self.inc, T("  $static$rettype $methname($argsspec) $const;")(locals())
            if template:
                print >>self.cpp, T("template<typename $template>\n$rettype\n$classname<$template>::$methname($argsspec) $const {\n  $body\n}")(locals())
            else:
                print >>self.cpp, T("$rettype\n$classname::$methname($argsspec) $const {\n  $body\n}")(locals())


    def _defaultSchema(self, type):
        """Generate default schema for a types from type itself"""

        logging.debug("_defaultSchema: type=%s", type)

        # get a list of all public methods which are accessors to attributes or bitfields or take no arguments
        methods = [ meth for meth in type.methods() 
                   if meth.access == "public" and meth.name != '_sizeof' and 
                   (meth.attribute is not None or meth.bitfield is not None or not meth.args)]
        
        # schema instance
        schema = H5Type(type.name, package=type.package, pstype=type, version=0, included=type.included)
        
        # All non-array attributes of value-types will go into separate dataset.
        # All 1-dim character arrays (strings) are included here too
        # Dataset name is 'data' for event data or 'config' for config types.
        ds = None
        for meth in methods:
            if (meth.rank == 0 and meth.type.value_type) or (meth.rank == 1 and meth.type.name == 'char'):
                if not ds:
                    dsname = 'data'
                    if "config-type" in type.tags: dsname = 'config' 
                    ds = H5Dataset(name=dsname, pstype=type)
                    schema.datasets.append(ds)
                attr = H5Attribute(name=meth.name, type=meth.type, rank=meth.rank, method=meth.name)
                ds.attributes.append(attr)
        if ds: logging.debug("_defaultSchema: scalars dataset: %s", ds)

        # for non-array attributes of user-defined types create individual datasets
        for meth in methods:
            if meth.rank == 0 and not meth.type.value_type:
                # get/make that type schema
                if not meth.type.h5schemas:
                    meth.type.h5schemas = [self._defaultSchema(meth.type)]
                # find its schema v0
                mschema = [s for s in meth.type.h5schemas if s.version == 0]
                if not mschema: raise ValueError("cannot find schema V0 for type "+meth.type.name)
                mschema = mschema[0]
                if mschema: logging.debug("_defaultSchema: sub-typedataset: %s", mschema)
                if len(mschema.datasets) != 1: raise ValueError("schema for sub-type "+type.name+"."+meth.type.name+" contains more than 1 dataset")
                # copy it into this schema
                schema.datasets.append(mschema.datasets[0])

        # for array attributes create individual datasets
        for meth in methods:
            if meth.rank > 1 or (meth.type.name != 'char' and meth.rank > 0):
                ds = H5Dataset(name=meth.name)
                schema.datasets.append(ds)
                attr = H5Attribute(name=meth.name, parent=ds, type=meth.type, rank=meth.rank, method=meth.name)
                ds.attributes.append(attr)

        return schema


    #--------------------
    #  Private methods --
    #--------------------

#
#  In case someone decides to run this module
#
if __name__ == "__main__" :

    # In principle we can try to run test suite for this module,
    # have to think about it later. Right now just abort.
    sys.exit ( "Module is not supposed to be run as main module" )
