:
:  Library of Jinja2 templates for Hdf5Translator backend
:
:  Lines starting with colon are comments, except for special '::::template::::'
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: macros
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: psana_cfg_template
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:  Template for a psana.cfg file that uses the Hdf5 Translator module.
:  This sets default values for all of the type filters.
:  
:  Parameters for this template:
:
: type_filter_options - a multiline list of the aliases, includes, and a comment
:                       to list all the types associated with the alias
[psana]

modules = Translator.H5Output
files = **TODO: PUT YOUR INPUT FILES HERE**

[Translator.H5Output]
# TODO: enter the full h5 output file name, including the output directory
output_file = output_directory/h5output.h5

# When the Translator encounters a split event, it checks a cache to see
# if it has already seen it.  If it has, it fills in any blanks that it can.
# To prevent this cache from growing to large, set the maximum number of
# split events to look back through here (default is 3000):
max_saved_split_events = 3000

#############
# store epics
epics_store = true

# The typenames for beam line data defaults to being written as (for example) 
# Bld::BldDataEBeamV0. Setting short_bld_name to true causes it to be 
# written as BldDataEBeamV0.

short_bld_name = false

####################################################################
# Type filtering
# one can include or exclude a class of Psana types with the following 
# options. Only the the strings include or exclude are valid for these 
# type filtering options.  Comments and blanks will be stripped from the 
# line by the Translator module.


{{type_filter_options}}

########################################################################
# Source filtering
#
#  The default for the src_filter option is "include all"
# If you want to include a subset of the sources, do
# src_filter include srcname1 srcname2  
#  or if you want to exclude a subset of sources, do
# src_filter exclude srcname1 srcname2
# where srcname are the group names associated with the source.

src_filter = include all

calibration_key = calibrated
include_uncalibrated_data = false

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: type_aliases_cpp
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:  Template for a psana.cfg file that uses the Hdf5 Translator module.
:  This sets default values for all of the type filters.
:  
:  Parameters for this template:
:
:  base_headers - list of the include files
:  type_aliases - list of objects, each has a alias and typeList - the latter is a list of types
:  
/* Do not edit this file.  It is created by a code generator. */

#include "Translator/TypeAliases.h"

{% for baseheader in base_headers %}
#include "psddl_psana/{{baseheader}}"
{% endfor %}

using namespace Translator;
using namespace std;

TypeAliases::TypeAliases() {
{% for entry in type_aliases %}
  set<const type_info *> {{entry.alias}};
{% for type in entry.typeList %}
  {{entry.alias}}.insert( & typeid({{type}}));
{% endfor %}
  m_alias2TypesMap["{{entry.alias}}"] = {{entry.alias}};

{% endfor %}
  Alias2TypesMap::iterator pos;
  for (pos = m_alias2TypesMap.begin(); pos != m_alias2TypesMap.end(); ++pos) {
    m_aliasKeys.insert(pos->first);
    TypeInfoSet & typeSet = pos->second;
    TypeInfoSet::iterator typePos;
    for (typePos = typeSet.begin(); typePos != typeSet.end(); ++typePos) {
      m_type2AliasMap[*typePos] = pos->first;
    }
  }  
}

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: hdfwritermap_cpp
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:  Template for a Translator/src/HdfWriterMap.cpp.  One function in this file, 
:  initializeHdfWriterMap is generated as it uses all the Psana types.
:  
:  Parameters for this template:
:  base_headers  - list of the basename of the header files in the psddl_hdf2psana package 
:             that include the store, store_at, make_datasets functions that we will use.  
:
:  namespaces - list of the namespaces that organize the store, store_at, make_datasets functions
:               in the psddl_hdf2psana package.
:  
:  psana_types - list of the psana types that we generate converters for
:
/* Do not edit this file.  It is created from a code generator.
Edit the template which resides in 

psddl/data/templates/hdf5Translator.tmpl?hdfwritermap_cpp
*/

#include "PSEvt/EventKey.h"
#include "PSEvt/TypeInfoUtils.h"
#include "Translator/HdfWriterMap.h"
#include "MsgLogger/MsgLogger.h"
{% for header in base_headers %}
#include "psddl_hdf2psana/{{header}}"
{% endfor %}

using namespace std;

namespace {

const int latestTypeSchema = -1;

using namespace Translator;
using namespace psddl_hdf2psana;
{% for namespace in namespaces %}
using namespace psddl_hdf2psana::{{namespace}};
{% endfor %}

template <class T>
void checkType(const PSEvt::EventKey &eventKey, const char *logger) {
  const std::type_info & templateType = typeid(T);
  if (templateType != *eventKey.typeinfo()) {
    MsgLog(logger, error, "eventKey: " << eventKey << " type mismatch with template type: " 
           << PSEvt::TypeInfoUtils::typeInfoRealName(&templateType));
  }
}

template<typename T>
class HdfWriter : public HdfWriterBase {
public:
  void make_datasets(DataTypeLoc dataTypeLoc, hdf5pp::Group & srcGroup, 
                     const PSEvt::EventKey & eventKey, 
                     PSEvt::Event & evt, PSEnv::Env & env,
                     bool shuffle, int deflate,
                     boost::shared_ptr<psddl_hdf2psana::ChunkPolicy> chunkPolicy)
  {
    checkType<T>(eventKey, "HdfWriter");
    boost::shared_ptr<T> ptr;
    if (dataTypeLoc == inEvent) ptr = evt.get(eventKey.src(), eventKey.key()); 
    else if (dataTypeLoc == inConfigStore) ptr = env.configStore().get(eventKey.src());
    ::make_datasets(*ptr,srcGroup,*chunkPolicy,deflate,shuffle,latestTypeSchema);
  }

  void store(DataTypeLoc dataTypeLoc, 
             hdf5pp::Group & srcGroup, 
             const PSEvt::EventKey & eventKey, 
             PSEvt::Event & evt, 
             PSEnv::Env & env) 
  {
    checkType<T>(eventKey, "HdfWriter");
    boost::shared_ptr<T> ptr;
    if (dataTypeLoc == inEvent) ptr = evt.get(eventKey.src(), eventKey.key()); 
    else if (dataTypeLoc == inConfigStore) ptr = env.configStore().get(eventKey.src());
    ::store(*ptr,srcGroup,latestTypeSchema); 
  }
  
  void store_at(DataTypeLoc dataTypeLoc, 
                long index, hdf5pp::Group & srcGroup, 
                const PSEvt::EventKey & eventKey, 
                PSEvt::Event & evt, 
                PSEnv::Env & env) {
    checkType<T>(eventKey, "HdfWriter");
    boost::shared_ptr<T> ptr; 
    if (dataTypeLoc == inEvent) ptr = evt.get(eventKey.src(), eventKey.key()); 
    else if (dataTypeLoc == inConfigStore) ptr = env.configStore().get(eventKey.src());
    ::store_at(ptr.get(),srcGroup, index, latestTypeSchema); 
  }

  void append(DataTypeLoc dataTypeLoc,
              hdf5pp::Group & srcGroup, const PSEvt::EventKey & eventKey, 
              PSEvt::Event & evt, PSEnv::Env & env) 
  {
    checkType<T>(eventKey, "HdfWriterFrom");
    boost::shared_ptr<T> ptr; 
    if (dataTypeLoc == inEvent) ptr = evt.get(eventKey.src(), eventKey.key()); 
    else if (dataTypeLoc == inConfigStore) ptr = env.configStore().get(eventKey.src());
    ::store_at(ptr.get(), srcGroup, indexForAppend, latestTypeSchema);
  }

  void addBlank(hdf5pp::Group & group)
  {
    T *ptrForBlank = NULL;
    ::store_at(ptrForBlank,group, indexForAppend, latestTypeSchema);
  }
  static const long indexForAppend = -1;
};  // class HdfWriter<T>


} // local namespace 

namespace Translator {

boost::shared_ptr<HdfWriterBase> getHdfWriter(HdfWriterMap & mapping, const std::type_info *typeInfoPtr) {
  //  static map<HdfWriterBase*,set<std::type_info*> > convertersNotFound;
   HdfWriterMap::iterator pos = mapping.find(typeInfoPtr);
  if (pos == mapping.end()) {
    // TODO: move this log message into H5Output
    //    WithMsgLog(logger,trace,str) {
    //      // to avoid printing messages for every event about converters not found, we do some simple
    //      // caching here. The first time we see that a converter is not found for a type, we log a 
    //      //  message. After that, we do not.  Since this function may be called for different 
    //      set<std::type_info*> notFoundThisMap = convertersNotFound[&mapping];
    //      if (notFoundThisMap.find(typeInfoPtr) == notFoundThisMap.end()) {
    //        str << "getHdfWriter: no converter found for type " << PSEvt::typeInfoRealName(typeInfoPtr);
    //        convertersNotFound.insert(typeInfoPtr);
    //      }
    //    }
    return boost::shared_ptr<Translator::HdfWriterBase>();
  }
  return pos->second;
}

void initializeHdfWriterMap( HdfWriterMap & mapping) {
{% for psana_type in psana_types %}
  mapping[ & typeid({{psana_type}}) ] = boost::make_shared<HdfWriter<{{psana_type}}> >();
{% endfor %}
}

} // Translator namespace


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: epics_ddl_h
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:  Template for a Translator/include/epics.dll.h
:
:  Parameters for this template:
:  base_headers  - list of the basename of the header files in the psddl_hdf2psana package 
:             that include the store, store_at, make_datasets functions that we will use.  
:
:  namespaces - list of the namespaces that organize the store, store_at, make_datasets functions
:               in the psddl_hdf2psana package.
:  
:  psana_types - list of the psana types that we generate converters for
:
#ifndef TRANSLATOR_EPICS_DDL_H
#define TRANSLATOR_EPICS_DDL_H

/* ****************************
** Do not edit this file.  It is auto generated. **

The code is generated from psddl/src/DdlHdf5Translator.py 
  and the template in      psddl/data/templates/hdf5Translator.tmpl?XXX

We use the DDL description of the Epics Pv to 'unroll' the 14 epicsPv
types that we will write into simple 'flat' structures that make it easier
to generate the hdf5 types.  Flat except for stamp, so as not to deviate from
the previous schema, we do not unroll the stamp field into seconds past the epoch
and nanoseconds. These 14 types are EpicsPvCtrl* and EpicsPvTime*
where * is one of String, Short, Float, Enum, Char, Long or Double.

The DDL defines these classes via a C++ class hierarchy, and there are some
compound objects that make up some of the attributes.  For example 

EpicsPvTimeDouble  -> EpicsPvTimeHeader -> EpicsPvHeader

moreover, classes can have compound types, for instance EpicsPvTimeHeader includes an
instance of epicsTimeStamp as an attribute.

For each of the 14 classes, we define a flat structure (except for stamp) that we can fill for Hdf5
translation, a function to produce the hdf5 type, and a function to fill the structure from
the appropriate Psana object that we will obtain from the epics store.

A difference between entries stored in the hdf5 datasets and the epics pv's from xtc, is the following.
EpicsPvTimeLong has an attribute NumElements() which says how many longs are stored (back to back, 
in an array) in the data() field.  If there are 3 longs in a particular epics pv, lets say the
pv name is "LASERTIMING", then for one psana epics pv of "LASERTIMING", we will store 3 entries 
in the "LASERTIMING" dataset of the Hdf5 file.  Each entry has one long in it.

 */

#include <string.h>

#include "hdf5/hdf5.h"
#include "psddl_psana/epics.ddl.h"

namespace Translator {

namespace Unroll {

struct epicsTimeStamp {
  uint32_t secPastEpoch;
  uint32_t nsec;
  epicsTimeStamp & operator=(const Psana::Epics::epicsTimeStamp & rhs) {
    secPastEpoch = rhs.sec();
    nsec = rhs.nsec();
    return *this;
 };
};

{% for epicsPv in epicsPvs %}
struct {{epicsPv['name']}} {
  typedef Psana::Epics::{{epicsPv['name']}} PsanaSrc;
{% for attr in epicsPv['attrs'] %}
  {{attr['basetype']}} {{attr['name']}}{{attr['array_print_info']}};
{% endfor %} 
  {{epicsPv['value_basetype']}} value{{epicsPv['value_array_print_info']}};
};

{% endfor %}
} // namespace Unroll

{% for epicsPv in epicsPvs %}
void copyToUnrolled(const Psana::Epics::{{epicsPv['name']}} &source, const int16_t element, Unroll::{{epicsPv['name']}} &dest);
{% endfor %} 

template <class U>
void copyValueFldToUnrolled(const typename U::PsanaSrc &psanaVar, int16_t el, U & unrollBuffer) {
  unrollBuffer.value = psanaVar.value(el);
}

template <>
void copyValueFldToUnrolled < Unroll::EpicsPvTimeString >
       (const Unroll::EpicsPvTimeString::PsanaSrc &psanaVar, int16_t el, 
        Unroll::EpicsPvTimeString & unrollBuffer);

template <>
void copyValueFldToUnrolled < Unroll::EpicsPvCtrlString >
       (const Unroll::EpicsPvCtrlString::PsanaSrc &psanaVar, int16_t el, 
        Unroll::EpicsPvCtrlString & unrollBuffer);

hid_t createH5TypeId_epicsTimeStamp();

 {% for epicsPv in epicsPvs %}
hid_t createH5TypeId_{{epicsPv['name']}}({{epicsPv['type_create_args']}});
{% endfor %} 

} // namespace Translator

#endif

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: epics_ddl_cpp
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:  Template for Translator/src/epics.dll.cpp
:
:  Parameters for this template:
:  base_headers  - list of the basename of the header files in the psddl_hdf2psana package 
:             that include the store, store_at, make_datasets functions that we will use.  
:
:  namespaces - list of the namespaces that organize the store, store_at, make_datasets functions
:               in the psddl_hdf2psana package.
:  
:  psana_types - list of the psana types that we generate converters for
:
/* Do not edit this file.  It is created by a code generator. */

#include <string.h>
#include "MsgLogger/MsgLogger.h"
#include "Translator/epics.ddl.h"

namespace {

const char * logger = "epics.dll";

void copyEpicsPvCtrlEnumStrings(const Psana::Epics::EpicsPvCtrlEnum & sourceObject, 
                                Translator::Unroll::EpicsPvCtrlEnum & destObject)
{
  const Psana::Epics::dbr_ctrl_enum& dbr = sourceObject.dbr();
  for (uint16_t stringNumber = 0; stringNumber < dbr.no_str(); ++stringNumber) {
    strncpy(destObject.strs[stringNumber], dbr.strings(stringNumber), Psana::Epics::MAX_ENUM_STRING_SIZE);
  }
}

} // local namespace

namespace Translator {

{% for epicsPv in epicsPvs %}
void copyToUnrolled(const Psana::Epics::{{epicsPv['name']}} &source, const int16_t element, 
                    Unroll::{{epicsPv['name']}} &dest) 
{
{% for attr in epicsPv['attrs'] %}
{% if attr['assignment'] == 'normal' %}
  dest.{{attr['name']}} = source.{{attr['accessor']}};
{% endif %}
{% if attr['assignment'] == 'enumstr' %}
  copyEpicsPvCtrlEnumStrings(source, dest);
{% endif %}
{% if attr['assignment'] == 'strncpy' %}
  strncpy(dest.{{attr['name']}}, source.{{attr['accessor']}}, Psana::Epics::{{attr['strncpy_max']}});
{% endif %}
{% endfor %}
  copyValueFldToUnrolled<Unroll::{{epicsPv['name']}}>(source,element,dest);
}

{% endfor %} 

template <>
void copyValueFldToUnrolled < Unroll::EpicsPvTimeString >
       (const Unroll::EpicsPvTimeString::PsanaSrc &psanaVar, int16_t el, 
        Unroll::EpicsPvTimeString & unrollBuffer) {
  strncpy(unrollBuffer.value, psanaVar.value(el), Psana::Epics::MAX_STRING_SIZE);
}

template <>
void copyValueFldToUnrolled < Unroll::EpicsPvCtrlString >
       (const Unroll::EpicsPvCtrlString::PsanaSrc &psanaVar, int16_t el, 
        Unroll::EpicsPvCtrlString & unrollBuffer) {
  strncpy(unrollBuffer.value, psanaVar.value(el), Psana::Epics::MAX_STRING_SIZE);
}

hid_t createH5TypeId_epicsTimeStamp() {
  hid_t typeId = H5Tcreate(H5T_COMPOUND, sizeof(Unroll::epicsTimeStamp));
  if (typeId < 0) MsgLog(logger, fatal, "Failed to create h5 type id for epicsTimeStamp");
  herr_t status = 0;
  status = std::min(status, H5Tinsert(typeId, "secPastEpoch", offsetof(Unroll::epicsTimeStamp, secPastEpoch), H5T_NATIVE_INT32));
  status = std::min(status, H5Tinsert(typeId, "nsec", offsetof(Unroll::epicsTimeStamp, nsec), H5T_NATIVE_INT32));
  if (status < 0) MsgLog(logger, fatal, "error inserting field into h5 typeId for epicsTimeStamp"); 
  return typeId;
}

 
{% for epicsPv in epicsPvs %}
hid_t createH5TypeId_{{epicsPv['name']}}({{epicsPv['type_create_args']}}) {
  hid_t typeId = H5Tcreate(H5T_COMPOUND, sizeof(Unroll::{{epicsPv['name']}}));
  if (typeId < 0) MsgLog(logger, fatal, "Failed to create h5 type id for {{epicsPv['name']}}");
  herr_t status = 0;
{% for attr in epicsPv['attrs'] %}
  status = std::min(status, H5Tinsert(typeId, "{{attr['h5name']}}", offsetof(Unroll::{{epicsPv['name']}}, {{attr['name']}}), {{attr['h5type']}}));
{% endfor %} 
  status = std::min(status, H5Tinsert(typeId, "value", offsetof(Unroll::{{epicsPv['name']}}, value), {{epicsPv['value_h5type']}}));

  if (status < 0) MsgLog(logger, fatal, "error inserting field into h5 typeId for {{epicsPv['name']}}"); 

  return typeId;
}

{% endfor %} 

} // Translator

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: dispatch_cpp
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:  Template for Translator/src/HdfWriterEpicsPvDispatch.cpp
:
:  Parameters for this template:
:  base_headers  - list of the basename of the header files in the psddl_hdf2psana package 
:             that include the store, store_at, make_datasets functions that we will use.  
:
:  namespaces - list of the namespaces that organize the store, store_at, make_datasets functions
:               in the psddl_hdf2psana package.
:  
:  psana_types - list of the psana types that we generate converters for
:

#include "MsgLogger/MsgLogger.h"
#include "psddl_psana/epics.ddl.h"
#include "Translator/epics.ddl.h"
#include "Translator/HdfWriterEpicsPv.h"

using namespace Translator;

namespace {
  const char * logger = "HdfWriterEpicsPv";
}

void HdfWriterEpicsPv::dispatch(hid_t groupId, int16_t dbrType, 
                                PSEnv::EpicsStore & epicsStore, 
                                const std::string & epicsPvName,
                                boost::shared_ptr<PSEvt::EventId> eventId,
                                DispatchAction dispatchAction) {
  switch (dbrType) {
{% for el in dbrTypes %}
  case Psana::Epics::{{el['dbr_str']}}:
    doDispatchAction<Unroll::{{el['pv_type']}}>(dbrType, "{{el['dbr_str']}}", 
                             "Psana::Epics::{{el['pv_type']}}",
                             groupId, epicsStore, epicsPvName, 
                             eventId, dispatchAction);
    break;
{% endfor %}
  default:
    MsgLog(logger, warning, "unexpected dbr type: " << dbrType << " in dispatch");
  }
}

