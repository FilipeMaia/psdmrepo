:
:  Library of Jinja2 templates for Pds2PsanaDispatch backend
:
:  Lines starting with colon are comments, except for special '::::template::::'
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: macros
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: header_template
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:  Template for header file. 
:  
:  Parameters for this template:
:    inc_guard  - include guard
:    namespace  - optional, top level namespace
:
#ifndef {{inc_guard}}
#define {{inc_guard}} 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <typeinfo>
#include <boost/shared_ptr.hpp>
#include "pdsdata/xtc/Xtc.hh"
#include "PSEvt/Event.h"
#include "PSEnv/EnvObjectStore.h"

$ if namespace:
namespace {{namespace}} {
$ endif

  /**
   *  Function takes xtc object, converts it into psana-type instance and stores either in 
   *  event or config-store. Pointer to even may be zero.
   */
  void xtcConvert(const boost::shared_ptr<Pds::Xtc>& xtc, PSEvt::Event* evt, PSEnv::EnvObjectStore& cfgStore);

  /**
   *  Function takes xtc TypeId and returns a list of C++ type_info pointers for the Psana types that the
   *  xtcConvert function (above) will put into the event store
   */
  std::vector<const std::type_info *> getXtcConvertTypeInfoPtrs(const Pds::TypeId & typeId);

$ if namespace:
} // namespace {{namespace}}
$ endif

#endif // {{inc_guard}}
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: impl_template
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:  Template for header file. 
:  
:  Parameters for this template:
:    namespace  - optional, top level namespace
:    headers    - list of header files
:    ignored_types - list of ignored type IDs
:    types      - dict of typeId -> code block
:
// *** Do not edit this file, it is auto-generated ***

#include "MsgLogger/MsgLogger.h"
#include "PSEvt/Exceptions.h"
#include "psddl_pds2psana/EvtProxy.h"
#include "psddl_pds2psana/EvtProxyCfg.h"

$ for header in headers
#include "{{header}}"
$ endfor

$ if namespace:
namespace {{namespace}} {
$ endif
void xtcConvert(const boost::shared_ptr<Pds::Xtc>& xtc, PSEvt::Event* evt, PSEnv::EnvObjectStore& cfgStore)
try {
  const Pds::TypeId& typeId = xtc->contains;

  int version = typeId.version();
  switch(typeId.id()) {
$ for type_id in ignored_types:
  case Pds::TypeId::{{type_id}}:
$ endfor
    break;
$ for type_id, block in types|dictsort:
  case Pds::TypeId::{{type_id}}:
    {
{{block}}
    }
    break;
$ endfor
  } // end switch

} catch (const PSEvt::ExceptionDuplicateKey& ex) {
  // catch exception for duplicated objects, ignore it
} // end xtcConvert(...)

{{typeInfoPtrsCode}}

$ if namespace:
} // namespace {{namespace}}
$ endif
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: version_switch_template
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:  Template for header file. 
:  
:  Parameters for this template:
:    versions      - dict of version -> code block
:
      switch (version) {
$ for version, blocks in versions|dictsort:
      case {{version}}:
        {
{{blocks|join('\n')}}
        }
        break;
$ endfor
      } // end switch (version)
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: config_abs_store_template
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:  Template for header file. 
:  
:  Parameters for this template:
:    xtc_type      - XTC type name
:    psana_type    - psana interface name
:    final_type    - interface implementation type name
:
          // store XTC object in config store
          boost::shared_ptr<{{xtc_type}}> xptr(xtc, ({{xtc_type}}*)(xtc->payload()));
          cfgStore.put(xptr, xtc->src);
          // create and store psana object in config store
          boost::shared_ptr<{{psana_type}}> obj = boost::make_shared<{{final_type}}>(xptr);
          cfgStore.put(obj, xtc->src);
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: config_value_store_template
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:  Template for header file. 
:  
:  Parameters for this template:
:    xtc_type      - XTC type name
:    psana_type    - psana type name
:    final_namespace  - namespace for implementation types
:
          // XTC data object
          {{xtc_type}}* xdata = ({{xtc_type}}*)(xtc->payload());
          // store XTC object in config store
          boost::shared_ptr<{{xtc_type}}> xptr(xtc, xdata);
          cfgStore.put(xptr, xtc->src);
          //convert XtcType to Psana type
          const {{psana_type}}& data = {{final_namespace}}::pds_to_psana(*xdata);
          // create and store psana object in config store
          cfgStore.put(boost::make_shared<{{psana_type}}>(data), xtc->src);
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: event_value_store_template
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:  Template for header file. 
:  
:  Parameters for this template:
:    xtc_type      - XTC type name
:    psana_type    - psana type name
:    final_namespace  - namespace for implementation types
:
          // XTC data object
          const {{xtc_type}}& xdata = *({{xtc_type}}*)(xtc->payload());
          //convert XtcType to Psana type
          const {{psana_type}}& data = {{final_namespace}}::pds_to_psana(xdata);
          // store data
          if (evt) evt->put(boost::make_shared<{{psana_type}}>(data), xtc->src);
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: event_abs_store_template
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:  Template for header file. 
:  
:  Parameters for this template:
:    proxy_type    - proxy type name
:    psana_type    - psana type name
:
          // store proxy
          typedef {{proxy_type}} ProxyType;
          if (evt) evt->putProxy<{{psana_type}}>(boost::make_shared<ProxyType>(xtc), xtc->src);
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: event_cfg_store_template
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:  Template for header file. 
:  
:  Parameters for this template:
:    config_types  - dict config type -> proxy type name
:    psana_type    - psana type name
:
$ for config_type, proxy_type in config_types|dictsort:
$ if loop.first:
          if (boost::shared_ptr<{{config_type}}> cfgPtr = cfgStore.get(xtc->src)) {
$ else:
          } else if (boost::shared_ptr<{{config_type}}> cfgPtr = cfgStore.get(xtc->src)) {
$ endif
            // store proxy
            typedef {{proxy_type}} ProxyType;
            if (evt) evt->putProxy<{{psana_type}}>(boost::make_shared<ProxyType>(xtc, cfgPtr), xtc->src);
$ endfor
          }
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: typeinfoptrs
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:

std::vector<const std::type_info *> getXtcConvertTypeInfoPtrs(const Pds::TypeId &typeId) {
  std::vector<const std::type_info *> typeIdPtrs;
  switch (typeId.id()) {
{% for ignored_type in ignored_types %}
  case Pds::TypeId::{{ignored_type}}:
{% endfor %}
    break;
{% for type_id,version_dict in psana_types|dictsort %}
  case Pds::TypeId::{{type_id}}:
    switch(typeId.version()) {
{% for version, versionTypeList in version_dict|dictsort %}
    case {{version}}:
{% for versionType in versionTypeList %}
      typeIdPtrs.push_back( &typeid({{versionType}}) );
{% endfor %}
      break;
{% endfor %}
    } // end version switch
    break;
{% endfor %}
  }  // typeId.id() switch statement
  return typeIdPtrs;
}


