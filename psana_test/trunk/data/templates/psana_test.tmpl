:
:  Library of Jinja2 templates for psana_test backend
:
:  Lines starting with colon are comments, except for special '::::template::::'
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: macros
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: psddl_dump_py
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:  Template for psana_test/src/psddl_dump.py
:
:  Parameters for this template:
:
:   xtc_dispatch_list  a list of 3-tuples, each tuple is (typeid, version, dump_function)
:
:   psana_types    a list of psana_type objects, where each object has
:       namespace
:       classname
:       xtctype        True if this is an xtc type, objects will have TypeId and Version members
:       basic_methods  a list of pairs (method, dump_function) where method is a 
:       list_methods   same kind of (method, elem_dump_function, where method returns a Python list
:       
# do not edit this file. It is generated from the DDL.
# edit the template psana_test/data/template/psana_test.tmpl and regenerate using ddl_psana_test

import psana
from psana import *
import psana_test.dump_basic_types as dbt
from  psana_test.dump_basic_types import *

def line_indent(INDENT, INDENT_LEVEL):
    return ' ' * INDENT * INDENT_LEVEL    

# functions to dump psana objects to a string                    
{% for psana_type in psana_types %}
{% set namespace = psana_type.namespace %}
{% set classname = psana_type.classname %}
{% set xtctype = psana_type.xtctype %}
{% set basic_methods = psana_type.basic_methods %}
{% set list_methods = psana_type.list_methods %}
{% set string_methods = psana_type.string_methods %}
{% set basic_0_to_methods = psana_type.basic_0_to_methods %}
{% set basic_0_to_const_methods = psana_type.basic_0_to_const_methods %}
{% set not_basic_idx_methods = psana_type.not_basic_idx_methods %}
def {{namespace}}_{{classname}}_to_str(obj, INDENT, INDENT_LEVEL):
{% if xtctype %}
    assert obj.TypeId == psana.{{namespace}}.{{classname}}.TypeId
    assert obj.Version == psana.{{namespace}}.{{classname}}.Version
{% endif %}
    lines = ''
{% if basic_attr %}
    # basic attributes
{% endif %}
{% for attrFn in basic_attr %}
{% set attr,dump_function = attrFn %}
    attrStr = line_indent(INDENT, INDENT_LEVEL)
    attrStr += '{{attr}}: %s' % dbt.{{dump_function}}(obj.{{attr}}) 
    lines += ('%s\n' % attrStr)
{% endfor %} {# basic attr #}
{% if basic_methods %}
    # basic methods
{% endif %}
{% for basic_method in basic_methods %}
{% set method,dump_function = basic_method %}
    methodStr = line_indent(INDENT, INDENT_LEVEL)
    methodStr += '{{method}}: %s' % dbt.{{dump_function}}(obj.{{method}}()) 
    lines += ('%s\n' % methodStr)
{% endfor %} {# basic_methods #}
{% if string_methods %}
    # string methods
{% endif %}
{% for string_method in string_methods %}
{% set method,maxlen = string_method %}
    methodStr = line_indent(INDENT, INDENT_LEVEL)
{% if maxlen %}
    methodStr += str(obj.{{method}}()[0:{{maxlen}}])
{% else %}
    methodStr += str(obj.{{method}}())
{% endif %}
    lines += '%s\n' % methodStr
{% endfor %}  {# string_methods #}
{% if list_methods %}
    # list methods
{% endif %}
{% for list_method in list_methods %}
{% set method,elem_dump_function = list_method %}
    methodStr = ''
    for idx, subObj in enumerate(obj.{{method}}()):
        elemStr = line_indent(INDENT, INDENT_LEVEL)
        elemStr += "{{method}}[%d]\n" % idx
        elemStr += {{elem_dump_function}}(subObj,INDENT,INDENT_LEVEL+1)
        methodStr += '%s\n' % elemStr
    lines += '%s\n' % methodStr
{% endfor %}  {# list_methods #}
{% if basic_0_to_methods %}
    # basic_0_to_methods
{% endif %}
{% for basic_0_to_method in basic_0_to_methods %}
{% set method, elem_dump_function, maxiter = basic_0_to_method %}
    methodStr = line_indent(INDENT, INDENT_LEVEL)
    methodStr += ('{{method}}[0:' + str(obj.{{maxiter}}()) + ']:')
    for idx in range(obj.{{maxiter}}()):
        elem = obj.{{method}}(idx)
        methodStr += (' ' + {{elem_dump_function}}(elem) )
    lines += '%s\n' % methodStr
{% endfor %}  {# basic_0_to_methods #}
{% if basic_0_to_const_methods %}
    # basic_0_to_const_methods
{% endif %}
{% for basic_0_to_const_method in basic_0_to_const_methods %}
{% set method, elem_dump_function, maxiter = basic_0_to_const_method %}
    methodStr = line_indent(INDENT, INDENT_LEVEL)
    methodStr += '{{method}}[0:{{maxiter}}]:'
    for idx in range({{maxiter}}):
        elem = obj.{{method}}(idx)
        methodStr += (' ' + {{elem_dump_function}}(elem) )
    lines += '%s\n' % methodStr
{% endfor %}  {# basic_0_to_const_methods #}
{% if nonbasic_idx_methods %}
    # nonbasic_idx method
{% endif %}
{% for not_basic_idx_method in not_basic_idx_methods %}
{% set method,shape_fn,elem_dump_fn = not_basic_idx_method %}
    assert len(obj.{{shape_fn}}())==1, "shape function {{shape_fn}} is not length 1"
    n = obj.{{shape_fn}}()[0]
    methodStr = line_indent(INDENT, INDENT_LEVEL)
    for idx in range(n):
        elem = obj.{{method}}(idx)
        methodStr += ("{{method}}[%d]\n" % idx)
        methodStr += {{elem_dump_fn}}(elem,INDENT,INDENT_LEVEL+1)
{% endfor %}

    return lines

{% endfor %} {# psana_types #}

# dispatch table
objFunctionTable = {
{% for dispatch_entry in xtc_dispatch_list %}
{% set typeid,version,dump_function = dispatch_entry %}
    ({{typeid}},{{version}}) : {{dump_function}},
{% endfor %}
} # end dispatch table


#########################################
# The primary high level function that users can call to dump a psana object to a string
def obj2str(obj, INDENT=0, INDENT_LEVEL=0):
    assert hasattr(obj,'TypeId'), "obj2str is only for xtc types with a TypeId"
    assert obj.TypeId is not None, "obj2str is only for xtc types with a TypeId that is not None"
    assert hasattr(obj,'Version'), "obj2str is only for xtc types with a Version"
    assert obj.Version is not None, "obj2str is only for xtc types with a Version that is not None"
    if obj.TypeId == 54:
       return ((" " * INDENT) * INDENT_LEVEL) + "no dump function for epics config"

    fnKey = (obj.TypeId, obj.Version)
    dump_function = objFunctionTable.get(fnKey,None)
    assert dump_function is not None, "obj2str - no dump function found for obj=%r typeid/version=%s" % (obj,fnKey,)
    return dump_function(obj, INDENT, INDENT_LEVEL)

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: include_headers
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:  Template for first part of psana_test/src/psddl_Dump.cpp
:
:  Parameters for this template:
:
:  base_headers  - list of the basename of the header files in the psddl_psana package 
:

/* Do not modify this file, it is generated code. 
   Modify the template file and Ddl backend and run the psddl compiler. */

{% for header in base_headers %}
#include "psddl_psana/{{header}}"
{% endfor %}

#include "MsgLogger/MsgLogger.h"
#include "PSEvt/Event.h"
#include "PSEnv/Env.h"
#include "psana_test/psddl_Dump.h"
#include <cstdio>
#include <vector>

using namespace std;
using namespace Psana;

