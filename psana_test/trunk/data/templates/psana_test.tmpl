:
:  Library of Jinja2 templates for psana_test backend
:
:  Lines starting with colon are comments, except for special '::::template::::'
:
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: macros
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::template:::: psddl_dump_py
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:  Template for psana_test/src/psddl_dump.py
:
:  Parameters for this template:
:
:   xtc_dispatch_list  a list of 3-tuples, each tuple is (typeid, version, dump_function)
:
:   psana_types    a list of psana_type objects, where each object has
:       namespace
:       classname
:       xtctype        True if this is an xtc type, objects will have TypeId and Version members
:       basic_methods  a list of pairs (method, dump_function) where method is a 
:       list_methods   same kind of (method, elem_dump_function, where method returns a Python list
:       
# do not edit this file. It is generated from the DDL.
# edit the template psana_test/data/template/psana_test.tmpl 
# and regenerate using ddl_psana_test

import psana
from psana import *
from  psana_test.types_to_str import *
import numpy as np

def _Src_to_str(obj, indent, lvl, methodSep):
    return doIndent(indent,lvl) + str(obj)

def Partition_Src_to_str(obj, indent, lvl, methodSep):
    return _Src_to_str(obj, indent, lvl, methodSep)

def Pds_Src_to_str(obj, indent, lvl, methodSep):
    return _Src_to_str(obj, indent, lvl, methodSep)

def Pds_DetInfo_to_str(obj, indent, lvl, methodSep):
    return _Src_to_str(obj, indent, lvl, methodSep)

def ControlData_ClockTime_to_str(obj, indent, lvl, methodSep):
    return Pds_ClockTime_to_str(obj, indent, lvl, methodSep)

def OceanOptics_nonLinearCorrected(obj, indent, lvl):
    data = obj.data()
    nonlinearCorrected = np.zeros(data.shape, np.float64)
    for idx in range(data.shape[0]):
        nonlinearCorrected[idx] = obj.nonlinerCorrected(idx)
    methodStr = doIndent(indent, lvl)
    methodStr += 'nonlinearCorrected: %s' % ndarray_to_str( nonlinearCorrected )
    return methodStr

# functions to dump psana objects to a string                    
{% for psana_type in psana_types %}
{% set namespace = psana_type.namespace %}
{% set classname = psana_type.classname %}
{% set xtctype = psana_type.xtctype %}
{% set one_line_methods = psana_type.one_line_methods %}
{% set multi_line_methods = psana_type.multi_line_methods %}
{% set idx_list_one_line_methods = psana_type.idx_list_one_line_methods %}
{% set idx_list_multi_line_methods = psana_type.idx_list_multi_line_methods %}
{% set list_multi_line_methods = psana_type.list_multi_line_methods %}
def {{namespace}}_{{classname}}_to_str(obj, indent, lvl, methodSep):
{% if xtctype %}
    assert obj.TypeId == psana.{{namespace}}.{{classname}}.TypeId
    assert obj.Version == psana.{{namespace}}.{{classname}}.Version
{% endif %}
    methodStrings = []
{% if namespace == 'OceanOptics' and classname.startswith('DataV') %}
    methodStrings.append(OceanOptics_nonLinearCorrected(obj, indent, lvl))
{% endif %}
{% if one_line_methods %}
    # one_line_methods
{% endif %}
{% for xx in one_line_methods %}
{% set name, expr, fn = xx %}
    methodStr = doIndent(indent, lvl)
    methodStr += '{{name}}: %s' % {{fn}}( {{expr}} )
    methodStrings.append(methodStr)                                 
{% endfor %}
{% if multi_line_methods %}
    # multi_line_methods
{% endif %}
{% for xx  in multi_line_methods %}
{% set name, expr, fn = xx %}
    methodStr = doIndent(indent, lvl)
    methodStr += '{{name}}:\n'
    methodStr += {{fn}}({{expr}}, indent, lvl+1, methodSep)
    methodStrings.append(methodStr)
{% endfor %}
{% if idx_list_one_line_methods %}
    # idx_list_one_line_methods
{% endif %}
{% for xx in idx_list_one_line_methods %}
{% set name, fn, maxexpr = xx %}
    methodStr = doIndent(indent, lvl)
    methodStr += '{{name}}'
    try:
       for idx in range( {{maxexpr}} ):
            methodStr += ' [%d]' % idx
            methodStr += '=%s' % {{fn}}( obj.{{name}}(idx) )
       methodStrings.append( methodStr )
    except:
       for idx, subObj in enumerate( obj.{{name}}() ):
            methodStr += ' [%d]' % idx
            methodStr += '=%s' % {{fn}}( subObj )
       methodStrings.append( methodStr )
{% endfor %}
{% if idx_list_multi_line_methods %}
    # idx_list_multi_line_methods
{% endif %}
{% for nameFnMaxExpr in idx_list_multi_line_methods %}
{% set name, fn, maxexpr = nameFnMaxExpr %}
    methodStr = ''
    numObjs = {{ maxexpr }}
    for idx in range( numObjs ):
        subObj = obj.{{name}}(idx)
        methodStr += doIndent(indent, lvl)
        methodStr += '{{name}}[%d]:\n' % idx
        methodStr += {{fn}}(subObj, indent, lvl+1, methodSep)
        if idx+1 < numObjs:
            methodStr += '\n'
    methodStrings.append(methodStr)
{% endfor %}
{% if list_multi_line_methods %}
    # list_multi_line_methods
{% endif %}
{% for nameFn in list_multi_line_methods %}
{% set name, fn = nameFn %}
    subMethodStrs = []
    for idx, subObj in enumerate( obj.{{name}}() ):
        subMethodStr = doIndent(indent, lvl)
        subMethodStr += '{{name}}[%d]:\n' % idx
        subMethodStr += {{fn}}(subObj, indent, lvl+1, methodSep)
        subMethodStrs.append(subMethodStr)
    methodStr = '\n'.join(subMethodStrs)
    methodStrings.append(methodStr)
{% endfor %}
    methodStrings = [meth for meth in methodStrings if len(meth)>0]
    return methodSep.join(methodStrings)

{% endfor %}{# psana_types #}

# dispatch table
objFunctionTable = {
{% for dispatch_entry in xtc_dispatch_list %}
{% set typeid,version,dump_function = dispatch_entry %}
    ({{typeid}},{{version}}) : {{dump_function}},
{% endfor %}
} # end dispatch table


#########################################
# The primary high level function that users can call to dump a psana object to a string
def obj2str(obj, indent=0, lvl=0, methodsep='\n'):
    if hasattr(obj,'TypeId'):
        if obj.TypeId is not None:
            if obj.TypeId == 54:
                return doIndent(indent,lvl) + 'epicsConfig not dumped'
            if obj.TypeId == 11 and type(obj) == psana.PNCCD.FullFrameV1:
                return doIndent(indent,lvl) + 'PNCCD.FullFramesV1 not dumped'
        if hasattr(obj,'Version'):
            if obj.Version is not None:
              fnKey = (obj.TypeId, obj.Version)
              dump_function = objFunctionTable.get(fnKey,None)
              assert dump_function is not None, "obj2str - no dump function found for obj=%r typeid/version=%s" % (obj,fnKey,)
              return dump_function(obj, indent, lvl, methodsep)
    # check for an ndarray that we know how to convert
    if isinstance(obj,np.ndarray):
        fnCvt = getTypeFn(obj.dtype)
        if fnCvt is not None:
            return ndarray_to_str(obj, indent, lvl)
    # default to Python str
    return str(obj)

