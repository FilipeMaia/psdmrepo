/* Do not edit this file, as it is auto-generated */

#include <boost/python.hpp>
#include <boost/make_shared.hpp>
#include "ndarray/ndarray.h"
#include "pdsdata/xtc/TypeId.hh"
#include "psddl_psana/bld.ddl.h" // inc_psana
#include "psddl_python/Converter.h"
#include "psddl_python/DdlWrapper.h"
#include "psddl_python/ConverterMap.h"
#include "psddl_python/ConverterBoostDef.h"
#include "psddl_python/ConverterBoostDefSharedPtr.h"

namespace psddl_python {
namespace Bld {

using namespace boost::python;
using boost::python::object;
using boost::shared_ptr;
using std::vector;

namespace {
template<typename T, std::vector<int> (T::*MF)() const>
PyObject* method_shape(const T *x) {
  return detail::vintToList((x->*MF)());
}
} // namespace

void createWrappers(PyObject* module) {
  PyObject* submodule = Py_InitModule3( "psana.Bld", 0, "The Python wrapper module for Bld types");
  Py_INCREF(submodule);
  PyModule_AddObject(module, "Bld", submodule);
  scope mod = object(handle<>(borrowed(submodule)));
  {
  scope outer = 
  class_<Psana::Bld::BldDataFEEGasDetEnergy >("BldDataFEEGasDetEnergy", "Four energy measurements from Front End Enclosure Gas Detector.\n               PV names: GDET:FEE1:11:ENRC, GDET:FEE1:12:ENRC, GDET:FEE1:21:ENRC, GDET:FEE1:22:ENRC.", no_init)
    .def("f_11_ENRC", &Psana::Bld::BldDataFEEGasDetEnergy::f_11_ENRC,"Value of GDET:FEE1:11:ENRC, in mJ.")
    .def("f_12_ENRC", &Psana::Bld::BldDataFEEGasDetEnergy::f_12_ENRC,"Value of GDET:FEE1:12:ENRC, in mJ.")
    .def("f_21_ENRC", &Psana::Bld::BldDataFEEGasDetEnergy::f_21_ENRC,"Value of GDET:FEE1:21:ENRC, in mJ.")
    .def("f_22_ENRC", &Psana::Bld::BldDataFEEGasDetEnergy::f_22_ENRC,"Value of GDET:FEE1:22:ENRC, in mJ.")
  ;
  scope().attr("Version")=0;
  scope().attr("TypeId")=int(Pds::TypeId::Id_FEEGasDetEnergy);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDef<Psana::Bld::BldDataFEEGasDetEnergy> >(Pds::TypeId::Id_FEEGasDetEnergy));

  {
  scope outer = 
  class_<Psana::Bld::BldDataFEEGasDetEnergyV1 >("BldDataFEEGasDetEnergyV1", "Six energy measurements from Front End Enclosure Gas Detector.\n   PV names: GDET:FEE1:241:ENRC, GDET:FEE1:242:ENRC, \n	GDET:FEE1:361:ENRC, GDET:FEE1:362:ENRC, \n	GDET:FEE1:363:ENRC, and GDET:FEE1:364:ENRC \n   Each pair of methods (e.g. f_11_ENRC(), f_12_ENRC() contains\n   identical measurements using two different phototubes.  \"11\" and \"12\"\n   are before the gas attenuation.  \"21\" and \"22\" are after gas\n   attenuation.\n   \"63\" and \"64\" are duplicate measurements of \"21\" and \"22\" respectively. \n    The difference is that they cover a smaller (10%) dynamic range. \n    When the beam is weak, 361 and 362 don't have good S/N, these 2 extra PVs should be used instead.  Dehong Zhang suggests that the threshold\n    for \"weak\" is around 0.5 mJ.", no_init)
    .def("f_11_ENRC", &Psana::Bld::BldDataFEEGasDetEnergyV1::f_11_ENRC,"First energy measurement (mJ) before attenuation. (pv name GDET:FEE1:241:ENRC)")
    .def("f_12_ENRC", &Psana::Bld::BldDataFEEGasDetEnergyV1::f_12_ENRC,"Second (duplicate!) energy measurement (mJ) after attenuation. (pv name GDET:FEE1:242:ENRC)")
    .def("f_21_ENRC", &Psana::Bld::BldDataFEEGasDetEnergyV1::f_21_ENRC,"First energy measurement (mJ) after attenuation. (pv name  GDET:FEE1:361:ENRC)")
    .def("f_22_ENRC", &Psana::Bld::BldDataFEEGasDetEnergyV1::f_22_ENRC,"Second (duplicate!) energy measurement (mJ) after attenuation. (pv name GDET:FEE1:362:ENRC)")
    .def("f_63_ENRC", &Psana::Bld::BldDataFEEGasDetEnergyV1::f_63_ENRC,"First energy measurement (mJ) for small signals (<0.5 mJ), after attenuation. (pv name GDET:FEE1:363:ENRC)")
    .def("f_64_ENRC", &Psana::Bld::BldDataFEEGasDetEnergyV1::f_64_ENRC,"Second (duplicate!) energy measurement (mJ) for small signals (<0.5mJ), after attenutation. (pv name GDET:FEE1:364:ENRC)")
  ;
  scope().attr("Version")=1;
  scope().attr("TypeId")=int(Pds::TypeId::Id_FEEGasDetEnergy);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDef<Psana::Bld::BldDataFEEGasDetEnergyV1> >(Pds::TypeId::Id_FEEGasDetEnergy));

  {
  scope outer = 
  class_<Psana::Bld::BldDataEBeamV0 >("BldDataEBeamV0", "Beam parameters.", no_init)
    .def("damageMask", &Psana::Bld::BldDataEBeamV0::damageMask,"Damage mask.")
    .def("ebeamCharge", &Psana::Bld::BldDataEBeamV0::ebeamCharge,"Beam charge in nC.")
    .def("ebeamL3Energy", &Psana::Bld::BldDataEBeamV0::ebeamL3Energy,"Beam energy in MeV.")
    .def("ebeamLTUPosX", &Psana::Bld::BldDataEBeamV0::ebeamLTUPosX,"LTU beam position in mm.")
    .def("ebeamLTUPosY", &Psana::Bld::BldDataEBeamV0::ebeamLTUPosY,"LTU beam position in mm.")
    .def("ebeamLTUAngX", &Psana::Bld::BldDataEBeamV0::ebeamLTUAngX,"LTU beam angle in mrad.")
    .def("ebeamLTUAngY", &Psana::Bld::BldDataEBeamV0::ebeamLTUAngY,"LTU beam angle in mrad.")
  ;

  enum_<Psana::Bld::BldDataEBeamV0::DamageMask>("DamageMask")
    .value("EbeamChargeDamage",Psana::Bld::BldDataEBeamV0::EbeamChargeDamage)
    .value("EbeamL3EnergyDamage",Psana::Bld::BldDataEBeamV0::EbeamL3EnergyDamage)
    .value("EbeamLTUPosXDamage",Psana::Bld::BldDataEBeamV0::EbeamLTUPosXDamage)
    .value("EbeamLTUPosYDamage",Psana::Bld::BldDataEBeamV0::EbeamLTUPosYDamage)
    .value("EbeamLTUAngXDamage",Psana::Bld::BldDataEBeamV0::EbeamLTUAngXDamage)
    .value("EbeamLTUAngYDamage",Psana::Bld::BldDataEBeamV0::EbeamLTUAngYDamage)
  ;
  scope().attr("Version")=0;
  scope().attr("TypeId")=int(Pds::TypeId::Id_EBeam);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDef<Psana::Bld::BldDataEBeamV0> >(Pds::TypeId::Id_EBeam));

  {
  scope outer = 
  class_<Psana::Bld::BldDataEBeamV1 >("BldDataEBeamV1", no_init)
    .def("damageMask", &Psana::Bld::BldDataEBeamV1::damageMask,"Damage mask.")
    .def("ebeamCharge", &Psana::Bld::BldDataEBeamV1::ebeamCharge,"Beam charge in nC.")
    .def("ebeamL3Energy", &Psana::Bld::BldDataEBeamV1::ebeamL3Energy,"Beam energy in MeV.")
    .def("ebeamLTUPosX", &Psana::Bld::BldDataEBeamV1::ebeamLTUPosX,"LTU beam position in mm.")
    .def("ebeamLTUPosY", &Psana::Bld::BldDataEBeamV1::ebeamLTUPosY,"LTU beam position in mm.")
    .def("ebeamLTUAngX", &Psana::Bld::BldDataEBeamV1::ebeamLTUAngX,"LTU beam angle in mrad.")
    .def("ebeamLTUAngY", &Psana::Bld::BldDataEBeamV1::ebeamLTUAngY,"LTU beam angle in mrad.")
    .def("ebeamPkCurrBC2", &Psana::Bld::BldDataEBeamV1::ebeamPkCurrBC2,"Beam current in Amps.")
  ;

  enum_<Psana::Bld::BldDataEBeamV1::DamageMask>("DamageMask")
    .value("EbeamChargeDamage",Psana::Bld::BldDataEBeamV1::EbeamChargeDamage)
    .value("EbeamL3EnergyDamage",Psana::Bld::BldDataEBeamV1::EbeamL3EnergyDamage)
    .value("EbeamLTUPosXDamage",Psana::Bld::BldDataEBeamV1::EbeamLTUPosXDamage)
    .value("EbeamLTUPosYDamage",Psana::Bld::BldDataEBeamV1::EbeamLTUPosYDamage)
    .value("EbeamLTUAngXDamage",Psana::Bld::BldDataEBeamV1::EbeamLTUAngXDamage)
    .value("EbeamLTUAngYDamage",Psana::Bld::BldDataEBeamV1::EbeamLTUAngYDamage)
    .value("EbeamPkCurrBC2Damage",Psana::Bld::BldDataEBeamV1::EbeamPkCurrBC2Damage)
  ;
  scope().attr("Version")=1;
  scope().attr("TypeId")=int(Pds::TypeId::Id_EBeam);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDef<Psana::Bld::BldDataEBeamV1> >(Pds::TypeId::Id_EBeam));

  {
  scope outer = 
  class_<Psana::Bld::BldDataEBeamV2 >("BldDataEBeamV2", no_init)
    .def("damageMask", &Psana::Bld::BldDataEBeamV2::damageMask,"Damage mask.")
    .def("ebeamCharge", &Psana::Bld::BldDataEBeamV2::ebeamCharge,"Beam charge in nC.")
    .def("ebeamL3Energy", &Psana::Bld::BldDataEBeamV2::ebeamL3Energy,"Beam energy in MeV.")
    .def("ebeamLTUPosX", &Psana::Bld::BldDataEBeamV2::ebeamLTUPosX,"LTU beam position in mm.")
    .def("ebeamLTUPosY", &Psana::Bld::BldDataEBeamV2::ebeamLTUPosY,"LTU beam position in mm.")
    .def("ebeamLTUAngX", &Psana::Bld::BldDataEBeamV2::ebeamLTUAngX,"LTU beam angle in mrad.")
    .def("ebeamLTUAngY", &Psana::Bld::BldDataEBeamV2::ebeamLTUAngY,"LTU beam angle in mrad.")
    .def("ebeamPkCurrBC2", &Psana::Bld::BldDataEBeamV2::ebeamPkCurrBC2,"Beam current in Amps.")
    .def("ebeamEnergyBC2", &Psana::Bld::BldDataEBeamV2::ebeamEnergyBC2,"Beam energy in MeV.")
  ;

  enum_<Psana::Bld::BldDataEBeamV2::DamageMask>("DamageMask")
    .value("EbeamChargeDamage",Psana::Bld::BldDataEBeamV2::EbeamChargeDamage)
    .value("EbeamL3EnergyDamage",Psana::Bld::BldDataEBeamV2::EbeamL3EnergyDamage)
    .value("EbeamLTUPosXDamage",Psana::Bld::BldDataEBeamV2::EbeamLTUPosXDamage)
    .value("EbeamLTUPosYDamage",Psana::Bld::BldDataEBeamV2::EbeamLTUPosYDamage)
    .value("EbeamLTUAngXDamage",Psana::Bld::BldDataEBeamV2::EbeamLTUAngXDamage)
    .value("EbeamLTUAngYDamage",Psana::Bld::BldDataEBeamV2::EbeamLTUAngYDamage)
    .value("EbeamPkCurrBC2Damage",Psana::Bld::BldDataEBeamV2::EbeamPkCurrBC2Damage)
    .value("EbeamEnergyBC2Damage",Psana::Bld::BldDataEBeamV2::EbeamEnergyBC2Damage)
  ;
  scope().attr("Version")=2;
  scope().attr("TypeId")=int(Pds::TypeId::Id_EBeam);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDef<Psana::Bld::BldDataEBeamV2> >(Pds::TypeId::Id_EBeam));

  {
  scope outer = 
  class_<Psana::Bld::BldDataEBeamV3 >("BldDataEBeamV3", no_init)
    .def("damageMask", &Psana::Bld::BldDataEBeamV3::damageMask,"Damage mask.")
    .def("ebeamCharge", &Psana::Bld::BldDataEBeamV3::ebeamCharge,"Beam charge in nC.")
    .def("ebeamL3Energy", &Psana::Bld::BldDataEBeamV3::ebeamL3Energy,"Beam energy in MeV.")
    .def("ebeamLTUPosX", &Psana::Bld::BldDataEBeamV3::ebeamLTUPosX,"LTU beam position in mm.")
    .def("ebeamLTUPosY", &Psana::Bld::BldDataEBeamV3::ebeamLTUPosY,"LTU beam position in mm.")
    .def("ebeamLTUAngX", &Psana::Bld::BldDataEBeamV3::ebeamLTUAngX,"LTU beam angle in mrad.")
    .def("ebeamLTUAngY", &Psana::Bld::BldDataEBeamV3::ebeamLTUAngY,"LTU beam angle in mrad.")
    .def("ebeamPkCurrBC2", &Psana::Bld::BldDataEBeamV3::ebeamPkCurrBC2,"Beam current in Amps.")
    .def("ebeamEnergyBC2", &Psana::Bld::BldDataEBeamV3::ebeamEnergyBC2,"Beam position in mm (related to beam energy).")
    .def("ebeamPkCurrBC1", &Psana::Bld::BldDataEBeamV3::ebeamPkCurrBC1,"Beam current in Amps.")
    .def("ebeamEnergyBC1", &Psana::Bld::BldDataEBeamV3::ebeamEnergyBC1,"Beam position in mm (related to beam energy).")
  ;

  enum_<Psana::Bld::BldDataEBeamV3::DamageMask>("DamageMask")
    .value("EbeamChargeDamage",Psana::Bld::BldDataEBeamV3::EbeamChargeDamage)
    .value("EbeamL3EnergyDamage",Psana::Bld::BldDataEBeamV3::EbeamL3EnergyDamage)
    .value("EbeamLTUPosXDamage",Psana::Bld::BldDataEBeamV3::EbeamLTUPosXDamage)
    .value("EbeamLTUPosYDamage",Psana::Bld::BldDataEBeamV3::EbeamLTUPosYDamage)
    .value("EbeamLTUAngXDamage",Psana::Bld::BldDataEBeamV3::EbeamLTUAngXDamage)
    .value("EbeamLTUAngYDamage",Psana::Bld::BldDataEBeamV3::EbeamLTUAngYDamage)
    .value("EbeamPkCurrBC2Damage",Psana::Bld::BldDataEBeamV3::EbeamPkCurrBC2Damage)
    .value("EbeamEnergyBC2Damage",Psana::Bld::BldDataEBeamV3::EbeamEnergyBC2Damage)
    .value("EbeamPkCurrBC1Damage",Psana::Bld::BldDataEBeamV3::EbeamPkCurrBC1Damage)
    .value("EbeamEnergyBC1Damage",Psana::Bld::BldDataEBeamV3::EbeamEnergyBC1Damage)
  ;
  scope().attr("Version")=3;
  scope().attr("TypeId")=int(Pds::TypeId::Id_EBeam);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDef<Psana::Bld::BldDataEBeamV3> >(Pds::TypeId::Id_EBeam));

  {
  scope outer = 
  class_<Psana::Bld::BldDataEBeamV4 >("BldDataEBeamV4", no_init)
    .def("damageMask", &Psana::Bld::BldDataEBeamV4::damageMask,"Damage mask.")
    .def("ebeamCharge", &Psana::Bld::BldDataEBeamV4::ebeamCharge,"Beam charge in nC.")
    .def("ebeamL3Energy", &Psana::Bld::BldDataEBeamV4::ebeamL3Energy,"Beam energy in MeV.")
    .def("ebeamLTUPosX", &Psana::Bld::BldDataEBeamV4::ebeamLTUPosX,"LTU beam position (BPMS:LTU1:720 through 750) in mm.")
    .def("ebeamLTUPosY", &Psana::Bld::BldDataEBeamV4::ebeamLTUPosY,"LTU beam position in mm.")
    .def("ebeamLTUAngX", &Psana::Bld::BldDataEBeamV4::ebeamLTUAngX,"LTU beam angle in mrad.")
    .def("ebeamLTUAngY", &Psana::Bld::BldDataEBeamV4::ebeamLTUAngY,"LTU beam angle in mrad.")
    .def("ebeamPkCurrBC2", &Psana::Bld::BldDataEBeamV4::ebeamPkCurrBC2,"Beam current in Amps.")
    .def("ebeamEnergyBC2", &Psana::Bld::BldDataEBeamV4::ebeamEnergyBC2,"Beam position in mm (related to beam energy).")
    .def("ebeamPkCurrBC1", &Psana::Bld::BldDataEBeamV4::ebeamPkCurrBC1,"Beam current in Amps.")
    .def("ebeamEnergyBC1", &Psana::Bld::BldDataEBeamV4::ebeamEnergyBC1,"Beam position in mm (related to beam energy).")
    .def("ebeamUndPosX", &Psana::Bld::BldDataEBeamV4::ebeamUndPosX,"Undulator launch feedback (BPMs U4 through U10) beam x-position in mm.")
    .def("ebeamUndPosY", &Psana::Bld::BldDataEBeamV4::ebeamUndPosY,"Undulator launch feedback beam y-position in mm.")
    .def("ebeamUndAngX", &Psana::Bld::BldDataEBeamV4::ebeamUndAngX,"Undulator launch feedback beam x-angle in mrad.")
    .def("ebeamUndAngY", &Psana::Bld::BldDataEBeamV4::ebeamUndAngY,"Undulator launch feedback beam y-angle in mrad.")
  ;

  enum_<Psana::Bld::BldDataEBeamV4::DamageMask>("DamageMask")
    .value("EbeamChargeDamage",Psana::Bld::BldDataEBeamV4::EbeamChargeDamage)
    .value("EbeamL3EnergyDamage",Psana::Bld::BldDataEBeamV4::EbeamL3EnergyDamage)
    .value("EbeamLTUPosXDamage",Psana::Bld::BldDataEBeamV4::EbeamLTUPosXDamage)
    .value("EbeamLTUPosYDamage",Psana::Bld::BldDataEBeamV4::EbeamLTUPosYDamage)
    .value("EbeamLTUAngXDamage",Psana::Bld::BldDataEBeamV4::EbeamLTUAngXDamage)
    .value("EbeamLTUAngYDamage",Psana::Bld::BldDataEBeamV4::EbeamLTUAngYDamage)
    .value("EbeamPkCurrBC2Damage",Psana::Bld::BldDataEBeamV4::EbeamPkCurrBC2Damage)
    .value("EbeamEnergyBC2Damage",Psana::Bld::BldDataEBeamV4::EbeamEnergyBC2Damage)
    .value("EbeamPkCurrBC1Damage",Psana::Bld::BldDataEBeamV4::EbeamPkCurrBC1Damage)
    .value("EbeamEnergyBC1Damage",Psana::Bld::BldDataEBeamV4::EbeamEnergyBC1Damage)
    .value("EbeamUndPosXDamage",Psana::Bld::BldDataEBeamV4::EbeamUndPosXDamage)
    .value("EbeamUndPosYDamage",Psana::Bld::BldDataEBeamV4::EbeamUndPosYDamage)
    .value("EbeamUndAngXDamage",Psana::Bld::BldDataEBeamV4::EbeamUndAngXDamage)
    .value("EbeamUndAngYDamage",Psana::Bld::BldDataEBeamV4::EbeamUndAngYDamage)
  ;
  scope().attr("Version")=4;
  scope().attr("TypeId")=int(Pds::TypeId::Id_EBeam);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDef<Psana::Bld::BldDataEBeamV4> >(Pds::TypeId::Id_EBeam));

  {
  scope outer = 
  class_<Psana::Bld::BldDataEBeamV5 >("BldDataEBeamV5", no_init)
    .def("damageMask", &Psana::Bld::BldDataEBeamV5::damageMask,"Damage mask.")
    .def("ebeamCharge", &Psana::Bld::BldDataEBeamV5::ebeamCharge,"Beam charge in nC.")
    .def("ebeamL3Energy", &Psana::Bld::BldDataEBeamV5::ebeamL3Energy,"Beam energy in MeV.")
    .def("ebeamLTUPosX", &Psana::Bld::BldDataEBeamV5::ebeamLTUPosX,"LTU beam position (BPMS:LTU1:720 through 750) in mm.")
    .def("ebeamLTUPosY", &Psana::Bld::BldDataEBeamV5::ebeamLTUPosY,"LTU beam position in mm.")
    .def("ebeamLTUAngX", &Psana::Bld::BldDataEBeamV5::ebeamLTUAngX,"LTU beam angle in mrad.")
    .def("ebeamLTUAngY", &Psana::Bld::BldDataEBeamV5::ebeamLTUAngY,"LTU beam angle in mrad.")
    .def("ebeamPkCurrBC2", &Psana::Bld::BldDataEBeamV5::ebeamPkCurrBC2,"Beam current in Amps.")
    .def("ebeamEnergyBC2", &Psana::Bld::BldDataEBeamV5::ebeamEnergyBC2,"Beam position in mm (related to beam energy).")
    .def("ebeamPkCurrBC1", &Psana::Bld::BldDataEBeamV5::ebeamPkCurrBC1,"Beam current in Amps.")
    .def("ebeamEnergyBC1", &Psana::Bld::BldDataEBeamV5::ebeamEnergyBC1,"Beam position in mm (related to beam energy).")
    .def("ebeamUndPosX", &Psana::Bld::BldDataEBeamV5::ebeamUndPosX,"Undulator launch feedback (BPMs U4 through U10) beam x-position in mm.")
    .def("ebeamUndPosY", &Psana::Bld::BldDataEBeamV5::ebeamUndPosY,"Undulator launch feedback beam y-position in mm.")
    .def("ebeamUndAngX", &Psana::Bld::BldDataEBeamV5::ebeamUndAngX,"Undulator launch feedback beam x-angle in mrad.")
    .def("ebeamUndAngY", &Psana::Bld::BldDataEBeamV5::ebeamUndAngY,"Undulator launch feedback beam y-angle in mrad.")
    .def("ebeamXTCAVAmpl", &Psana::Bld::BldDataEBeamV5::ebeamXTCAVAmpl,"XTCAV Amplitude in MVolt.")
    .def("ebeamXTCAVPhase", &Psana::Bld::BldDataEBeamV5::ebeamXTCAVPhase,"XTCAV Phase in degrees.")
    .def("ebeamDumpCharge", &Psana::Bld::BldDataEBeamV5::ebeamDumpCharge,"Bunch charge at Dump in num. electrons")
  ;

  enum_<Psana::Bld::BldDataEBeamV5::DamageMask>("DamageMask")
    .value("EbeamChargeDamage",Psana::Bld::BldDataEBeamV5::EbeamChargeDamage)
    .value("EbeamL3EnergyDamage",Psana::Bld::BldDataEBeamV5::EbeamL3EnergyDamage)
    .value("EbeamLTUPosXDamage",Psana::Bld::BldDataEBeamV5::EbeamLTUPosXDamage)
    .value("EbeamLTUPosYDamage",Psana::Bld::BldDataEBeamV5::EbeamLTUPosYDamage)
    .value("EbeamLTUAngXDamage",Psana::Bld::BldDataEBeamV5::EbeamLTUAngXDamage)
    .value("EbeamLTUAngYDamage",Psana::Bld::BldDataEBeamV5::EbeamLTUAngYDamage)
    .value("EbeamPkCurrBC2Damage",Psana::Bld::BldDataEBeamV5::EbeamPkCurrBC2Damage)
    .value("EbeamEnergyBC2Damage",Psana::Bld::BldDataEBeamV5::EbeamEnergyBC2Damage)
    .value("EbeamPkCurrBC1Damage",Psana::Bld::BldDataEBeamV5::EbeamPkCurrBC1Damage)
    .value("EbeamEnergyBC1Damage",Psana::Bld::BldDataEBeamV5::EbeamEnergyBC1Damage)
    .value("EbeamUndPosXDamage",Psana::Bld::BldDataEBeamV5::EbeamUndPosXDamage)
    .value("EbeamUndPosYDamage",Psana::Bld::BldDataEBeamV5::EbeamUndPosYDamage)
    .value("EbeamUndAngXDamage",Psana::Bld::BldDataEBeamV5::EbeamUndAngXDamage)
    .value("EbeamUndAngYDamage",Psana::Bld::BldDataEBeamV5::EbeamUndAngYDamage)
    .value("EbeamXTCAVAmplDamage",Psana::Bld::BldDataEBeamV5::EbeamXTCAVAmplDamage)
    .value("EbeamXTCAVPhaseDamage",Psana::Bld::BldDataEBeamV5::EbeamXTCAVPhaseDamage)
    .value("EbeamDumpChargeDamage",Psana::Bld::BldDataEBeamV5::EbeamDumpChargeDamage)
  ;
  scope().attr("Version")=5;
  scope().attr("TypeId")=int(Pds::TypeId::Id_EBeam);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDef<Psana::Bld::BldDataEBeamV5> >(Pds::TypeId::Id_EBeam));

  {
  scope outer = 
  class_<Psana::Bld::BldDataEBeamV6 >("BldDataEBeamV6", no_init)
    .def("damageMask", &Psana::Bld::BldDataEBeamV6::damageMask,"Damage mask.")
    .def("ebeamCharge", &Psana::Bld::BldDataEBeamV6::ebeamCharge,"Beam charge in nC.")
    .def("ebeamL3Energy", &Psana::Bld::BldDataEBeamV6::ebeamL3Energy,"Beam energy in MeV.")
    .def("ebeamLTUPosX", &Psana::Bld::BldDataEBeamV6::ebeamLTUPosX,"LTU beam position (BPMS:LTU1:720 through 750) in mm.")
    .def("ebeamLTUPosY", &Psana::Bld::BldDataEBeamV6::ebeamLTUPosY,"LTU beam position in mm.")
    .def("ebeamLTUAngX", &Psana::Bld::BldDataEBeamV6::ebeamLTUAngX,"LTU beam angle in mrad.")
    .def("ebeamLTUAngY", &Psana::Bld::BldDataEBeamV6::ebeamLTUAngY,"LTU beam angle in mrad.")
    .def("ebeamPkCurrBC2", &Psana::Bld::BldDataEBeamV6::ebeamPkCurrBC2,"Beam current in Amps.")
    .def("ebeamEnergyBC2", &Psana::Bld::BldDataEBeamV6::ebeamEnergyBC2,"Beam position in mm (related to beam energy).")
    .def("ebeamPkCurrBC1", &Psana::Bld::BldDataEBeamV6::ebeamPkCurrBC1,"Beam current in Amps.")
    .def("ebeamEnergyBC1", &Psana::Bld::BldDataEBeamV6::ebeamEnergyBC1,"Beam position in mm (related to beam energy).")
    .def("ebeamUndPosX", &Psana::Bld::BldDataEBeamV6::ebeamUndPosX,"Undulator launch feedback (BPMs U4 through U10) beam x-position in mm.")
    .def("ebeamUndPosY", &Psana::Bld::BldDataEBeamV6::ebeamUndPosY,"Undulator launch feedback beam y-position in mm.")
    .def("ebeamUndAngX", &Psana::Bld::BldDataEBeamV6::ebeamUndAngX,"Undulator launch feedback beam x-angle in mrad.")
    .def("ebeamUndAngY", &Psana::Bld::BldDataEBeamV6::ebeamUndAngY,"Undulator launch feedback beam y-angle in mrad.")
    .def("ebeamXTCAVAmpl", &Psana::Bld::BldDataEBeamV6::ebeamXTCAVAmpl,"XTCAV Amplitude in MVolt.")
    .def("ebeamXTCAVPhase", &Psana::Bld::BldDataEBeamV6::ebeamXTCAVPhase,"XTCAV Phase in degrees.")
    .def("ebeamDumpCharge", &Psana::Bld::BldDataEBeamV6::ebeamDumpCharge,"Bunch charge at Dump in num. electrons")
    .def("ebeamPhotonEnergy", &Psana::Bld::BldDataEBeamV6::ebeamPhotonEnergy,"computed photon energy, in eV")
    .def("ebeamLTU250", &Psana::Bld::BldDataEBeamV6::ebeamLTU250,"LTU250 BPM value in mm, used to compute photon energy. from BPMS:LTU1:250:X")
    .def("ebeamLTU450", &Psana::Bld::BldDataEBeamV6::ebeamLTU450,"LTU450 BPM value in mm, used to compute photon energy. from BPMS:LTU1:450:X")
  ;

  enum_<Psana::Bld::BldDataEBeamV6::DamageMask>("DamageMask")
    .value("EbeamChargeDamage",Psana::Bld::BldDataEBeamV6::EbeamChargeDamage)
    .value("EbeamL3EnergyDamage",Psana::Bld::BldDataEBeamV6::EbeamL3EnergyDamage)
    .value("EbeamLTUPosXDamage",Psana::Bld::BldDataEBeamV6::EbeamLTUPosXDamage)
    .value("EbeamLTUPosYDamage",Psana::Bld::BldDataEBeamV6::EbeamLTUPosYDamage)
    .value("EbeamLTUAngXDamage",Psana::Bld::BldDataEBeamV6::EbeamLTUAngXDamage)
    .value("EbeamLTUAngYDamage",Psana::Bld::BldDataEBeamV6::EbeamLTUAngYDamage)
    .value("EbeamPkCurrBC2Damage",Psana::Bld::BldDataEBeamV6::EbeamPkCurrBC2Damage)
    .value("EbeamEnergyBC2Damage",Psana::Bld::BldDataEBeamV6::EbeamEnergyBC2Damage)
    .value("EbeamPkCurrBC1Damage",Psana::Bld::BldDataEBeamV6::EbeamPkCurrBC1Damage)
    .value("EbeamEnergyBC1Damage",Psana::Bld::BldDataEBeamV6::EbeamEnergyBC1Damage)
    .value("EbeamUndPosXDamage",Psana::Bld::BldDataEBeamV6::EbeamUndPosXDamage)
    .value("EbeamUndPosYDamage",Psana::Bld::BldDataEBeamV6::EbeamUndPosYDamage)
    .value("EbeamUndAngXDamage",Psana::Bld::BldDataEBeamV6::EbeamUndAngXDamage)
    .value("EbeamUndAngYDamage",Psana::Bld::BldDataEBeamV6::EbeamUndAngYDamage)
    .value("EbeamXTCAVAmplDamage",Psana::Bld::BldDataEBeamV6::EbeamXTCAVAmplDamage)
    .value("EbeamXTCAVPhaseDamage",Psana::Bld::BldDataEBeamV6::EbeamXTCAVPhaseDamage)
    .value("EbeamDumpChargeDamage",Psana::Bld::BldDataEBeamV6::EbeamDumpChargeDamage)
    .value("EbeamPhotonEnergyDamage",Psana::Bld::BldDataEBeamV6::EbeamPhotonEnergyDamage)
  ;
  scope().attr("Version")=6;
  scope().attr("TypeId")=int(Pds::TypeId::Id_EBeam);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDef<Psana::Bld::BldDataEBeamV6> >(Pds::TypeId::Id_EBeam));

  {
  scope outer = 
  class_<Psana::Bld::BldDataEBeamV7 >("BldDataEBeamV7", "BldDataEBeamV7 is the same as BldDataEBeamV6.\nA sign-error error was discovered in the calculation of the photon energy that goes into the ebeam bld.\nThis is fixed on the accelerator side, but we will increment the ebeam bld version number to V7 so the\ndata is clearly marked as changed.", no_init)
    .def("damageMask", &Psana::Bld::BldDataEBeamV7::damageMask,"Damage mask.")
    .def("ebeamCharge", &Psana::Bld::BldDataEBeamV7::ebeamCharge,"Beam charge in nC.")
    .def("ebeamL3Energy", &Psana::Bld::BldDataEBeamV7::ebeamL3Energy,"Beam energy in MeV.")
    .def("ebeamLTUPosX", &Psana::Bld::BldDataEBeamV7::ebeamLTUPosX,"LTU beam position (BPMS:LTU1:720 through 750) in mm.")
    .def("ebeamLTUPosY", &Psana::Bld::BldDataEBeamV7::ebeamLTUPosY,"LTU beam position in mm.")
    .def("ebeamLTUAngX", &Psana::Bld::BldDataEBeamV7::ebeamLTUAngX,"LTU beam angle in mrad.")
    .def("ebeamLTUAngY", &Psana::Bld::BldDataEBeamV7::ebeamLTUAngY,"LTU beam angle in mrad.")
    .def("ebeamPkCurrBC2", &Psana::Bld::BldDataEBeamV7::ebeamPkCurrBC2,"Beam current in Amps.")
    .def("ebeamEnergyBC2", &Psana::Bld::BldDataEBeamV7::ebeamEnergyBC2,"Beam position in mm (related to beam energy).")
    .def("ebeamPkCurrBC1", &Psana::Bld::BldDataEBeamV7::ebeamPkCurrBC1,"Beam current in Amps.")
    .def("ebeamEnergyBC1", &Psana::Bld::BldDataEBeamV7::ebeamEnergyBC1,"Beam position in mm (related to beam energy).")
    .def("ebeamUndPosX", &Psana::Bld::BldDataEBeamV7::ebeamUndPosX,"Undulator launch feedback (BPMs U4 through U10) beam x-position in mm.")
    .def("ebeamUndPosY", &Psana::Bld::BldDataEBeamV7::ebeamUndPosY,"Undulator launch feedback beam y-position in mm.")
    .def("ebeamUndAngX", &Psana::Bld::BldDataEBeamV7::ebeamUndAngX,"Undulator launch feedback beam x-angle in mrad.")
    .def("ebeamUndAngY", &Psana::Bld::BldDataEBeamV7::ebeamUndAngY,"Undulator launch feedback beam y-angle in mrad.")
    .def("ebeamXTCAVAmpl", &Psana::Bld::BldDataEBeamV7::ebeamXTCAVAmpl,"XTCAV Amplitude in MVolt.")
    .def("ebeamXTCAVPhase", &Psana::Bld::BldDataEBeamV7::ebeamXTCAVPhase,"XTCAV Phase in degrees.")
    .def("ebeamDumpCharge", &Psana::Bld::BldDataEBeamV7::ebeamDumpCharge,"Bunch charge at Dump in num. electrons")
    .def("ebeamPhotonEnergy", &Psana::Bld::BldDataEBeamV7::ebeamPhotonEnergy,"computed photon energy, in eV")
    .def("ebeamLTU250", &Psana::Bld::BldDataEBeamV7::ebeamLTU250,"LTU250 BPM value in mm, used to compute photon energy. from BPMS:LTU1:250:X")
    .def("ebeamLTU450", &Psana::Bld::BldDataEBeamV7::ebeamLTU450,"LTU450 BPM value in mm, used to compute photon energy. from BPMS:LTU1:450:X")
  ;

  enum_<Psana::Bld::BldDataEBeamV7::DamageMask>("DamageMask")
    .value("EbeamChargeDamage",Psana::Bld::BldDataEBeamV7::EbeamChargeDamage)
    .value("EbeamL3EnergyDamage",Psana::Bld::BldDataEBeamV7::EbeamL3EnergyDamage)
    .value("EbeamLTUPosXDamage",Psana::Bld::BldDataEBeamV7::EbeamLTUPosXDamage)
    .value("EbeamLTUPosYDamage",Psana::Bld::BldDataEBeamV7::EbeamLTUPosYDamage)
    .value("EbeamLTUAngXDamage",Psana::Bld::BldDataEBeamV7::EbeamLTUAngXDamage)
    .value("EbeamLTUAngYDamage",Psana::Bld::BldDataEBeamV7::EbeamLTUAngYDamage)
    .value("EbeamPkCurrBC2Damage",Psana::Bld::BldDataEBeamV7::EbeamPkCurrBC2Damage)
    .value("EbeamEnergyBC2Damage",Psana::Bld::BldDataEBeamV7::EbeamEnergyBC2Damage)
    .value("EbeamPkCurrBC1Damage",Psana::Bld::BldDataEBeamV7::EbeamPkCurrBC1Damage)
    .value("EbeamEnergyBC1Damage",Psana::Bld::BldDataEBeamV7::EbeamEnergyBC1Damage)
    .value("EbeamUndPosXDamage",Psana::Bld::BldDataEBeamV7::EbeamUndPosXDamage)
    .value("EbeamUndPosYDamage",Psana::Bld::BldDataEBeamV7::EbeamUndPosYDamage)
    .value("EbeamUndAngXDamage",Psana::Bld::BldDataEBeamV7::EbeamUndAngXDamage)
    .value("EbeamUndAngYDamage",Psana::Bld::BldDataEBeamV7::EbeamUndAngYDamage)
    .value("EbeamXTCAVAmplDamage",Psana::Bld::BldDataEBeamV7::EbeamXTCAVAmplDamage)
    .value("EbeamXTCAVPhaseDamage",Psana::Bld::BldDataEBeamV7::EbeamXTCAVPhaseDamage)
    .value("EbeamDumpChargeDamage",Psana::Bld::BldDataEBeamV7::EbeamDumpChargeDamage)
    .value("EbeamPhotonEnergyDamage",Psana::Bld::BldDataEBeamV7::EbeamPhotonEnergyDamage)
  ;
  scope().attr("Version")=7;
  scope().attr("TypeId")=int(Pds::TypeId::Id_EBeam);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDef<Psana::Bld::BldDataEBeamV7> >(Pds::TypeId::Id_EBeam));

  {
  scope outer = 
  class_<Psana::Bld::BldDataPhaseCavity >("BldDataPhaseCavity", "PV names: UND:R02:IOC:16:BAT:FitTime1, UND:R02:IOC:16:BAT:FitTime2,\n                UND:R02:IOC:16:BAT:Charge1,  UND:R02:IOC:16:BAT:Charge2", no_init)
    .def("fitTime1", &Psana::Bld::BldDataPhaseCavity::fitTime1,"UND:R02:IOC:16:BAT:FitTime1 value in pico-seconds.")
    .def("fitTime2", &Psana::Bld::BldDataPhaseCavity::fitTime2,"UND:R02:IOC:16:BAT:FitTime2 value in pico-seconds.")
    .def("charge1", &Psana::Bld::BldDataPhaseCavity::charge1,"UND:R02:IOC:16:BAT:Charge1 value in pico-columbs.")
    .def("charge2", &Psana::Bld::BldDataPhaseCavity::charge2,"UND:R02:IOC:16:BAT:Charge2 value in pico-columbs.")
  ;
  scope().attr("Version")=0;
  scope().attr("TypeId")=int(Pds::TypeId::Id_PhaseCavity);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDef<Psana::Bld::BldDataPhaseCavity> >(Pds::TypeId::Id_PhaseCavity));

  {
  scope outer = 
  class_<Psana::Bld::BldDataIpimbV0, boost::shared_ptr<Psana::Bld::BldDataIpimbV0>, boost::noncopyable >("BldDataIpimbV0", "Combined structure which includes Ipimb.DataV1, Ipimb.ConfigV1, and\n            Lusi.IpmFexV1 objects.", no_init)
    .def("ipimbData", &Psana::Bld::BldDataIpimbV0::ipimbData, return_internal_reference<1>())
    .def("ipimbConfig", &Psana::Bld::BldDataIpimbV0::ipimbConfig, return_internal_reference<1>())
    .def("ipmFexData", &Psana::Bld::BldDataIpimbV0::ipmFexData, return_value_policy<copy_const_reference>())
  ;
  scope().attr("Version")=0;
  scope().attr("TypeId")=int(Pds::TypeId::Id_SharedIpimb);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDefSharedPtr<Psana::Bld::BldDataIpimbV0> >(Pds::TypeId::Id_SharedIpimb));

  {
  scope outer = 
  class_<Psana::Bld::BldDataIpimbV1, boost::shared_ptr<Psana::Bld::BldDataIpimbV1>, boost::noncopyable >("BldDataIpimbV1", "Combined structure which includes Ipimb.DataV2, Ipimb.ConfigV2, and\n            Lusi.IpmFexV1 objects.", no_init)
    .def("ipimbData", &Psana::Bld::BldDataIpimbV1::ipimbData, return_internal_reference<1>())
    .def("ipimbConfig", &Psana::Bld::BldDataIpimbV1::ipimbConfig, return_internal_reference<1>())
    .def("ipmFexData", &Psana::Bld::BldDataIpimbV1::ipmFexData, return_value_policy<copy_const_reference>())
  ;
  scope().attr("Version")=1;
  scope().attr("TypeId")=int(Pds::TypeId::Id_SharedIpimb);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDefSharedPtr<Psana::Bld::BldDataIpimbV1> >(Pds::TypeId::Id_SharedIpimb));

  {
  scope outer = 
  class_<Psana::Bld::BldDataPimV1, boost::shared_ptr<Psana::Bld::BldDataPimV1>, boost::noncopyable >("BldDataPimV1", "Combined structure which includes Pulnix.TM6740ConfigV2, Lusi.PimImageConfigV1, and\n            Camera.FrameV1 objects.", no_init)
    .def("camConfig", &Psana::Bld::BldDataPimV1::camConfig, return_internal_reference<1>())
    .def("pimConfig", &Psana::Bld::BldDataPimV1::pimConfig, return_value_policy<copy_const_reference>())
    .def("frame", &Psana::Bld::BldDataPimV1::frame, return_internal_reference<1>())
  ;
  scope().attr("Version")=1;
  scope().attr("TypeId")=int(Pds::TypeId::Id_SharedPim);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDefSharedPtr<Psana::Bld::BldDataPimV1> >(Pds::TypeId::Id_SharedPim));

  {
  scope outer = 
  class_<Psana::Bld::BldDataGMDV0, boost::shared_ptr<Psana::Bld::BldDataGMDV0>, boost::noncopyable >("BldDataGMDV0", "Gas Monitor Detector data.", no_init)
    .def("gasType", &Psana::Bld::BldDataGMDV0::gasType,"String describing gas type")
    .def("pressure", &Psana::Bld::BldDataGMDV0::pressure,"Pressure from Spinning Rotor Gauge")
    .def("temperature", &Psana::Bld::BldDataGMDV0::temperature,"Temp from PT100")
    .def("current", &Psana::Bld::BldDataGMDV0::current,"Current from Keithley Electrometer")
    .def("hvMeshElectron", &Psana::Bld::BldDataGMDV0::hvMeshElectron,"HV Mesh Electron")
    .def("hvMeshIon", &Psana::Bld::BldDataGMDV0::hvMeshIon,"HV Mesh Ion")
    .def("hvMultIon", &Psana::Bld::BldDataGMDV0::hvMultIon,"HV Mult Ion")
    .def("chargeQ", &Psana::Bld::BldDataGMDV0::chargeQ,"Charge Q")
    .def("photonEnergy", &Psana::Bld::BldDataGMDV0::photonEnergy,"Photon Energy")
    .def("multPulseIntensity", &Psana::Bld::BldDataGMDV0::multPulseIntensity,"Pulse Intensity derived from Electron Multiplier")
    .def("keithleyPulseIntensity", &Psana::Bld::BldDataGMDV0::keithleyPulseIntensity,"Pulse Intensity derived from ION cup current")
    .def("pulseEnergy", &Psana::Bld::BldDataGMDV0::pulseEnergy,"Pulse Energy derived from Electron Multiplier")
    .def("pulseEnergyFEE", &Psana::Bld::BldDataGMDV0::pulseEnergyFEE,"Pulse Energy from FEE Gas Detector")
    .def("transmission", &Psana::Bld::BldDataGMDV0::transmission,"Transmission derived from Electron Multiplier")
    .def("transmissionFEE", &Psana::Bld::BldDataGMDV0::transmissionFEE,"Transmission from FEE Gas Detector")
  ;
  scope().attr("Version")=0;
  scope().attr("TypeId")=int(Pds::TypeId::Id_GMD);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDefSharedPtr<Psana::Bld::BldDataGMDV0> >(Pds::TypeId::Id_GMD));

  {
  scope outer = 
  class_<Psana::Bld::BldDataGMDV1, boost::shared_ptr<Psana::Bld::BldDataGMDV1>, boost::noncopyable >("BldDataGMDV1", "Gas Monitor Detector data.", no_init)
    .def("milliJoulesPerPulse", &Psana::Bld::BldDataGMDV1::milliJoulesPerPulse,"Shot to shot pulse energy (mJ)")
    .def("milliJoulesAverage", &Psana::Bld::BldDataGMDV1::milliJoulesAverage,"Average pulse energy from ION cup current (mJ)")
    .def("correctedSumPerPulse", &Psana::Bld::BldDataGMDV1::correctedSumPerPulse,"Bg corrected waveform integrated within limits in raw A/D counts")
    .def("bgValuePerSample", &Psana::Bld::BldDataGMDV1::bgValuePerSample,"Avg background value per sample in raw A/D counts")
    .def("relativeEnergyPerPulse", &Psana::Bld::BldDataGMDV1::relativeEnergyPerPulse,"Shot by shot pulse energy in arbitrary units")
  ;
  scope().attr("Version")=1;
  scope().attr("TypeId")=int(Pds::TypeId::Id_GMD);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDefSharedPtr<Psana::Bld::BldDataGMDV1> >(Pds::TypeId::Id_GMD));

  {
  scope outer = 
  class_<Psana::Bld::BldDataGMDV2, boost::shared_ptr<Psana::Bld::BldDataGMDV2>, boost::noncopyable >("BldDataGMDV2", "Gas Monitor Detector data.", no_init)
    .def("milliJoulesPerPulse", &Psana::Bld::BldDataGMDV2::milliJoulesPerPulse,"Shot to shot pulse energy (mJ).  Not as robust as relativeEnergyPerPulse() method.")
    .def("milliJoulesAverage", &Psana::Bld::BldDataGMDV2::milliJoulesAverage,"Average pulse energy from ION cup current (mJ).  Not as robust as relativeEnergyPerPulse() method.")
    .def("sumAllPeaksFiltBkgd", &Psana::Bld::BldDataGMDV2::sumAllPeaksFiltBkgd,"Sum of all peaks, normalized w/ filt bkgd level.  Not typically used by the user.")
    .def("rawAvgBkgd", &Psana::Bld::BldDataGMDV2::rawAvgBkgd,"Avg background value per waveform in raw A/D counts.  Not typically used by the user.")
    .def("relativeEnergyPerPulse", &Psana::Bld::BldDataGMDV2::relativeEnergyPerPulse,"Shot by shot pulse energy in arbitrary units.  The most stable measurement.  Most users should use this.")
    .def("sumAllPeaksRawBkgd", &Psana::Bld::BldDataGMDV2::sumAllPeaksRawBkgd,"Sum of all peaks, normalized w/ raw avg bkgd level.  Not typically used by the user.")
  ;
  scope().attr("Version")=2;
  scope().attr("TypeId")=int(Pds::TypeId::Id_GMD);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDefSharedPtr<Psana::Bld::BldDataGMDV2> >(Pds::TypeId::Id_GMD));

  {
  scope outer = 
  class_<Psana::Bld::BldDataAcqADCV1, boost::shared_ptr<Psana::Bld::BldDataAcqADCV1>, boost::noncopyable >("BldDataAcqADCV1", "Combined structure which includes Acqiris.ConfigV1 and\n            Acqiris.DataDescV1 objects.", no_init)
    .def("config", &Psana::Bld::BldDataAcqADCV1::config, return_internal_reference<1>())
    .def("data", &Psana::Bld::BldDataAcqADCV1::data, return_internal_reference<1>())
  ;
  scope().attr("Version")=1;
  scope().attr("TypeId")=int(Pds::TypeId::Id_SharedAcqADC);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDefSharedPtr<Psana::Bld::BldDataAcqADCV1> >(Pds::TypeId::Id_SharedAcqADC));

  {
  scope outer = 
  class_<Psana::Bld::BldDataSpectrometerV0, boost::shared_ptr<Psana::Bld::BldDataSpectrometerV0>, boost::noncopyable >("BldDataSpectrometerV0", "Structure which contains image projections for spectrometers.", no_init)
    .def("hproj", &Psana::Bld::BldDataSpectrometerV0::hproj)
    .def("vproj", &Psana::Bld::BldDataSpectrometerV0::vproj)
  ;
  scope().attr("Version")=0;
  scope().attr("TypeId")=int(Pds::TypeId::Id_Spectrometer);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDefSharedPtr<Psana::Bld::BldDataSpectrometerV0> >(Pds::TypeId::Id_Spectrometer));

  {
  scope outer = 
  class_<Psana::Bld::BldDataSpectrometerV1, boost::shared_ptr<Psana::Bld::BldDataSpectrometerV1>, boost::noncopyable >("BldDataSpectrometerV1", "Structure which contains image projections and fit parameters for spectrometers. \n	Changes from V0 include extending size of hproj, removal of vproj,\n	 and addition of fit parameters.", no_init)
    .def("width", &Psana::Bld::BldDataSpectrometerV1::width,"Width of camera frame and thus size of hproj array \n     PV TBD")
    .def("hproj_y1", &Psana::Bld::BldDataSpectrometerV1::hproj_y1,"First row of pixels used in projection ROI  \n     PV TBD")
    .def("hproj_y2", &Psana::Bld::BldDataSpectrometerV1::hproj_y2,"Last row of pixels used in projection ROI\n    PV: TBD")
    .def("comRaw", &Psana::Bld::BldDataSpectrometerV1::comRaw,"Raw center of mass, no baseline subtraction \n     PV: TBD")
    .def("baseline", &Psana::Bld::BldDataSpectrometerV1::baseline,"Baseline level for calculated values \n     PV: TBD")
    .def("com", &Psana::Bld::BldDataSpectrometerV1::com,"Baseline-subtracted center of mass \n     PV: TBD")
    .def("integral", &Psana::Bld::BldDataSpectrometerV1::integral,"Integrated area under spectrum (no baseline subtraction) \n     PV: TBD")
    .def("nPeaks", &Psana::Bld::BldDataSpectrometerV1::nPeaks,"Number of peak fits performed\n    PV: TBD")
    .def("hproj", &Psana::Bld::BldDataSpectrometerV1::hproj,"Projection of spectrum onto energy axis \n     PV TBD")
    .def("peakPos", &Psana::Bld::BldDataSpectrometerV1::peakPos,"Peak position array, length given by nPeaks\n     PV: TBD")
    .def("peakHeight", &Psana::Bld::BldDataSpectrometerV1::peakHeight,"Peak height array, length given by nPeaks\n     PV: TBD")
    .def("FWHM", &Psana::Bld::BldDataSpectrometerV1::FWHM,"Peak FWHM array, length given by nPeaks\n     PV: TBD")
  ;
  scope().attr("Version")=1;
  scope().attr("TypeId")=int(Pds::TypeId::Id_Spectrometer);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDefSharedPtr<Psana::Bld::BldDataSpectrometerV1> >(Pds::TypeId::Id_Spectrometer));

  {
  scope outer = 
  class_<Psana::Bld::BldDataAnalogInputV1, boost::shared_ptr<Psana::Bld::BldDataAnalogInputV1>, boost::noncopyable >("BldDataAnalogInputV1", "Structure which contains voltage data from an analog input device.", no_init)
    .def("numChannels", &Psana::Bld::BldDataAnalogInputV1::numChannels,"The number of active channels on the analog input device.")
    .def("channelVoltages", &Psana::Bld::BldDataAnalogInputV1::channelVoltages,"Array of voltage values were each entry represents a channel of the analog input device.")
  ;
  scope().attr("Version")=1;
  scope().attr("TypeId")=int(Pds::TypeId::Id_AnalogInput);
  }
  ConverterMap::instance().addConverter(boost::make_shared<ConverterBoostDefSharedPtr<Psana::Bld::BldDataAnalogInputV1> >(Pds::TypeId::Id_AnalogInput));

  {
    PyObject* unvlist = PyList_New(2);
    PyList_SET_ITEM(unvlist, 0, PyObject_GetAttrString(submodule, "BldDataSpectrometerV0"));
    PyList_SET_ITEM(unvlist, 1, PyObject_GetAttrString(submodule, "BldDataSpectrometerV1"));
    PyObject_SetAttrString(submodule, "BldDataSpectrometer", unvlist);
    Py_CLEAR(unvlist);
  }
  {
    PyObject* unvlist = PyList_New(3);
    PyList_SET_ITEM(unvlist, 0, PyObject_GetAttrString(submodule, "BldDataGMDV0"));
    PyList_SET_ITEM(unvlist, 1, PyObject_GetAttrString(submodule, "BldDataGMDV1"));
    PyList_SET_ITEM(unvlist, 2, PyObject_GetAttrString(submodule, "BldDataGMDV2"));
    PyObject_SetAttrString(submodule, "BldDataGMD", unvlist);
    Py_CLEAR(unvlist);
  }
  {
    PyObject* unvlist = PyList_New(8);
    PyList_SET_ITEM(unvlist, 0, PyObject_GetAttrString(submodule, "BldDataEBeamV0"));
    PyList_SET_ITEM(unvlist, 1, PyObject_GetAttrString(submodule, "BldDataEBeamV1"));
    PyList_SET_ITEM(unvlist, 2, PyObject_GetAttrString(submodule, "BldDataEBeamV2"));
    PyList_SET_ITEM(unvlist, 3, PyObject_GetAttrString(submodule, "BldDataEBeamV3"));
    PyList_SET_ITEM(unvlist, 4, PyObject_GetAttrString(submodule, "BldDataEBeamV4"));
    PyList_SET_ITEM(unvlist, 5, PyObject_GetAttrString(submodule, "BldDataEBeamV5"));
    PyList_SET_ITEM(unvlist, 6, PyObject_GetAttrString(submodule, "BldDataEBeamV6"));
    PyList_SET_ITEM(unvlist, 7, PyObject_GetAttrString(submodule, "BldDataEBeamV7"));
    PyObject_SetAttrString(submodule, "BldDataEBeam", unvlist);
    Py_CLEAR(unvlist);
  }
  {
    PyObject* unvlist = PyList_New(1);
    PyList_SET_ITEM(unvlist, 0, PyObject_GetAttrString(submodule, "BldDataAcqADCV1"));
    PyObject_SetAttrString(submodule, "BldDataAcqADC", unvlist);
    Py_CLEAR(unvlist);
  }
  {
    PyObject* unvlist = PyList_New(2);
    PyList_SET_ITEM(unvlist, 0, PyObject_GetAttrString(submodule, "BldDataIpimbV0"));
    PyList_SET_ITEM(unvlist, 1, PyObject_GetAttrString(submodule, "BldDataIpimbV1"));
    PyObject_SetAttrString(submodule, "BldDataIpimb", unvlist);
    Py_CLEAR(unvlist);
  }
  {
    PyObject* unvlist = PyList_New(1);
    PyList_SET_ITEM(unvlist, 0, PyObject_GetAttrString(submodule, "BldDataAnalogInputV1"));
    PyObject_SetAttrString(submodule, "BldDataAnalogInput", unvlist);
    Py_CLEAR(unvlist);
  }
  {
    PyObject* unvlist = PyList_New(1);
    PyList_SET_ITEM(unvlist, 0, PyObject_GetAttrString(submodule, "BldDataPimV1"));
    PyObject_SetAttrString(submodule, "BldDataPim", unvlist);
    Py_CLEAR(unvlist);
  }
  detail::register_ndarray_to_numpy_cvt<const uint32_t, 1>();
  detail::register_ndarray_to_numpy_cvt<const double, 1>();

} // createWrappers()
} // namespace Bld
} // namespace psddl_python
