/* Do not edit this file, as it is auto-generated */

#ifndef PSDDL_PYTHON_CSPAD_DDL_WRAPPER_H
#define PSDDL_PYTHON_CSPAD_DDL_WRAPPER_H 1

#include <vector>
#include "psddl_python/DdlWrapper.h"
#include "psddl_python/Converter.h"
#include "ndarray/ndarray.h"
#include "pdsdata/xtc/TypeId.hh"
#include "psddl_psana/cspad.ddl.h" // inc_psana

namespace psddl_python {
namespace CsPad {

using namespace boost::python;
using boost::python::api::object;
using boost::shared_ptr;
using std::vector;

void createWrappers(PyObject* module);

class CsPadDigitalPotsCfg_Wrapper {
  shared_ptr<const Psana::CsPad::CsPadDigitalPotsCfg> m_obj;
public:
  CsPadDigitalPotsCfg_Wrapper(const shared_ptr<const Psana::CsPad::CsPadDigitalPotsCfg>& obj) : m_obj(obj) {}
  PyObject* pots() const { return detail::ndToNumpy(m_obj->pots(), m_obj); }
};

class CsPadReadOnlyCfg_Wrapper {
  shared_ptr<const Psana::CsPad::CsPadReadOnlyCfg> m_obj;
public:
  CsPadReadOnlyCfg_Wrapper(const shared_ptr<const Psana::CsPad::CsPadReadOnlyCfg>& obj) : m_obj(obj) {}
  uint32_t shiftTest() const { return m_obj->shiftTest(); }
  uint32_t version() const { return m_obj->version(); }
};

class ProtectionSystemThreshold_Wrapper {
  shared_ptr<const Psana::CsPad::ProtectionSystemThreshold> m_obj;
public:
  ProtectionSystemThreshold_Wrapper(const shared_ptr<const Psana::CsPad::ProtectionSystemThreshold>& obj) : m_obj(obj) {}
  uint32_t adcThreshold() const { return m_obj->adcThreshold(); }
  uint32_t pixelCountThreshold() const { return m_obj->pixelCountThreshold(); }
};

class CsPadGainMapCfg_Wrapper {
  shared_ptr<const Psana::CsPad::CsPadGainMapCfg> m_obj;
public:
  CsPadGainMapCfg_Wrapper(const shared_ptr<const Psana::CsPad::CsPadGainMapCfg>& obj) : m_obj(obj) {}
  PyObject* gainMap() const { return detail::ndToNumpy(m_obj->gainMap(), m_obj); }
};

class ConfigV1QuadReg_Wrapper {
  shared_ptr<const Psana::CsPad::ConfigV1QuadReg> m_obj;
public:
  ConfigV1QuadReg_Wrapper(const shared_ptr<const Psana::CsPad::ConfigV1QuadReg>& obj) : m_obj(obj) {}
  PyObject* shiftSelect() const { return detail::ndToNumpy(m_obj->shiftSelect(), m_obj); }
  PyObject* edgeSelect() const { return detail::ndToNumpy(m_obj->edgeSelect(), m_obj); }
  uint32_t readClkSet() const { return m_obj->readClkSet(); }
  uint32_t readClkHold() const { return m_obj->readClkHold(); }
  uint32_t dataMode() const { return m_obj->dataMode(); }
  uint32_t prstSel() const { return m_obj->prstSel(); }
  uint32_t acqDelay() const { return m_obj->acqDelay(); }
  uint32_t intTime() const { return m_obj->intTime(); }
  uint32_t digDelay() const { return m_obj->digDelay(); }
  uint32_t ampIdle() const { return m_obj->ampIdle(); }
  uint32_t injTotal() const { return m_obj->injTotal(); }
  uint32_t rowColShiftPer() const { return m_obj->rowColShiftPer(); }
  const Psana::CsPad::CsPadReadOnlyCfg& ro() const { return m_obj->ro(); }
  const Psana::CsPad::CsPadDigitalPotsCfg& dp() const { return m_obj->dp(); }
  const Psana::CsPad::CsPadGainMapCfg& gm() const { return m_obj->gm(); }
};

class ConfigV2QuadReg_Wrapper {
  shared_ptr<const Psana::CsPad::ConfigV2QuadReg> m_obj;
public:
  ConfigV2QuadReg_Wrapper(const shared_ptr<const Psana::CsPad::ConfigV2QuadReg>& obj) : m_obj(obj) {}
  PyObject* shiftSelect() const { return detail::ndToNumpy(m_obj->shiftSelect(), m_obj); }
  PyObject* edgeSelect() const { return detail::ndToNumpy(m_obj->edgeSelect(), m_obj); }
  uint32_t readClkSet() const { return m_obj->readClkSet(); }
  uint32_t readClkHold() const { return m_obj->readClkHold(); }
  uint32_t dataMode() const { return m_obj->dataMode(); }
  uint32_t prstSel() const { return m_obj->prstSel(); }
  uint32_t acqDelay() const { return m_obj->acqDelay(); }
  uint32_t intTime() const { return m_obj->intTime(); }
  uint32_t digDelay() const { return m_obj->digDelay(); }
  uint32_t ampIdle() const { return m_obj->ampIdle(); }
  uint32_t injTotal() const { return m_obj->injTotal(); }
  uint32_t rowColShiftPer() const { return m_obj->rowColShiftPer(); }
  uint32_t ampReset() const { return m_obj->ampReset(); }
  uint32_t digCount() const { return m_obj->digCount(); }
  uint32_t digPeriod() const { return m_obj->digPeriod(); }
  const Psana::CsPad::CsPadReadOnlyCfg& ro() const { return m_obj->ro(); }
  const Psana::CsPad::CsPadDigitalPotsCfg& dp() const { return m_obj->dp(); }
  const Psana::CsPad::CsPadGainMapCfg& gm() const { return m_obj->gm(); }
};

class ConfigV1_Wrapper {
  shared_ptr<const Psana::CsPad::ConfigV1> m_obj;
public:
  enum { TypeId = Pds::TypeId::Id_CspadConfig };
  enum { Version = 1 };
  ConfigV1_Wrapper(const shared_ptr<const Psana::CsPad::ConfigV1>& obj) : m_obj(obj) {}
  uint32_t concentratorVersion() const { return m_obj->concentratorVersion(); }
  uint32_t runDelay() const { return m_obj->runDelay(); }
  uint32_t eventCode() const { return m_obj->eventCode(); }
  uint32_t inactiveRunMode() const { return m_obj->inactiveRunMode(); }
  uint32_t activeRunMode() const { return m_obj->activeRunMode(); }
  uint32_t tdi() const { return m_obj->tdi(); }
  uint32_t payloadSize() const { return m_obj->payloadSize(); }
  uint32_t badAsicMask0() const { return m_obj->badAsicMask0(); }
  uint32_t badAsicMask1() const { return m_obj->badAsicMask1(); }
  uint32_t asicMask() const { return m_obj->asicMask(); }
  uint32_t quadMask() const { return m_obj->quadMask(); }
  CsPad::ConfigV1QuadReg_Wrapper quads(uint32_t i0) const { return CsPad::ConfigV1QuadReg_Wrapper(boost::shared_ptr<const Psana::CsPad::ConfigV1QuadReg>(m_obj, &m_obj->quads(i0))); }
  uint32_t numAsicsRead() const { return m_obj->numAsicsRead(); }
  uint32_t numQuads() const { return m_obj->numQuads(); }
  uint32_t numSect() const { return m_obj->numSect(); }
  boost::python::list quads_shape() const { boost::python::list res; const vector<int>& sh=m_obj->quads_shape(); for (vector<int>::const_iterator i = sh.begin(); i != sh.end(); ++ i) res.append(*i); return res; }
};

class ConfigV2_Wrapper {
  shared_ptr<const Psana::CsPad::ConfigV2> m_obj;
public:
  enum { TypeId = Pds::TypeId::Id_CspadConfig };
  enum { Version = 2 };
  ConfigV2_Wrapper(const shared_ptr<const Psana::CsPad::ConfigV2>& obj) : m_obj(obj) {}
  uint32_t concentratorVersion() const { return m_obj->concentratorVersion(); }
  uint32_t runDelay() const { return m_obj->runDelay(); }
  uint32_t eventCode() const { return m_obj->eventCode(); }
  uint32_t inactiveRunMode() const { return m_obj->inactiveRunMode(); }
  uint32_t activeRunMode() const { return m_obj->activeRunMode(); }
  uint32_t tdi() const { return m_obj->tdi(); }
  uint32_t payloadSize() const { return m_obj->payloadSize(); }
  uint32_t badAsicMask0() const { return m_obj->badAsicMask0(); }
  uint32_t badAsicMask1() const { return m_obj->badAsicMask1(); }
  uint32_t asicMask() const { return m_obj->asicMask(); }
  uint32_t quadMask() const { return m_obj->quadMask(); }
  CsPad::ConfigV1QuadReg_Wrapper quads(uint32_t i0) const { return CsPad::ConfigV1QuadReg_Wrapper(boost::shared_ptr<const Psana::CsPad::ConfigV1QuadReg>(m_obj, &m_obj->quads(i0))); }
  uint32_t numAsicsRead() const { return m_obj->numAsicsRead(); }
  uint32_t roiMask(uint32_t iq) const { return m_obj->roiMask(iq); }
  uint32_t numAsicsStored(uint32_t iq) const { return m_obj->numAsicsStored(iq); }
  uint32_t numQuads() const { return m_obj->numQuads(); }
  uint32_t numSect() const { return m_obj->numSect(); }
  boost::python::list quads_shape() const { boost::python::list res; const vector<int>& sh=m_obj->quads_shape(); for (vector<int>::const_iterator i = sh.begin(); i != sh.end(); ++ i) res.append(*i); return res; }
};

class ConfigV3_Wrapper {
  shared_ptr<const Psana::CsPad::ConfigV3> m_obj;
public:
  enum { TypeId = Pds::TypeId::Id_CspadConfig };
  enum { Version = 3 };
  ConfigV3_Wrapper(const shared_ptr<const Psana::CsPad::ConfigV3>& obj) : m_obj(obj) {}
  uint32_t concentratorVersion() const { return m_obj->concentratorVersion(); }
  uint32_t runDelay() const { return m_obj->runDelay(); }
  uint32_t eventCode() const { return m_obj->eventCode(); }
  CsPad::ProtectionSystemThreshold_Wrapper protectionThresholds(uint32_t i0) const { return CsPad::ProtectionSystemThreshold_Wrapper(boost::shared_ptr<const Psana::CsPad::ProtectionSystemThreshold>(m_obj, &m_obj->protectionThresholds(i0))); }
  uint32_t protectionEnable() const { return m_obj->protectionEnable(); }
  uint32_t inactiveRunMode() const { return m_obj->inactiveRunMode(); }
  uint32_t activeRunMode() const { return m_obj->activeRunMode(); }
  uint32_t tdi() const { return m_obj->tdi(); }
  uint32_t payloadSize() const { return m_obj->payloadSize(); }
  uint32_t badAsicMask0() const { return m_obj->badAsicMask0(); }
  uint32_t badAsicMask1() const { return m_obj->badAsicMask1(); }
  uint32_t asicMask() const { return m_obj->asicMask(); }
  uint32_t quadMask() const { return m_obj->quadMask(); }
  CsPad::ConfigV1QuadReg_Wrapper quads(uint32_t i0) const { return CsPad::ConfigV1QuadReg_Wrapper(boost::shared_ptr<const Psana::CsPad::ConfigV1QuadReg>(m_obj, &m_obj->quads(i0))); }
  uint32_t numAsicsRead() const { return m_obj->numAsicsRead(); }
  uint32_t roiMask(uint32_t iq) const { return m_obj->roiMask(iq); }
  uint32_t numAsicsStored(uint32_t iq) const { return m_obj->numAsicsStored(iq); }
  uint32_t numQuads() const { return m_obj->numQuads(); }
  uint32_t numSect() const { return m_obj->numSect(); }
  boost::python::list protectionThresholds_shape() const { boost::python::list res; const vector<int>& sh=m_obj->protectionThresholds_shape(); for (vector<int>::const_iterator i = sh.begin(); i != sh.end(); ++ i) res.append(*i); return res; }
  boost::python::list quads_shape() const { boost::python::list res; const vector<int>& sh=m_obj->quads_shape(); for (vector<int>::const_iterator i = sh.begin(); i != sh.end(); ++ i) res.append(*i); return res; }
};

class ConfigV4_Wrapper {
  shared_ptr<const Psana::CsPad::ConfigV4> m_obj;
public:
  enum { TypeId = Pds::TypeId::Id_CspadConfig };
  enum { Version = 4 };
  ConfigV4_Wrapper(const shared_ptr<const Psana::CsPad::ConfigV4>& obj) : m_obj(obj) {}
  uint32_t concentratorVersion() const { return m_obj->concentratorVersion(); }
  uint32_t runDelay() const { return m_obj->runDelay(); }
  uint32_t eventCode() const { return m_obj->eventCode(); }
  CsPad::ProtectionSystemThreshold_Wrapper protectionThresholds(uint32_t i0) const { return CsPad::ProtectionSystemThreshold_Wrapper(boost::shared_ptr<const Psana::CsPad::ProtectionSystemThreshold>(m_obj, &m_obj->protectionThresholds(i0))); }
  uint32_t protectionEnable() const { return m_obj->protectionEnable(); }
  uint32_t inactiveRunMode() const { return m_obj->inactiveRunMode(); }
  uint32_t activeRunMode() const { return m_obj->activeRunMode(); }
  uint32_t tdi() const { return m_obj->tdi(); }
  uint32_t payloadSize() const { return m_obj->payloadSize(); }
  uint32_t badAsicMask0() const { return m_obj->badAsicMask0(); }
  uint32_t badAsicMask1() const { return m_obj->badAsicMask1(); }
  uint32_t asicMask() const { return m_obj->asicMask(); }
  uint32_t quadMask() const { return m_obj->quadMask(); }
  CsPad::ConfigV2QuadReg_Wrapper quads(uint32_t i0) const { return CsPad::ConfigV2QuadReg_Wrapper(boost::shared_ptr<const Psana::CsPad::ConfigV2QuadReg>(m_obj, &m_obj->quads(i0))); }
  uint32_t numAsicsRead() const { return m_obj->numAsicsRead(); }
  uint32_t roiMask(uint32_t iq) const { return m_obj->roiMask(iq); }
  uint32_t numAsicsStored(uint32_t iq) const { return m_obj->numAsicsStored(iq); }
  uint32_t numQuads() const { return m_obj->numQuads(); }
  uint32_t numSect() const { return m_obj->numSect(); }
  boost::python::list protectionThresholds_shape() const { boost::python::list res; const vector<int>& sh=m_obj->protectionThresholds_shape(); for (vector<int>::const_iterator i = sh.begin(); i != sh.end(); ++ i) res.append(*i); return res; }
  boost::python::list quads_shape() const { boost::python::list res; const vector<int>& sh=m_obj->quads_shape(); for (vector<int>::const_iterator i = sh.begin(); i != sh.end(); ++ i) res.append(*i); return res; }
};
class ConfigV1;
class ConfigV2;
class ConfigV3;
class ConfigV4;

class ElementV1_Wrapper {
  shared_ptr<const Psana::CsPad::ElementV1> m_obj;
public:
  ElementV1_Wrapper(const shared_ptr<const Psana::CsPad::ElementV1>& obj) : m_obj(obj) {}
  uint32_t virtual_channel() const { return m_obj->virtual_channel(); }
  uint32_t lane() const { return m_obj->lane(); }
  uint32_t tid() const { return m_obj->tid(); }
  uint32_t acq_count() const { return m_obj->acq_count(); }
  uint32_t op_code() const { return m_obj->op_code(); }
  uint32_t quad() const { return m_obj->quad(); }
  uint32_t seq_count() const { return m_obj->seq_count(); }
  uint32_t ticks() const { return m_obj->ticks(); }
  uint32_t fiducials() const { return m_obj->fiducials(); }
  PyObject* sb_temp() const { return detail::ndToNumpy(m_obj->sb_temp(), m_obj); }
  uint32_t frame_type() const { return m_obj->frame_type(); }
  PyObject* data() const { return detail::ndToNumpy(m_obj->data(), m_obj); }
  uint32_t sectionMask() const { return m_obj->sectionMask(); }
  float common_mode(uint32_t section) const { return m_obj->common_mode(section); }
};
class ConfigV1;
class ConfigV2;
class ConfigV3;
class ConfigV4;

class DataV1_Wrapper {
  shared_ptr<const Psana::CsPad::DataV1> m_obj;
public:
  enum { TypeId = Pds::TypeId::Id_CspadElement };
  enum { Version = 1 };
  DataV1_Wrapper(const shared_ptr<const Psana::CsPad::DataV1>& obj) : m_obj(obj) {}
  CsPad::ElementV1_Wrapper quads(uint32_t i0) const { return CsPad::ElementV1_Wrapper(boost::shared_ptr<const Psana::CsPad::ElementV1>(m_obj, &m_obj->quads(i0))); }
  boost::python::list quads_shape() const { boost::python::list res; const vector<int>& sh=m_obj->quads_shape(); for (vector<int>::const_iterator i = sh.begin(); i != sh.end(); ++ i) res.append(*i); return res; }
  boost::python::list quads_list() { boost::python::list l; const int n = m_obj->quads_shape()[0]; for (int i = 0; i < n; i++) l.append(quads(i)); return l; }
};
class ConfigV2;
class ConfigV3;
class ConfigV4;

class ElementV2_Wrapper {
  shared_ptr<const Psana::CsPad::ElementV2> m_obj;
public:
  ElementV2_Wrapper(const shared_ptr<const Psana::CsPad::ElementV2>& obj) : m_obj(obj) {}
  uint32_t virtual_channel() const { return m_obj->virtual_channel(); }
  uint32_t lane() const { return m_obj->lane(); }
  uint32_t tid() const { return m_obj->tid(); }
  uint32_t acq_count() const { return m_obj->acq_count(); }
  uint32_t op_code() const { return m_obj->op_code(); }
  uint32_t quad() const { return m_obj->quad(); }
  uint32_t seq_count() const { return m_obj->seq_count(); }
  uint32_t ticks() const { return m_obj->ticks(); }
  uint32_t fiducials() const { return m_obj->fiducials(); }
  PyObject* sb_temp() const { return detail::ndToNumpy(m_obj->sb_temp(), m_obj); }
  uint32_t frame_type() const { return m_obj->frame_type(); }
  PyObject* data() const { return detail::ndToNumpy(m_obj->data(), m_obj); }
  uint32_t sectionMask() const { return m_obj->sectionMask(); }
  float common_mode(uint32_t section) const { return m_obj->common_mode(section); }
};
class ConfigV2;
class ConfigV3;
class ConfigV4;

class DataV2_Wrapper {
  shared_ptr<const Psana::CsPad::DataV2> m_obj;
public:
  enum { TypeId = Pds::TypeId::Id_CspadElement };
  enum { Version = 2 };
  DataV2_Wrapper(const shared_ptr<const Psana::CsPad::DataV2>& obj) : m_obj(obj) {}
  CsPad::ElementV2_Wrapper quads(uint32_t i0) const { return CsPad::ElementV2_Wrapper(boost::shared_ptr<const Psana::CsPad::ElementV2>(m_obj, &m_obj->quads(i0))); }
  boost::python::list quads_shape() const { boost::python::list res; const vector<int>& sh=m_obj->quads_shape(); for (vector<int>::const_iterator i = sh.begin(); i != sh.end(); ++ i) res.append(*i); return res; }
  boost::python::list quads_list() { boost::python::list l; const int n = m_obj->quads_shape()[0]; for (int i = 0; i < n; i++) l.append(quads(i)); return l; }
};
} // namespace CsPad
} // namespace psddl_python
#endif // PSDDL_PYTHON_CSPAD_DDL_WRAPPER_H
