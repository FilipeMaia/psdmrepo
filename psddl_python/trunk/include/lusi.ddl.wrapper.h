#ifndef PSANA_LUSI_DDL_WRAPPER_H
#define PSANA_LUSI_DDL_WRAPPER_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <ndarray/ndarray.h>
#include <pdsdata/xtc/TypeId.hh>
#include <psddl_pyana/DdlWrapper.h>
namespace Psana {
namespace Lusi {

extern void createWrappers();


/** @class DiodeFexConfigV1

  
*/

#pragma pack(push,4)

class DiodeFexConfigV1_Wrapper {
  boost::shared_ptr<DiodeFexConfigV1> _o;
  DiodeFexConfigV1* o;
public:
  enum { TypeId = Pds::TypeId::Id_DiodeFexConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { NRANGES = 3 };
  DiodeFexConfigV1_Wrapper(boost::shared_ptr<DiodeFexConfigV1> obj) : _o(obj), o(_o.get()) {}
  DiodeFexConfigV1_Wrapper(DiodeFexConfigV1* obj) : o(obj) {}
  bool operator==(const DiodeFexConfigV1_Wrapper &t) const { return this == &t; }
  std::vector<float> base() const { VEC_CONVERT(o->base(), float); }
  std::vector<float> scale() const { VEC_CONVERT(o->scale(), float); }
  uint32_t _sizeof() const { return o->_sizeof(); }
private:
  float	_base[NRANGES];
  float	_scale[NRANGES];
};
#pragma pack(pop)

/** @class DiodeFexConfigV2

  
*/

#pragma pack(push,4)

class DiodeFexConfigV2_Wrapper {
  boost::shared_ptr<DiodeFexConfigV2> _o;
  DiodeFexConfigV2* o;
public:
  enum { TypeId = Pds::TypeId::Id_DiodeFexConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  enum { NRANGES = 16 };
  DiodeFexConfigV2_Wrapper(boost::shared_ptr<DiodeFexConfigV2> obj) : _o(obj), o(_o.get()) {}
  DiodeFexConfigV2_Wrapper(DiodeFexConfigV2* obj) : o(obj) {}
  bool operator==(const DiodeFexConfigV2_Wrapper &t) const { return this == &t; }
  std::vector<float> base() const { VEC_CONVERT(o->base(), float); }
  std::vector<float> scale() const { VEC_CONVERT(o->scale(), float); }
  uint32_t _sizeof() const { return o->_sizeof(); }
private:
  float	_base[NRANGES];
  float	_scale[NRANGES];
};
#pragma pack(pop)

/** @class DiodeFexV1

  
*/

#pragma pack(push,4)

class DiodeFexV1_Wrapper {
  boost::shared_ptr<DiodeFexV1> _o;
  DiodeFexV1* o;
public:
  enum { TypeId = Pds::TypeId::Id_DiodeFex /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  DiodeFexV1_Wrapper(boost::shared_ptr<DiodeFexV1> obj) : _o(obj), o(_o.get()) {}
  DiodeFexV1_Wrapper(DiodeFexV1* obj) : o(obj) {}
  bool operator==(const DiodeFexV1_Wrapper &t) const { return this == &t; }
  float value() const { return o->value(); }
  uint32_t _sizeof() const { return o->_sizeof(); }
private:
  float	_value;
};
#pragma pack(pop)

/** @class IpmFexConfigV1

  
*/


class IpmFexConfigV1_Wrapper {
  boost::shared_ptr<IpmFexConfigV1> _o;
  IpmFexConfigV1* o;
public:
  enum { TypeId = Pds::TypeId::Id_IpmFexConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { NCHANNELS = 4 };
  IpmFexConfigV1_Wrapper(boost::shared_ptr<IpmFexConfigV1> obj) : _o(obj), o(_o.get()) {}
  IpmFexConfigV1_Wrapper(IpmFexConfigV1* obj) : o(obj) {}
  bool operator==(const IpmFexConfigV1_Wrapper &t) const { return this == &t; }
  std::vector<Lusi::DiodeFexConfigV1> diode() const { VEC_CONVERT(o->diode(), Lusi::DiodeFexConfigV1); }
  float xscale() const { return o->xscale(); }
  float yscale() const { return o->yscale(); }
};

/** @class IpmFexConfigV2

  
*/


class IpmFexConfigV2_Wrapper {
  boost::shared_ptr<IpmFexConfigV2> _o;
  IpmFexConfigV2* o;
public:
  enum { TypeId = Pds::TypeId::Id_IpmFexConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  enum { NCHANNELS = 4 };
  IpmFexConfigV2_Wrapper(boost::shared_ptr<IpmFexConfigV2> obj) : _o(obj), o(_o.get()) {}
  IpmFexConfigV2_Wrapper(IpmFexConfigV2* obj) : o(obj) {}
  bool operator==(const IpmFexConfigV2_Wrapper &t) const { return this == &t; }
  std::vector<Lusi::DiodeFexConfigV2> diode() const { VEC_CONVERT(o->diode(), Lusi::DiodeFexConfigV2); }
  float xscale() const { return o->xscale(); }
  float yscale() const { return o->yscale(); }
};

/** @class IpmFexV1

  
*/

#pragma pack(push,4)

class IpmFexV1_Wrapper {
  boost::shared_ptr<IpmFexV1> _o;
  IpmFexV1* o;
public:
  enum { TypeId = Pds::TypeId::Id_IpmFex /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { NCHANNELS = 4 };
  IpmFexV1_Wrapper(boost::shared_ptr<IpmFexV1> obj) : _o(obj), o(_o.get()) {}
  IpmFexV1_Wrapper(IpmFexV1* obj) : o(obj) {}
  bool operator==(const IpmFexV1_Wrapper &t) const { return this == &t; }
  std::vector<float> channel() const { VEC_CONVERT(o->channel(), float); }
  float sum() const { return o->sum(); }
  float xpos() const { return o->xpos(); }
  float ypos() const { return o->ypos(); }
  uint32_t _sizeof() const { return o->_sizeof(); }
private:
  float	_channel[NCHANNELS];
  float	_sum;
  float	_xpos;
  float	_ypos;
};
#pragma pack(pop)

/** @class PimImageConfigV1

  
*/

#pragma pack(push,4)

class PimImageConfigV1_Wrapper {
  boost::shared_ptr<PimImageConfigV1> _o;
  PimImageConfigV1* o;
public:
  enum { TypeId = Pds::TypeId::Id_PimImageConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  PimImageConfigV1_Wrapper(boost::shared_ptr<PimImageConfigV1> obj) : _o(obj), o(_o.get()) {}
  PimImageConfigV1_Wrapper(PimImageConfigV1* obj) : o(obj) {}
  bool operator==(const PimImageConfigV1_Wrapper &t) const { return this == &t; }
  float xscale() const { return o->xscale(); }
  float yscale() const { return o->yscale(); }
  uint32_t _sizeof() const { return o->_sizeof(); }
private:
  float	_xscale;
  float	_yscale;
};
#pragma pack(pop)
} // namespace Lusi
} // namespace Psana
#endif // PSANA_LUSI_DDL_WRAPPER_H
