#ifndef PSANA_LUSI_DDL_H
#define PSANA_LUSI_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include "pdsdata/xtc/TypeId.hh"

#include <vector>

namespace Psana {
namespace Lusi {

/** Class: DiodeFexConfigV1
  
*/

#pragma pack(push,4)

class DiodeFexConfigV1 {
public:
  enum {Version = 1};
  enum {TypeId = Pds::TypeId::Id_DiodeFexConfig};
  enum {NRANGES = 3};
  DiodeFexConfigV1()
  {
  }
  DiodeFexConfigV1(const float* arg__base, const float* arg__scale)
  {
    std::copy(arg__base, arg__base+(3), _base);
    std::copy(arg__scale, arg__scale+(3), _scale);
  }
  const float* base() const {return &_base[0];}
  const float* scale() const {return &_scale[0];}
  static uint32_t _sizeof()  {return (0+(4*(NRANGES)))+(4*(NRANGES));}
  std::vector<int> base_shape() const;
  std::vector<int> scale_shape() const;
private:
  float	_base[NRANGES];
  float	_scale[NRANGES];
};
#pragma pack(pop)

/** Class: DiodeFexV1
  
*/

#pragma pack(push,4)

class DiodeFexV1 {
public:
  enum {Version = 1};
  enum {TypeId = Pds::TypeId::Id_DiodeFex};
  DiodeFexV1(float arg__value)
    : _value(arg__value)
  {
  }
  float value() const {return _value;}
  static uint32_t _sizeof()  {return 4;}
private:
  float	_value;
};
#pragma pack(pop)

/** Class: IpmFexConfigV1
  
*/


class IpmFexConfigV1 {
public:
  enum {Version = 1};
  enum {TypeId = Pds::TypeId::Id_IpmFexConfig};
  enum {NCHANNELS = 4};
  virtual ~IpmFexConfigV1();
  virtual const Lusi::DiodeFexConfigV1& diode(uint32_t i0) const = 0;
  virtual float xscale() const = 0;
  virtual float yscale() const = 0;
  virtual std::vector<int> diode_shape() const = 0;
};

/** Class: IpmFexV1
  
*/

#pragma pack(push,4)

class IpmFexV1 {
public:
  enum {Version = 1};
  enum {TypeId = Pds::TypeId::Id_IpmFex};
  enum {NCHANNELS = 4};
  IpmFexV1(const float* arg__channel, float arg__sum, float arg__xpos, float arg__ypos)
    : _sum(arg__sum), _xpos(arg__xpos), _ypos(arg__ypos)
  {
    std::copy(arg__channel, arg__channel+(4), _channel);
  }
  const float* channel() const {return &_channel[0];}
  float sum() const {return _sum;}
  float xpos() const {return _xpos;}
  float ypos() const {return _ypos;}
  static uint32_t _sizeof()  {return (((0+(4*(NCHANNELS)))+4)+4)+4;}
  std::vector<int> channel_shape() const;
private:
  float	_channel[NCHANNELS];
  float	_sum;
  float	_xpos;
  float	_ypos;
};
#pragma pack(pop)

/** Class: PimImageConfigV1
  
*/

#pragma pack(push,4)

class PimImageConfigV1 {
public:
  enum {Version = 1};
  enum {TypeId = Pds::TypeId::Id_PimImageConfig};
  PimImageConfigV1(float arg__xscale, float arg__yscale)
    : _xscale(arg__xscale), _yscale(arg__yscale)
  {
  }
  float xscale() const {return _xscale;}
  float yscale() const {return _yscale;}
  static uint32_t _sizeof()  {return 8;}
private:
  float	_xscale;
  float	_yscale;
};
#pragma pack(pop)
} // namespace Lusi
} // namespace Psana
#endif // PSANA_LUSI_DDL_H
