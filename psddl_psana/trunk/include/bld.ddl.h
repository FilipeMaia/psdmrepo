#ifndef PSANA_BLD_DDL_H
#define PSANA_BLD_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstring>
#include "ndarray/ndarray.h"
#include "pdsdata/xtc/TypeId.hh"
#include "psddl_psana/acqiris.ddl.h"
#include "psddl_psana/camera.ddl.h"
#include "psddl_psana/ipimb.ddl.h"
#include "psddl_psana/lusi.ddl.h"
#include "psddl_psana/pulnix.ddl.h"
namespace Psana {
namespace Bld {

/** @class BldDataFEEGasDetEnergy

  Four energy measurements from Front End Enclosure Gas Detector.
               PV names: GDET:FEE1:11:ENRC, GDET:FEE1:12:ENRC, GDET:FEE1:21:ENRC, GDET:FEE1:22:ENRC.
*/


class BldDataFEEGasDetEnergy {
public:
  enum { TypeId = Pds::TypeId::Id_FEEGasDetEnergy /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 0 /**< XTC type version number */ };
  BldDataFEEGasDetEnergy(double arg__f_11_ENRC, double arg__f_12_ENRC, double arg__f_21_ENRC, double arg__f_22_ENRC)
    : _f_11_ENRC(arg__f_11_ENRC), _f_12_ENRC(arg__f_12_ENRC), _f_21_ENRC(arg__f_21_ENRC), _f_22_ENRC(arg__f_22_ENRC)
  {
  }
  BldDataFEEGasDetEnergy() {}
  /** Value of GDET:FEE1:11:ENRC, in mJ. */
  double f_11_ENRC() const { return _f_11_ENRC; }
  /** Value of GDET:FEE1:12:ENRC, in mJ. */
  double f_12_ENRC() const { return _f_12_ENRC; }
  /** Value of GDET:FEE1:21:ENRC, in mJ. */
  double f_21_ENRC() const { return _f_21_ENRC; }
  /** Value of GDET:FEE1:22:ENRC, in mJ. */
  double f_22_ENRC() const { return _f_22_ENRC; }
  static uint32_t _sizeof() { return 32; }
private:
  double	_f_11_ENRC;	/**< Value of GDET:FEE1:11:ENRC, in mJ. */
  double	_f_12_ENRC;	/**< Value of GDET:FEE1:12:ENRC, in mJ. */
  double	_f_21_ENRC;	/**< Value of GDET:FEE1:21:ENRC, in mJ. */
  double	_f_22_ENRC;	/**< Value of GDET:FEE1:22:ENRC, in mJ. */
};

/** @class BldDataFEEGasDetEnergyV1

  Six energy measurements from Front End Enclosure Gas Detector.
   PV names: GDET:FEE1:241:ENRC, GDET:FEE1:242:ENRC, 
	GDET:FEE1:361:ENRC, GDET:FEE1:362:ENRC, 
	GDET:FEE1:363:ENRC, and GDET:FEE1:364:ENRC 
   Each pair of methods (e.g. f_11_ENRC(), f_12_ENRC() contains
   identical measurements using two different phototubes.  "11" and "12"
   are before the gas attenuation.  "21" and "22" are after gas
   attenuation.
   "63" and "64" are duplicate measurements of "21" and "22" respectively. 
    The difference is that they cover a smaller (10%) dynamic range. 
    When the beam is weak, 361 and 362 don't have good S/N, these 2 extra PVs should be used instead.  Dehong Zhang suggests that the threshold
    for "weak" is around 0.5 mJ.
*/


class BldDataFEEGasDetEnergyV1 {
public:
  enum { TypeId = Pds::TypeId::Id_FEEGasDetEnergy /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  BldDataFEEGasDetEnergyV1(double arg__f_11_ENRC, double arg__f_12_ENRC, double arg__f_21_ENRC, double arg__f_22_ENRC, double arg__f_63_ENRC, double arg__f_64_ENRC)
    : _f_11_ENRC(arg__f_11_ENRC), _f_12_ENRC(arg__f_12_ENRC), _f_21_ENRC(arg__f_21_ENRC), _f_22_ENRC(arg__f_22_ENRC), _f_63_ENRC(arg__f_63_ENRC), _f_64_ENRC(arg__f_64_ENRC)
  {
  }
  BldDataFEEGasDetEnergyV1() {}
  /** First energy measurement (mJ) before attenuation. (pv name GDET:FEE1:241:ENRC) */
  double f_11_ENRC() const { return _f_11_ENRC; }
  /** Second (duplicate!) energy measurement (mJ) after attenuation. (pv name GDET:FEE1:242:ENRC) */
  double f_12_ENRC() const { return _f_12_ENRC; }
  /** First energy measurement (mJ) after attenuation. (pv name  GDET:FEE1:361:ENRC) */
  double f_21_ENRC() const { return _f_21_ENRC; }
  /** Second (duplicate!) energy measurement (mJ) after attenuation. (pv name GDET:FEE1:362:ENRC) */
  double f_22_ENRC() const { return _f_22_ENRC; }
  /** First energy measurement (mJ) for small signals (<0.5 mJ), after attenuation. (pv name GDET:FEE1:363:ENRC) */
  double f_63_ENRC() const { return _f_63_ENRC; }
  /** Second (duplicate!) energy measurement (mJ) for small signals (<0.5mJ), after attenutation. (pv name GDET:FEE1:364:ENRC) */
  double f_64_ENRC() const { return _f_64_ENRC; }
  static uint32_t _sizeof() { return 48; }
private:
  double	_f_11_ENRC;	/**< First energy measurement (mJ) before attenuation. (pv name GDET:FEE1:241:ENRC) */
  double	_f_12_ENRC;	/**< Second (duplicate!) energy measurement (mJ) after attenuation. (pv name GDET:FEE1:242:ENRC) */
  double	_f_21_ENRC;	/**< First energy measurement (mJ) after attenuation. (pv name  GDET:FEE1:361:ENRC) */
  double	_f_22_ENRC;	/**< Second (duplicate!) energy measurement (mJ) after attenuation. (pv name GDET:FEE1:362:ENRC) */
  double	_f_63_ENRC;	/**< First energy measurement (mJ) for small signals (<0.5 mJ), after attenuation. (pv name GDET:FEE1:363:ENRC) */
  double	_f_64_ENRC;	/**< Second (duplicate!) energy measurement (mJ) for small signals (<0.5mJ), after attenutation. (pv name GDET:FEE1:364:ENRC) */
};

/** @class BldDataEBeamV0

  Beam parameters.
*/


class BldDataEBeamV0 {
public:
  enum { TypeId = Pds::TypeId::Id_EBeam /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 0 /**< XTC type version number */ };

  /** Constants defining bit mask for individual damage bits in value returned from damageMask() */
  enum DamageMask {
    EbeamChargeDamage = 0x001,
    EbeamL3EnergyDamage = 0x002,
    EbeamLTUPosXDamage = 0x004,
    EbeamLTUPosYDamage = 0x008,
    EbeamLTUAngXDamage = 0x010,
    EbeamLTUAngYDamage = 0x020,
  };
  BldDataEBeamV0(uint32_t arg__uDamageMask, double arg__fEbeamCharge, double arg__fEbeamL3Energy, double arg__fEbeamLTUPosX, double arg__fEbeamLTUPosY, double arg__fEbeamLTUAngX, double arg__fEbeamLTUAngY)
    : _uDamageMask(arg__uDamageMask), _fEbeamCharge(arg__fEbeamCharge), _fEbeamL3Energy(arg__fEbeamL3Energy), _fEbeamLTUPosX(arg__fEbeamLTUPosX), _fEbeamLTUPosY(arg__fEbeamLTUPosY), _fEbeamLTUAngX(arg__fEbeamLTUAngX), _fEbeamLTUAngY(arg__fEbeamLTUAngY)
  {
  }
  BldDataEBeamV0() {}
  /** Damage mask. */
  uint32_t damageMask() const { return _uDamageMask; }
  /** Beam charge in nC. */
  double ebeamCharge() const { return _fEbeamCharge; }
  /** Beam energy in MeV. */
  double ebeamL3Energy() const { return _fEbeamL3Energy; }
  /** LTU beam position in mm. */
  double ebeamLTUPosX() const { return _fEbeamLTUPosX; }
  /** LTU beam position in mm. */
  double ebeamLTUPosY() const { return _fEbeamLTUPosY; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngX() const { return _fEbeamLTUAngX; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngY() const { return _fEbeamLTUAngY; }
  static uint32_t _sizeof() { return 52; }
private:
  uint32_t	_uDamageMask;	/**< Damage mask. */
  double	_fEbeamCharge;	/**< Beam charge in nC. */
  double	_fEbeamL3Energy;	/**< Beam energy in MeV. */
  double	_fEbeamLTUPosX;	/**< LTU beam position in mm. */
  double	_fEbeamLTUPosY;	/**< LTU beam position in mm. */
  double	_fEbeamLTUAngX;	/**< LTU beam angle in mrad. */
  double	_fEbeamLTUAngY;	/**< LTU beam angle in mrad. */
};
std::ostream& operator<<(std::ostream& str, Bld::BldDataEBeamV0::DamageMask enval);

/** @class BldDataEBeamV1

  
*/


class BldDataEBeamV1 {
public:
  enum { TypeId = Pds::TypeId::Id_EBeam /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };

  /** Constants defining bit mask for individual damage bits in value returned from damageMask() */
  enum DamageMask {
    EbeamChargeDamage = 0x001,
    EbeamL3EnergyDamage = 0x002,
    EbeamLTUPosXDamage = 0x004,
    EbeamLTUPosYDamage = 0x008,
    EbeamLTUAngXDamage = 0x010,
    EbeamLTUAngYDamage = 0x020,
    EbeamPkCurrBC2Damage = 0x040,
  };
  BldDataEBeamV1(uint32_t arg__uDamageMask, double arg__fEbeamCharge, double arg__fEbeamL3Energy, double arg__fEbeamLTUPosX, double arg__fEbeamLTUPosY, double arg__fEbeamLTUAngX, double arg__fEbeamLTUAngY, double arg__fEbeamPkCurrBC2)
    : _uDamageMask(arg__uDamageMask), _fEbeamCharge(arg__fEbeamCharge), _fEbeamL3Energy(arg__fEbeamL3Energy), _fEbeamLTUPosX(arg__fEbeamLTUPosX), _fEbeamLTUPosY(arg__fEbeamLTUPosY), _fEbeamLTUAngX(arg__fEbeamLTUAngX), _fEbeamLTUAngY(arg__fEbeamLTUAngY), _fEbeamPkCurrBC2(arg__fEbeamPkCurrBC2)
  {
  }
  BldDataEBeamV1() {}
  /** Damage mask. */
  uint32_t damageMask() const { return _uDamageMask; }
  /** Beam charge in nC. */
  double ebeamCharge() const { return _fEbeamCharge; }
  /** Beam energy in MeV. */
  double ebeamL3Energy() const { return _fEbeamL3Energy; }
  /** LTU beam position in mm. */
  double ebeamLTUPosX() const { return _fEbeamLTUPosX; }
  /** LTU beam position in mm. */
  double ebeamLTUPosY() const { return _fEbeamLTUPosY; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngX() const { return _fEbeamLTUAngX; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngY() const { return _fEbeamLTUAngY; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC2() const { return _fEbeamPkCurrBC2; }
  static uint32_t _sizeof() { return 60; }
private:
  uint32_t	_uDamageMask;	/**< Damage mask. */
  double	_fEbeamCharge;	/**< Beam charge in nC. */
  double	_fEbeamL3Energy;	/**< Beam energy in MeV. */
  double	_fEbeamLTUPosX;	/**< LTU beam position in mm. */
  double	_fEbeamLTUPosY;	/**< LTU beam position in mm. */
  double	_fEbeamLTUAngX;	/**< LTU beam angle in mrad. */
  double	_fEbeamLTUAngY;	/**< LTU beam angle in mrad. */
  double	_fEbeamPkCurrBC2;	/**< Beam current in Amps. */
};
std::ostream& operator<<(std::ostream& str, Bld::BldDataEBeamV1::DamageMask enval);

/** @class BldDataEBeamV2

  
*/


class BldDataEBeamV2 {
public:
  enum { TypeId = Pds::TypeId::Id_EBeam /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };

  /** Constants defining bit mask for individual damage bits in value returned from damageMask() */
  enum DamageMask {
    EbeamChargeDamage = 0x001,
    EbeamL3EnergyDamage = 0x002,
    EbeamLTUPosXDamage = 0x004,
    EbeamLTUPosYDamage = 0x008,
    EbeamLTUAngXDamage = 0x010,
    EbeamLTUAngYDamage = 0x020,
    EbeamPkCurrBC2Damage = 0x040,
    EbeamEnergyBC2Damage = 0x080,
  };
  BldDataEBeamV2(uint32_t arg__uDamageMask, double arg__fEbeamCharge, double arg__fEbeamL3Energy, double arg__fEbeamLTUPosX, double arg__fEbeamLTUPosY, double arg__fEbeamLTUAngX, double arg__fEbeamLTUAngY, double arg__fEbeamPkCurrBC2, double arg__fEbeamEnergyBC2)
    : _uDamageMask(arg__uDamageMask), _fEbeamCharge(arg__fEbeamCharge), _fEbeamL3Energy(arg__fEbeamL3Energy), _fEbeamLTUPosX(arg__fEbeamLTUPosX), _fEbeamLTUPosY(arg__fEbeamLTUPosY), _fEbeamLTUAngX(arg__fEbeamLTUAngX), _fEbeamLTUAngY(arg__fEbeamLTUAngY), _fEbeamPkCurrBC2(arg__fEbeamPkCurrBC2), _fEbeamEnergyBC2(arg__fEbeamEnergyBC2)
  {
  }
  BldDataEBeamV2() {}
  /** Damage mask. */
  uint32_t damageMask() const { return _uDamageMask; }
  /** Beam charge in nC. */
  double ebeamCharge() const { return _fEbeamCharge; }
  /** Beam energy in MeV. */
  double ebeamL3Energy() const { return _fEbeamL3Energy; }
  /** LTU beam position in mm. */
  double ebeamLTUPosX() const { return _fEbeamLTUPosX; }
  /** LTU beam position in mm. */
  double ebeamLTUPosY() const { return _fEbeamLTUPosY; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngX() const { return _fEbeamLTUAngX; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngY() const { return _fEbeamLTUAngY; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC2() const { return _fEbeamPkCurrBC2; }
  /** Beam energy in MeV. */
  double ebeamEnergyBC2() const { return _fEbeamEnergyBC2; }
  static uint32_t _sizeof() { return 68; }
private:
  uint32_t	_uDamageMask;	/**< Damage mask. */
  double	_fEbeamCharge;	/**< Beam charge in nC. */
  double	_fEbeamL3Energy;	/**< Beam energy in MeV. */
  double	_fEbeamLTUPosX;	/**< LTU beam position in mm. */
  double	_fEbeamLTUPosY;	/**< LTU beam position in mm. */
  double	_fEbeamLTUAngX;	/**< LTU beam angle in mrad. */
  double	_fEbeamLTUAngY;	/**< LTU beam angle in mrad. */
  double	_fEbeamPkCurrBC2;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC2;	/**< Beam energy in MeV. */
};
std::ostream& operator<<(std::ostream& str, Bld::BldDataEBeamV2::DamageMask enval);

/** @class BldDataEBeamV3

  
*/


class BldDataEBeamV3 {
public:
  enum { TypeId = Pds::TypeId::Id_EBeam /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 3 /**< XTC type version number */ };

  /** Constants defining bit mask for individual damage bits in value returned from damageMask() */
  enum DamageMask {
    EbeamChargeDamage = 0x001,
    EbeamL3EnergyDamage = 0x002,
    EbeamLTUPosXDamage = 0x004,
    EbeamLTUPosYDamage = 0x008,
    EbeamLTUAngXDamage = 0x010,
    EbeamLTUAngYDamage = 0x020,
    EbeamPkCurrBC2Damage = 0x040,
    EbeamEnergyBC2Damage = 0x080,
    EbeamPkCurrBC1Damage = 0x100,
    EbeamEnergyBC1Damage = 0x200,
  };
  BldDataEBeamV3(uint32_t arg__uDamageMask, double arg__fEbeamCharge, double arg__fEbeamL3Energy, double arg__fEbeamLTUPosX, double arg__fEbeamLTUPosY, double arg__fEbeamLTUAngX, double arg__fEbeamLTUAngY, double arg__fEbeamPkCurrBC2, double arg__fEbeamEnergyBC2, double arg__fEbeamPkCurrBC1, double arg__fEbeamEnergyBC1)
    : _uDamageMask(arg__uDamageMask), _fEbeamCharge(arg__fEbeamCharge), _fEbeamL3Energy(arg__fEbeamL3Energy), _fEbeamLTUPosX(arg__fEbeamLTUPosX), _fEbeamLTUPosY(arg__fEbeamLTUPosY), _fEbeamLTUAngX(arg__fEbeamLTUAngX), _fEbeamLTUAngY(arg__fEbeamLTUAngY), _fEbeamPkCurrBC2(arg__fEbeamPkCurrBC2), _fEbeamEnergyBC2(arg__fEbeamEnergyBC2), _fEbeamPkCurrBC1(arg__fEbeamPkCurrBC1), _fEbeamEnergyBC1(arg__fEbeamEnergyBC1)
  {
  }
  BldDataEBeamV3() {}
  /** Damage mask. */
  uint32_t damageMask() const { return _uDamageMask; }
  /** Beam charge in nC. */
  double ebeamCharge() const { return _fEbeamCharge; }
  /** Beam energy in MeV. */
  double ebeamL3Energy() const { return _fEbeamL3Energy; }
  /** LTU beam position in mm. */
  double ebeamLTUPosX() const { return _fEbeamLTUPosX; }
  /** LTU beam position in mm. */
  double ebeamLTUPosY() const { return _fEbeamLTUPosY; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngX() const { return _fEbeamLTUAngX; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngY() const { return _fEbeamLTUAngY; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC2() const { return _fEbeamPkCurrBC2; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC2() const { return _fEbeamEnergyBC2; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC1() const { return _fEbeamPkCurrBC1; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC1() const { return _fEbeamEnergyBC1; }
  static uint32_t _sizeof() { return 84; }
private:
  uint32_t	_uDamageMask;	/**< Damage mask. */
  double	_fEbeamCharge;	/**< Beam charge in nC. */
  double	_fEbeamL3Energy;	/**< Beam energy in MeV. */
  double	_fEbeamLTUPosX;	/**< LTU beam position in mm. */
  double	_fEbeamLTUPosY;	/**< LTU beam position in mm. */
  double	_fEbeamLTUAngX;	/**< LTU beam angle in mrad. */
  double	_fEbeamLTUAngY;	/**< LTU beam angle in mrad. */
  double	_fEbeamPkCurrBC2;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC2;	/**< Beam position in mm (related to beam energy). */
  double	_fEbeamPkCurrBC1;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC1;	/**< Beam position in mm (related to beam energy). */
};
std::ostream& operator<<(std::ostream& str, Bld::BldDataEBeamV3::DamageMask enval);

/** @class BldDataEBeamV4

  
*/


class BldDataEBeamV4 {
public:
  enum { TypeId = Pds::TypeId::Id_EBeam /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 4 /**< XTC type version number */ };

  /** Constants defining bit mask for individual damage bits in value returned from damageMask() */
  enum DamageMask {
    EbeamChargeDamage = 0x001,
    EbeamL3EnergyDamage = 0x002,
    EbeamLTUPosXDamage = 0x004,
    EbeamLTUPosYDamage = 0x008,
    EbeamLTUAngXDamage = 0x010,
    EbeamLTUAngYDamage = 0x020,
    EbeamPkCurrBC2Damage = 0x040,
    EbeamEnergyBC2Damage = 0x080,
    EbeamPkCurrBC1Damage = 0x100,
    EbeamEnergyBC1Damage = 0x200,
    EbeamUndPosXDamage = 0x400,
    EbeamUndPosYDamage = 0x800,
    EbeamUndAngXDamage = 0x1000,
    EbeamUndAngYDamage = 0x2000,
  };
  BldDataEBeamV4(uint32_t arg__uDamageMask, double arg__fEbeamCharge, double arg__fEbeamL3Energy, double arg__fEbeamLTUPosX, double arg__fEbeamLTUPosY, double arg__fEbeamLTUAngX, double arg__fEbeamLTUAngY, double arg__fEbeamPkCurrBC2, double arg__fEbeamEnergyBC2, double arg__fEbeamPkCurrBC1, double arg__fEbeamEnergyBC1, double arg__fEbeamUndPosX, double arg__fEbeamUndPosY, double arg__fEbeamUndAngX, double arg__fEbeamUndAngY)
    : _uDamageMask(arg__uDamageMask), _fEbeamCharge(arg__fEbeamCharge), _fEbeamL3Energy(arg__fEbeamL3Energy), _fEbeamLTUPosX(arg__fEbeamLTUPosX), _fEbeamLTUPosY(arg__fEbeamLTUPosY), _fEbeamLTUAngX(arg__fEbeamLTUAngX), _fEbeamLTUAngY(arg__fEbeamLTUAngY), _fEbeamPkCurrBC2(arg__fEbeamPkCurrBC2), _fEbeamEnergyBC2(arg__fEbeamEnergyBC2), _fEbeamPkCurrBC1(arg__fEbeamPkCurrBC1), _fEbeamEnergyBC1(arg__fEbeamEnergyBC1), _fEbeamUndPosX(arg__fEbeamUndPosX), _fEbeamUndPosY(arg__fEbeamUndPosY), _fEbeamUndAngX(arg__fEbeamUndAngX), _fEbeamUndAngY(arg__fEbeamUndAngY)
  {
  }
  BldDataEBeamV4() {}
  /** Damage mask. */
  uint32_t damageMask() const { return _uDamageMask; }
  /** Beam charge in nC. */
  double ebeamCharge() const { return _fEbeamCharge; }
  /** Beam energy in MeV. */
  double ebeamL3Energy() const { return _fEbeamL3Energy; }
  /** LTU beam position (BPMS:LTU1:720 through 750) in mm. */
  double ebeamLTUPosX() const { return _fEbeamLTUPosX; }
  /** LTU beam position in mm. */
  double ebeamLTUPosY() const { return _fEbeamLTUPosY; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngX() const { return _fEbeamLTUAngX; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngY() const { return _fEbeamLTUAngY; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC2() const { return _fEbeamPkCurrBC2; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC2() const { return _fEbeamEnergyBC2; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC1() const { return _fEbeamPkCurrBC1; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC1() const { return _fEbeamEnergyBC1; }
  /** Undulator launch feedback (BPMs U4 through U10) beam x-position in mm. */
  double ebeamUndPosX() const { return _fEbeamUndPosX; }
  /** Undulator launch feedback beam y-position in mm. */
  double ebeamUndPosY() const { return _fEbeamUndPosY; }
  /** Undulator launch feedback beam x-angle in mrad. */
  double ebeamUndAngX() const { return _fEbeamUndAngX; }
  /** Undulator launch feedback beam y-angle in mrad. */
  double ebeamUndAngY() const { return _fEbeamUndAngY; }
  static uint32_t _sizeof() { return 116; }
private:
  uint32_t	_uDamageMask;	/**< Damage mask. */
  double	_fEbeamCharge;	/**< Beam charge in nC. */
  double	_fEbeamL3Energy;	/**< Beam energy in MeV. */
  double	_fEbeamLTUPosX;	/**< LTU beam position (BPMS:LTU1:720 through 750) in mm. */
  double	_fEbeamLTUPosY;	/**< LTU beam position in mm. */
  double	_fEbeamLTUAngX;	/**< LTU beam angle in mrad. */
  double	_fEbeamLTUAngY;	/**< LTU beam angle in mrad. */
  double	_fEbeamPkCurrBC2;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC2;	/**< Beam position in mm (related to beam energy). */
  double	_fEbeamPkCurrBC1;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC1;	/**< Beam position in mm (related to beam energy). */
  double	_fEbeamUndPosX;	/**< Undulator launch feedback (BPMs U4 through U10) beam x-position in mm. */
  double	_fEbeamUndPosY;	/**< Undulator launch feedback beam y-position in mm. */
  double	_fEbeamUndAngX;	/**< Undulator launch feedback beam x-angle in mrad. */
  double	_fEbeamUndAngY;	/**< Undulator launch feedback beam y-angle in mrad. */
};
std::ostream& operator<<(std::ostream& str, Bld::BldDataEBeamV4::DamageMask enval);

/** @class BldDataEBeamV5

  
*/


class BldDataEBeamV5 {
public:
  enum { TypeId = Pds::TypeId::Id_EBeam /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 5 /**< XTC type version number */ };

  /** Constants defining bit mask for individual damage bits in value returned from damageMask() */
  enum DamageMask {
    EbeamChargeDamage = 0x001,
    EbeamL3EnergyDamage = 0x002,
    EbeamLTUPosXDamage = 0x004,
    EbeamLTUPosYDamage = 0x008,
    EbeamLTUAngXDamage = 0x010,
    EbeamLTUAngYDamage = 0x020,
    EbeamPkCurrBC2Damage = 0x040,
    EbeamEnergyBC2Damage = 0x080,
    EbeamPkCurrBC1Damage = 0x100,
    EbeamEnergyBC1Damage = 0x200,
    EbeamUndPosXDamage = 0x400,
    EbeamUndPosYDamage = 0x800,
    EbeamUndAngXDamage = 0x1000,
    EbeamUndAngYDamage = 0x2000,
    EbeamXTCAVAmplDamage = 0x4000,
    EbeamXTCAVPhaseDamage = 0x8000,
    EbeamDumpChargeDamage = 0x10000,
  };
  BldDataEBeamV5(uint32_t arg__uDamageMask, double arg__fEbeamCharge, double arg__fEbeamL3Energy, double arg__fEbeamLTUPosX, double arg__fEbeamLTUPosY, double arg__fEbeamLTUAngX, double arg__fEbeamLTUAngY, double arg__fEbeamPkCurrBC2, double arg__fEbeamEnergyBC2, double arg__fEbeamPkCurrBC1, double arg__fEbeamEnergyBC1, double arg__fEbeamUndPosX, double arg__fEbeamUndPosY, double arg__fEbeamUndAngX, double arg__fEbeamUndAngY, double arg__fEbeamXTCAVAmpl, double arg__fEbeamXTCAVPhase, double arg__fEbeamDumpCharge)
    : _uDamageMask(arg__uDamageMask), _fEbeamCharge(arg__fEbeamCharge), _fEbeamL3Energy(arg__fEbeamL3Energy), _fEbeamLTUPosX(arg__fEbeamLTUPosX), _fEbeamLTUPosY(arg__fEbeamLTUPosY), _fEbeamLTUAngX(arg__fEbeamLTUAngX), _fEbeamLTUAngY(arg__fEbeamLTUAngY), _fEbeamPkCurrBC2(arg__fEbeamPkCurrBC2), _fEbeamEnergyBC2(arg__fEbeamEnergyBC2), _fEbeamPkCurrBC1(arg__fEbeamPkCurrBC1), _fEbeamEnergyBC1(arg__fEbeamEnergyBC1), _fEbeamUndPosX(arg__fEbeamUndPosX), _fEbeamUndPosY(arg__fEbeamUndPosY), _fEbeamUndAngX(arg__fEbeamUndAngX), _fEbeamUndAngY(arg__fEbeamUndAngY), _fEbeamXTCAVAmpl(arg__fEbeamXTCAVAmpl), _fEbeamXTCAVPhase(arg__fEbeamXTCAVPhase), _fEbeamDumpCharge(arg__fEbeamDumpCharge)
  {
  }
  BldDataEBeamV5() {}
  /** Damage mask. */
  uint32_t damageMask() const { return _uDamageMask; }
  /** Beam charge in nC. */
  double ebeamCharge() const { return _fEbeamCharge; }
  /** Beam energy in MeV. */
  double ebeamL3Energy() const { return _fEbeamL3Energy; }
  /** LTU beam position (BPMS:LTU1:720 through 750) in mm. */
  double ebeamLTUPosX() const { return _fEbeamLTUPosX; }
  /** LTU beam position in mm. */
  double ebeamLTUPosY() const { return _fEbeamLTUPosY; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngX() const { return _fEbeamLTUAngX; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngY() const { return _fEbeamLTUAngY; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC2() const { return _fEbeamPkCurrBC2; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC2() const { return _fEbeamEnergyBC2; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC1() const { return _fEbeamPkCurrBC1; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC1() const { return _fEbeamEnergyBC1; }
  /** Undulator launch feedback (BPMs U4 through U10) beam x-position in mm. */
  double ebeamUndPosX() const { return _fEbeamUndPosX; }
  /** Undulator launch feedback beam y-position in mm. */
  double ebeamUndPosY() const { return _fEbeamUndPosY; }
  /** Undulator launch feedback beam x-angle in mrad. */
  double ebeamUndAngX() const { return _fEbeamUndAngX; }
  /** Undulator launch feedback beam y-angle in mrad. */
  double ebeamUndAngY() const { return _fEbeamUndAngY; }
  /** XTCAV Amplitude in MVolt. */
  double ebeamXTCAVAmpl() const { return _fEbeamXTCAVAmpl; }
  /** XTCAV Phase in degrees. */
  double ebeamXTCAVPhase() const { return _fEbeamXTCAVPhase; }
  /** Bunch charge at Dump in num. electrons */
  double ebeamDumpCharge() const { return _fEbeamDumpCharge; }
  static uint32_t _sizeof() { return 140; }
private:
  uint32_t	_uDamageMask;	/**< Damage mask. */
  double	_fEbeamCharge;	/**< Beam charge in nC. */
  double	_fEbeamL3Energy;	/**< Beam energy in MeV. */
  double	_fEbeamLTUPosX;	/**< LTU beam position (BPMS:LTU1:720 through 750) in mm. */
  double	_fEbeamLTUPosY;	/**< LTU beam position in mm. */
  double	_fEbeamLTUAngX;	/**< LTU beam angle in mrad. */
  double	_fEbeamLTUAngY;	/**< LTU beam angle in mrad. */
  double	_fEbeamPkCurrBC2;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC2;	/**< Beam position in mm (related to beam energy). */
  double	_fEbeamPkCurrBC1;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC1;	/**< Beam position in mm (related to beam energy). */
  double	_fEbeamUndPosX;	/**< Undulator launch feedback (BPMs U4 through U10) beam x-position in mm. */
  double	_fEbeamUndPosY;	/**< Undulator launch feedback beam y-position in mm. */
  double	_fEbeamUndAngX;	/**< Undulator launch feedback beam x-angle in mrad. */
  double	_fEbeamUndAngY;	/**< Undulator launch feedback beam y-angle in mrad. */
  double	_fEbeamXTCAVAmpl;	/**< XTCAV Amplitude in MVolt. */
  double	_fEbeamXTCAVPhase;	/**< XTCAV Phase in degrees. */
  double	_fEbeamDumpCharge;	/**< Bunch charge at Dump in num. electrons */
};
std::ostream& operator<<(std::ostream& str, Bld::BldDataEBeamV5::DamageMask enval);

/** @class BldDataEBeamV6

  
*/


class BldDataEBeamV6 {
public:
  enum { TypeId = Pds::TypeId::Id_EBeam /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 6 /**< XTC type version number */ };

  /** Constants defining bit mask for individual damage bits in value returned from damageMask() */
  enum DamageMask {
    EbeamChargeDamage = 0x001,
    EbeamL3EnergyDamage = 0x002,
    EbeamLTUPosXDamage = 0x004,
    EbeamLTUPosYDamage = 0x008,
    EbeamLTUAngXDamage = 0x010,
    EbeamLTUAngYDamage = 0x020,
    EbeamPkCurrBC2Damage = 0x040,
    EbeamEnergyBC2Damage = 0x080,
    EbeamPkCurrBC1Damage = 0x100,
    EbeamEnergyBC1Damage = 0x200,
    EbeamUndPosXDamage = 0x400,
    EbeamUndPosYDamage = 0x800,
    EbeamUndAngXDamage = 0x1000,
    EbeamUndAngYDamage = 0x2000,
    EbeamXTCAVAmplDamage = 0x4000,
    EbeamXTCAVPhaseDamage = 0x8000,
    EbeamDumpChargeDamage = 0x10000,
    EbeamPhotonEnergyDamage = 0x20000,
  };
  BldDataEBeamV6(uint32_t arg__uDamageMask, double arg__fEbeamCharge, double arg__fEbeamL3Energy, double arg__fEbeamLTUPosX, double arg__fEbeamLTUPosY, double arg__fEbeamLTUAngX, double arg__fEbeamLTUAngY, double arg__fEbeamPkCurrBC2, double arg__fEbeamEnergyBC2, double arg__fEbeamPkCurrBC1, double arg__fEbeamEnergyBC1, double arg__fEbeamUndPosX, double arg__fEbeamUndPosY, double arg__fEbeamUndAngX, double arg__fEbeamUndAngY, double arg__fEbeamXTCAVAmpl, double arg__fEbeamXTCAVPhase, double arg__fEbeamDumpCharge, double arg__fEbeamPhotonEnergy, double arg__fEbeamLTU250, double arg__fEbeamLTU450)
    : _uDamageMask(arg__uDamageMask), _fEbeamCharge(arg__fEbeamCharge), _fEbeamL3Energy(arg__fEbeamL3Energy), _fEbeamLTUPosX(arg__fEbeamLTUPosX), _fEbeamLTUPosY(arg__fEbeamLTUPosY), _fEbeamLTUAngX(arg__fEbeamLTUAngX), _fEbeamLTUAngY(arg__fEbeamLTUAngY), _fEbeamPkCurrBC2(arg__fEbeamPkCurrBC2), _fEbeamEnergyBC2(arg__fEbeamEnergyBC2), _fEbeamPkCurrBC1(arg__fEbeamPkCurrBC1), _fEbeamEnergyBC1(arg__fEbeamEnergyBC1), _fEbeamUndPosX(arg__fEbeamUndPosX), _fEbeamUndPosY(arg__fEbeamUndPosY), _fEbeamUndAngX(arg__fEbeamUndAngX), _fEbeamUndAngY(arg__fEbeamUndAngY), _fEbeamXTCAVAmpl(arg__fEbeamXTCAVAmpl), _fEbeamXTCAVPhase(arg__fEbeamXTCAVPhase), _fEbeamDumpCharge(arg__fEbeamDumpCharge), _fEbeamPhotonEnergy(arg__fEbeamPhotonEnergy), _fEbeamLTU250(arg__fEbeamLTU250), _fEbeamLTU450(arg__fEbeamLTU450)
  {
  }
  BldDataEBeamV6() {}
  /** Damage mask. */
  uint32_t damageMask() const { return _uDamageMask; }
  /** Beam charge in nC. */
  double ebeamCharge() const { return _fEbeamCharge; }
  /** Beam energy in MeV. */
  double ebeamL3Energy() const { return _fEbeamL3Energy; }
  /** LTU beam position (BPMS:LTU1:720 through 750) in mm. */
  double ebeamLTUPosX() const { return _fEbeamLTUPosX; }
  /** LTU beam position in mm. */
  double ebeamLTUPosY() const { return _fEbeamLTUPosY; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngX() const { return _fEbeamLTUAngX; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngY() const { return _fEbeamLTUAngY; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC2() const { return _fEbeamPkCurrBC2; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC2() const { return _fEbeamEnergyBC2; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC1() const { return _fEbeamPkCurrBC1; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC1() const { return _fEbeamEnergyBC1; }
  /** Undulator launch feedback (BPMs U4 through U10) beam x-position in mm. */
  double ebeamUndPosX() const { return _fEbeamUndPosX; }
  /** Undulator launch feedback beam y-position in mm. */
  double ebeamUndPosY() const { return _fEbeamUndPosY; }
  /** Undulator launch feedback beam x-angle in mrad. */
  double ebeamUndAngX() const { return _fEbeamUndAngX; }
  /** Undulator launch feedback beam y-angle in mrad. */
  double ebeamUndAngY() const { return _fEbeamUndAngY; }
  /** XTCAV Amplitude in MVolt. */
  double ebeamXTCAVAmpl() const { return _fEbeamXTCAVAmpl; }
  /** XTCAV Phase in degrees. */
  double ebeamXTCAVPhase() const { return _fEbeamXTCAVPhase; }
  /** Bunch charge at Dump in num. electrons */
  double ebeamDumpCharge() const { return _fEbeamDumpCharge; }
  /** computed photon energy, in eV */
  double ebeamPhotonEnergy() const { return _fEbeamPhotonEnergy; }
  /** LTU250 BPM value in mm, used to compute photon energy. from BPMS:LTU1:250:X */
  double ebeamLTU250() const { return _fEbeamLTU250; }
  /** LTU450 BPM value in mm, used to compute photon energy. from BPMS:LTU1:450:X */
  double ebeamLTU450() const { return _fEbeamLTU450; }
  static uint32_t _sizeof() { return 164; }
private:
  uint32_t	_uDamageMask;	/**< Damage mask. */
  double	_fEbeamCharge;	/**< Beam charge in nC. */
  double	_fEbeamL3Energy;	/**< Beam energy in MeV. */
  double	_fEbeamLTUPosX;	/**< LTU beam position (BPMS:LTU1:720 through 750) in mm. */
  double	_fEbeamLTUPosY;	/**< LTU beam position in mm. */
  double	_fEbeamLTUAngX;	/**< LTU beam angle in mrad. */
  double	_fEbeamLTUAngY;	/**< LTU beam angle in mrad. */
  double	_fEbeamPkCurrBC2;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC2;	/**< Beam position in mm (related to beam energy). */
  double	_fEbeamPkCurrBC1;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC1;	/**< Beam position in mm (related to beam energy). */
  double	_fEbeamUndPosX;	/**< Undulator launch feedback (BPMs U4 through U10) beam x-position in mm. */
  double	_fEbeamUndPosY;	/**< Undulator launch feedback beam y-position in mm. */
  double	_fEbeamUndAngX;	/**< Undulator launch feedback beam x-angle in mrad. */
  double	_fEbeamUndAngY;	/**< Undulator launch feedback beam y-angle in mrad. */
  double	_fEbeamXTCAVAmpl;	/**< XTCAV Amplitude in MVolt. */
  double	_fEbeamXTCAVPhase;	/**< XTCAV Phase in degrees. */
  double	_fEbeamDumpCharge;	/**< Bunch charge at Dump in num. electrons */
  double	_fEbeamPhotonEnergy;	/**< computed photon energy, in eV */
  double	_fEbeamLTU250;	/**< LTU250 BPM value in mm, used to compute photon energy. from BPMS:LTU1:250:X */
  double	_fEbeamLTU450;	/**< LTU450 BPM value in mm, used to compute photon energy. from BPMS:LTU1:450:X */
};
std::ostream& operator<<(std::ostream& str, Bld::BldDataEBeamV6::DamageMask enval);

/** @class BldDataEBeamV7

  BldDataEBeamV7 is the same as BldDataEBeamV6.
A sign-error error was discovered in the calculation of the photon energy that goes into the ebeam bld.
This is fixed on the accelerator side, but we will increment the ebeam bld version number to V7 so the
data is clearly marked as changed.
*/


class BldDataEBeamV7 {
public:
  enum { TypeId = Pds::TypeId::Id_EBeam /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 7 /**< XTC type version number */ };

  /** Constants defining bit mask for individual damage bits in value returned from damageMask() */
  enum DamageMask {
    EbeamChargeDamage = 0x001,
    EbeamL3EnergyDamage = 0x002,
    EbeamLTUPosXDamage = 0x004,
    EbeamLTUPosYDamage = 0x008,
    EbeamLTUAngXDamage = 0x010,
    EbeamLTUAngYDamage = 0x020,
    EbeamPkCurrBC2Damage = 0x040,
    EbeamEnergyBC2Damage = 0x080,
    EbeamPkCurrBC1Damage = 0x100,
    EbeamEnergyBC1Damage = 0x200,
    EbeamUndPosXDamage = 0x400,
    EbeamUndPosYDamage = 0x800,
    EbeamUndAngXDamage = 0x1000,
    EbeamUndAngYDamage = 0x2000,
    EbeamXTCAVAmplDamage = 0x4000,
    EbeamXTCAVPhaseDamage = 0x8000,
    EbeamDumpChargeDamage = 0x10000,
    EbeamPhotonEnergyDamage = 0x20000,
  };
  BldDataEBeamV7(uint32_t arg__uDamageMask, double arg__fEbeamCharge, double arg__fEbeamL3Energy, double arg__fEbeamLTUPosX, double arg__fEbeamLTUPosY, double arg__fEbeamLTUAngX, double arg__fEbeamLTUAngY, double arg__fEbeamPkCurrBC2, double arg__fEbeamEnergyBC2, double arg__fEbeamPkCurrBC1, double arg__fEbeamEnergyBC1, double arg__fEbeamUndPosX, double arg__fEbeamUndPosY, double arg__fEbeamUndAngX, double arg__fEbeamUndAngY, double arg__fEbeamXTCAVAmpl, double arg__fEbeamXTCAVPhase, double arg__fEbeamDumpCharge, double arg__fEbeamPhotonEnergy, double arg__fEbeamLTU250, double arg__fEbeamLTU450)
    : _uDamageMask(arg__uDamageMask), _fEbeamCharge(arg__fEbeamCharge), _fEbeamL3Energy(arg__fEbeamL3Energy), _fEbeamLTUPosX(arg__fEbeamLTUPosX), _fEbeamLTUPosY(arg__fEbeamLTUPosY), _fEbeamLTUAngX(arg__fEbeamLTUAngX), _fEbeamLTUAngY(arg__fEbeamLTUAngY), _fEbeamPkCurrBC2(arg__fEbeamPkCurrBC2), _fEbeamEnergyBC2(arg__fEbeamEnergyBC2), _fEbeamPkCurrBC1(arg__fEbeamPkCurrBC1), _fEbeamEnergyBC1(arg__fEbeamEnergyBC1), _fEbeamUndPosX(arg__fEbeamUndPosX), _fEbeamUndPosY(arg__fEbeamUndPosY), _fEbeamUndAngX(arg__fEbeamUndAngX), _fEbeamUndAngY(arg__fEbeamUndAngY), _fEbeamXTCAVAmpl(arg__fEbeamXTCAVAmpl), _fEbeamXTCAVPhase(arg__fEbeamXTCAVPhase), _fEbeamDumpCharge(arg__fEbeamDumpCharge), _fEbeamPhotonEnergy(arg__fEbeamPhotonEnergy), _fEbeamLTU250(arg__fEbeamLTU250), _fEbeamLTU450(arg__fEbeamLTU450)
  {
  }
  BldDataEBeamV7() {}
  /** Damage mask. */
  uint32_t damageMask() const { return _uDamageMask; }
  /** Beam charge in nC. */
  double ebeamCharge() const { return _fEbeamCharge; }
  /** Beam energy in MeV. */
  double ebeamL3Energy() const { return _fEbeamL3Energy; }
  /** LTU beam position (BPMS:LTU1:720 through 750) in mm. */
  double ebeamLTUPosX() const { return _fEbeamLTUPosX; }
  /** LTU beam position in mm. */
  double ebeamLTUPosY() const { return _fEbeamLTUPosY; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngX() const { return _fEbeamLTUAngX; }
  /** LTU beam angle in mrad. */
  double ebeamLTUAngY() const { return _fEbeamLTUAngY; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC2() const { return _fEbeamPkCurrBC2; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC2() const { return _fEbeamEnergyBC2; }
  /** Beam current in Amps. */
  double ebeamPkCurrBC1() const { return _fEbeamPkCurrBC1; }
  /** Beam position in mm (related to beam energy). */
  double ebeamEnergyBC1() const { return _fEbeamEnergyBC1; }
  /** Undulator launch feedback (BPMs U4 through U10) beam x-position in mm. */
  double ebeamUndPosX() const { return _fEbeamUndPosX; }
  /** Undulator launch feedback beam y-position in mm. */
  double ebeamUndPosY() const { return _fEbeamUndPosY; }
  /** Undulator launch feedback beam x-angle in mrad. */
  double ebeamUndAngX() const { return _fEbeamUndAngX; }
  /** Undulator launch feedback beam y-angle in mrad. */
  double ebeamUndAngY() const { return _fEbeamUndAngY; }
  /** XTCAV Amplitude in MVolt. */
  double ebeamXTCAVAmpl() const { return _fEbeamXTCAVAmpl; }
  /** XTCAV Phase in degrees. */
  double ebeamXTCAVPhase() const { return _fEbeamXTCAVPhase; }
  /** Bunch charge at Dump in num. electrons */
  double ebeamDumpCharge() const { return _fEbeamDumpCharge; }
  /** computed photon energy, in eV */
  double ebeamPhotonEnergy() const { return _fEbeamPhotonEnergy; }
  /** LTU250 BPM value in mm, used to compute photon energy. from BPMS:LTU1:250:X */
  double ebeamLTU250() const { return _fEbeamLTU250; }
  /** LTU450 BPM value in mm, used to compute photon energy. from BPMS:LTU1:450:X */
  double ebeamLTU450() const { return _fEbeamLTU450; }
  static uint32_t _sizeof() { return 164; }
private:
  uint32_t	_uDamageMask;	/**< Damage mask. */
  double	_fEbeamCharge;	/**< Beam charge in nC. */
  double	_fEbeamL3Energy;	/**< Beam energy in MeV. */
  double	_fEbeamLTUPosX;	/**< LTU beam position (BPMS:LTU1:720 through 750) in mm. */
  double	_fEbeamLTUPosY;	/**< LTU beam position in mm. */
  double	_fEbeamLTUAngX;	/**< LTU beam angle in mrad. */
  double	_fEbeamLTUAngY;	/**< LTU beam angle in mrad. */
  double	_fEbeamPkCurrBC2;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC2;	/**< Beam position in mm (related to beam energy). */
  double	_fEbeamPkCurrBC1;	/**< Beam current in Amps. */
  double	_fEbeamEnergyBC1;	/**< Beam position in mm (related to beam energy). */
  double	_fEbeamUndPosX;	/**< Undulator launch feedback (BPMs U4 through U10) beam x-position in mm. */
  double	_fEbeamUndPosY;	/**< Undulator launch feedback beam y-position in mm. */
  double	_fEbeamUndAngX;	/**< Undulator launch feedback beam x-angle in mrad. */
  double	_fEbeamUndAngY;	/**< Undulator launch feedback beam y-angle in mrad. */
  double	_fEbeamXTCAVAmpl;	/**< XTCAV Amplitude in MVolt. */
  double	_fEbeamXTCAVPhase;	/**< XTCAV Phase in degrees. */
  double	_fEbeamDumpCharge;	/**< Bunch charge at Dump in num. electrons */
  double	_fEbeamPhotonEnergy;	/**< computed photon energy, in eV */
  double	_fEbeamLTU250;	/**< LTU250 BPM value in mm, used to compute photon energy. from BPMS:LTU1:250:X */
  double	_fEbeamLTU450;	/**< LTU450 BPM value in mm, used to compute photon energy. from BPMS:LTU1:450:X */
};
std::ostream& operator<<(std::ostream& str, Bld::BldDataEBeamV7::DamageMask enval);

/** @class BldDataPhaseCavity

  PV names: UND:R02:IOC:16:BAT:FitTime1, UND:R02:IOC:16:BAT:FitTime2,
                UND:R02:IOC:16:BAT:Charge1,  UND:R02:IOC:16:BAT:Charge2
*/


class BldDataPhaseCavity {
public:
  enum { TypeId = Pds::TypeId::Id_PhaseCavity /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 0 /**< XTC type version number */ };
  BldDataPhaseCavity(double arg__fFitTime1, double arg__fFitTime2, double arg__fCharge1, double arg__fCharge2)
    : _fFitTime1(arg__fFitTime1), _fFitTime2(arg__fFitTime2), _fCharge1(arg__fCharge1), _fCharge2(arg__fCharge2)
  {
  }
  BldDataPhaseCavity() {}
  /** UND:R02:IOC:16:BAT:FitTime1 value in pico-seconds. */
  double fitTime1() const { return _fFitTime1; }
  /** UND:R02:IOC:16:BAT:FitTime2 value in pico-seconds. */
  double fitTime2() const { return _fFitTime2; }
  /** UND:R02:IOC:16:BAT:Charge1 value in pico-columbs. */
  double charge1() const { return _fCharge1; }
  /** UND:R02:IOC:16:BAT:Charge2 value in pico-columbs. */
  double charge2() const { return _fCharge2; }
  static uint32_t _sizeof() { return 32; }
private:
  double	_fFitTime1;	/**< UND:R02:IOC:16:BAT:FitTime1 value in pico-seconds. */
  double	_fFitTime2;	/**< UND:R02:IOC:16:BAT:FitTime2 value in pico-seconds. */
  double	_fCharge1;	/**< UND:R02:IOC:16:BAT:Charge1 value in pico-columbs. */
  double	_fCharge2;	/**< UND:R02:IOC:16:BAT:Charge2 value in pico-columbs. */
};

/** @class BldDataIpimbV0

  Combined structure which includes Ipimb.DataV1, Ipimb.ConfigV1, and
            Lusi.IpmFexV1 objects.
*/


class BldDataIpimbV0 {
public:
  enum { TypeId = Pds::TypeId::Id_SharedIpimb /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 0 /**< XTC type version number */ };
  virtual ~BldDataIpimbV0();
  virtual const Ipimb::DataV1& ipimbData() const = 0;
  virtual const Ipimb::ConfigV1& ipimbConfig() const = 0;
  virtual const Lusi::IpmFexV1& ipmFexData() const = 0;
};

/** @class BldDataIpimbV1

  Combined structure which includes Ipimb.DataV2, Ipimb.ConfigV2, and
            Lusi.IpmFexV1 objects.
*/


class BldDataIpimbV1 {
public:
  enum { TypeId = Pds::TypeId::Id_SharedIpimb /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  virtual ~BldDataIpimbV1();
  virtual const Ipimb::DataV2& ipimbData() const = 0;
  virtual const Ipimb::ConfigV2& ipimbConfig() const = 0;
  virtual const Lusi::IpmFexV1& ipmFexData() const = 0;
};

/** @class BldDataPimV1

  Combined structure which includes Pulnix.TM6740ConfigV2, Lusi.PimImageConfigV1, and
            Camera.FrameV1 objects.
*/


class BldDataPimV1 {
public:
  enum { TypeId = Pds::TypeId::Id_SharedPim /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  virtual ~BldDataPimV1();
  virtual const Pulnix::TM6740ConfigV2& camConfig() const = 0;
  virtual const Lusi::PimImageConfigV1& pimConfig() const = 0;
  virtual const Camera::FrameV1& frame() const = 0;
};

/** @class BldDataGMDV0

  Gas Monitor Detector data.
*/


class BldDataGMDV0 {
public:
  enum { TypeId = Pds::TypeId::Id_GMD /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 0 /**< XTC type version number */ };
  virtual ~BldDataGMDV0();
  /** String describing gas type */
  virtual const char* gasType() const = 0;
  /** Pressure from Spinning Rotor Gauge */
  virtual double pressure() const = 0;
  /** Temp from PT100 */
  virtual double temperature() const = 0;
  /** Current from Keithley Electrometer */
  virtual double current() const = 0;
  /** HV Mesh Electron */
  virtual double hvMeshElectron() const = 0;
  /** HV Mesh Ion */
  virtual double hvMeshIon() const = 0;
  /** HV Mult Ion */
  virtual double hvMultIon() const = 0;
  /** Charge Q */
  virtual double chargeQ() const = 0;
  /** Photon Energy */
  virtual double photonEnergy() const = 0;
  /** Pulse Intensity derived from Electron Multiplier */
  virtual double multPulseIntensity() const = 0;
  /** Pulse Intensity derived from ION cup current */
  virtual double keithleyPulseIntensity() const = 0;
  /** Pulse Energy derived from Electron Multiplier */
  virtual double pulseEnergy() const = 0;
  /** Pulse Energy from FEE Gas Detector */
  virtual double pulseEnergyFEE() const = 0;
  /** Transmission derived from Electron Multiplier */
  virtual double transmission() const = 0;
  /** Transmission from FEE Gas Detector */
  virtual double transmissionFEE() const = 0;
};

/** @class BldDataGMDV1

  Gas Monitor Detector data.
*/


class BldDataGMDV1 {
public:
  enum { TypeId = Pds::TypeId::Id_GMD /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  virtual ~BldDataGMDV1();
  /** Shot to shot pulse energy (mJ) */
  virtual double milliJoulesPerPulse() const = 0;
  /** Average pulse energy from ION cup current (mJ) */
  virtual double milliJoulesAverage() const = 0;
  /** Bg corrected waveform integrated within limits in raw A/D counts */
  virtual double correctedSumPerPulse() const = 0;
  /** Avg background value per sample in raw A/D counts */
  virtual double bgValuePerSample() const = 0;
  /** Shot by shot pulse energy in arbitrary units */
  virtual double relativeEnergyPerPulse() const = 0;
};

/** @class BldDataGMDV2

  Gas Monitor Detector data.
*/


class BldDataGMDV2 {
public:
  enum { TypeId = Pds::TypeId::Id_GMD /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  virtual ~BldDataGMDV2();
  /** Shot to shot pulse energy (mJ).  Not as robust as relativeEnergyPerPulse() method. */
  virtual double milliJoulesPerPulse() const = 0;
  /** Average pulse energy from ION cup current (mJ).  Not as robust as relativeEnergyPerPulse() method. */
  virtual double milliJoulesAverage() const = 0;
  /** Sum of all peaks, normalized w/ filt bkgd level.  Not typically used by the user. */
  virtual double sumAllPeaksFiltBkgd() const = 0;
  /** Avg background value per waveform in raw A/D counts.  Not typically used by the user. */
  virtual double rawAvgBkgd() const = 0;
  /** Shot by shot pulse energy in arbitrary units.  The most stable measurement.  Most users should use this. */
  virtual double relativeEnergyPerPulse() const = 0;
  /** Sum of all peaks, normalized w/ raw avg bkgd level.  Not typically used by the user. */
  virtual double sumAllPeaksRawBkgd() const = 0;
};

/** @class BldDataAcqADCV1

  Combined structure which includes Acqiris.ConfigV1 and
            Acqiris.DataDescV1 objects.
*/


class BldDataAcqADCV1 {
public:
  enum { TypeId = Pds::TypeId::Id_SharedAcqADC /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  virtual ~BldDataAcqADCV1();
  virtual const Acqiris::ConfigV1& config() const = 0;
  virtual const Acqiris::DataDescV1& data() const = 0;
};

/** @class BldDataSpectrometerV0

  Structure which contains image projections for spectrometers.
*/


class BldDataSpectrometerV0 {
public:
  enum { TypeId = Pds::TypeId::Id_Spectrometer /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 0 /**< XTC type version number */ };
  virtual ~BldDataSpectrometerV0();
  virtual ndarray<const uint32_t, 1> hproj() const = 0;
  virtual ndarray<const uint32_t, 1> vproj() const = 0;
};

/** @class BldDataSpectrometerV1

  Structure which contains image projections and fit parameters for spectrometers. 
	Changes from V0 include extending size of hproj, removal of vproj,
	 and addition of fit parameters.
*/


class BldDataSpectrometerV1 {
public:
  enum { TypeId = Pds::TypeId::Id_Spectrometer /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  virtual ~BldDataSpectrometerV1();
  /** Width of camera frame and thus size of hproj array 
     PV TBD */
  virtual uint32_t width() const = 0;
  /** First row of pixels used in projection ROI  
     PV TBD */
  virtual uint32_t hproj_y1() const = 0;
  /** Last row of pixels used in projection ROI
    PV: TBD */
  virtual uint32_t hproj_y2() const = 0;
  /** Raw center of mass, no baseline subtraction 
     PV: TBD */
  virtual double comRaw() const = 0;
  /** Baseline level for calculated values 
     PV: TBD */
  virtual double baseline() const = 0;
  /** Baseline-subtracted center of mass 
     PV: TBD */
  virtual double com() const = 0;
  /** Integrated area under spectrum (no baseline subtraction) 
     PV: TBD */
  virtual double integral() const = 0;
  /** Number of peak fits performed
    PV: TBD */
  virtual uint32_t nPeaks() const = 0;
  /** Projection of spectrum onto energy axis 
     PV TBD */
  virtual ndarray<const uint32_t, 1> hproj() const = 0;
  /** Peak position array, length given by nPeaks
     PV: TBD */
  virtual ndarray<const double, 1> peakPos() const = 0;
  /** Peak height array, length given by nPeaks
     PV: TBD */
  virtual ndarray<const double, 1> peakHeight() const = 0;
  /** Peak FWHM array, length given by nPeaks
     PV: TBD */
  virtual ndarray<const double, 1> FWHM() const = 0;
};

/** @class BldDataAnalogInputV1

  Structure which contains voltage data from an analog input device.
*/


class BldDataAnalogInputV1 {
public:
  enum { TypeId = Pds::TypeId::Id_AnalogInput /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  virtual ~BldDataAnalogInputV1();
  /** The number of active channels on the analog input device. */
  virtual uint32_t numChannels() const = 0;
  /** Array of voltage values were each entry represents a channel of the analog input device. */
  virtual ndarray<const double, 1> channelVoltages() const = 0;
};
} // namespace Bld
} // namespace Psana
#endif // PSANA_BLD_DDL_H
