#ifndef PSANA_CSPAD_DDL_H
#define PSANA_CSPAD_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include "ndarray/ndarray.h"
#include "pdsdata/xtc/TypeId.hh"
namespace Psana {
namespace CsPad {
  enum {
    MaxQuadsPerSensor = 4 /**< Defines number of quadrants in a CsPad device. */
  };
  enum {
    ASICsPerQuad = 16 /**< Total number of ASICs in one quadrant. */
  };
  enum {
    RowsPerBank = 26 /**< Number of rows per readout bank? */
  };
  enum {
    FullBanksPerASIC = 7 /**< Number of full readout banks per one ASIC? */
  };
  enum {
    BanksPerASIC = 8 /**< Number of readout banks per one ASIC? */
  };
  enum {
    ColumnsPerASIC = 185 /**< Number of columns readout by single ASIC. */
  };
  enum {
    MaxRowsPerASIC = 194 /**< Maximum number of rows readout by single ASIC. */
  };
  enum {
    PotsPerQuad = 80 /**< Number of POTs? per single quadrant. */
  };
  enum {
    TwoByTwosPerQuad = 4 /**< Total number of 2x2s in single quadrant. */
  };
  enum {
    SectorsPerQuad = 8 /**< Total number of sectors (2x1) per single quadrant. */
  };

  /** Enum specifying different running modes. */
  enum RunModes {
    NoRunning,
    RunButDrop,
    RunAndSendToRCE,
    RunAndSendTriggeredByTTL,
    ExternalTriggerSendToRCE,
    ExternalTriggerDrop,
    NumberOfRunModes,
  };

  /** Enum specifying different data collection modes. */
  enum DataModes {
    normal = 0,
    shiftTest = 1,
    testData = 2,
    reserved = 3,
  };

/** @class CsPadDigitalPotsCfg

  Class defining configuration for CsPad POTs?
*/


class CsPadDigitalPotsCfg {
public:
  virtual ~CsPadDigitalPotsCfg();
  bool operator==(const CsPadDigitalPotsCfg &t) const { return this == &t; }
  virtual ndarray<uint8_t, 1> pots() const = 0;
};

/** @class CsPadReadOnlyCfg

  Class defining read-only configuration.
*/


class CsPadReadOnlyCfg {
public:
  virtual ~CsPadReadOnlyCfg();
  bool operator==(const CsPadReadOnlyCfg &t) const { return this == &t; }
  virtual uint32_t shiftTest() const = 0;
  virtual uint32_t version() const = 0;
};

/** @class ProtectionSystemThreshold

  
*/


class ProtectionSystemThreshold {
public:
  virtual ~ProtectionSystemThreshold();
  bool operator==(const ProtectionSystemThreshold &t) const { return this == &t; }
  virtual uint32_t adcThreshold() const = 0;
  virtual uint32_t pixelCountThreshold() const = 0;
};

/** @class CsPadGainMapCfg

  Class defining ASIC gain map.
*/


class CsPadGainMapCfg {
public:
  virtual ~CsPadGainMapCfg();
  bool operator==(const CsPadGainMapCfg &t) const { return this == &t; }
  /** Array with the gain map for single ASIC. */
  virtual ndarray<uint16_t, 2> gainMap() const = 0;
};

/** @class ConfigV1QuadReg

  Configuration data for single quadrant.
*/


class ConfigV1QuadReg {
public:
  virtual ~ConfigV1QuadReg();
  bool operator==(const ConfigV1QuadReg &t) const { return this == &t; }
  virtual ndarray<uint32_t, 1> shiftSelect() const = 0;
  virtual ndarray<uint32_t, 1> edgeSelect() const = 0;
  virtual uint32_t readClkSet() const = 0;
  virtual uint32_t readClkHold() const = 0;
  virtual uint32_t dataMode() const = 0;
  virtual uint32_t prstSel() const = 0;
  virtual uint32_t acqDelay() const = 0;
  virtual uint32_t intTime() const = 0;
  virtual uint32_t digDelay() const = 0;
  virtual uint32_t ampIdle() const = 0;
  virtual uint32_t injTotal() const = 0;
  virtual uint32_t rowColShiftPer() const = 0;
  /** read-only configuration */
  virtual const CsPad::CsPadReadOnlyCfg& ro() const = 0;
  virtual const CsPad::CsPadDigitalPotsCfg& dp() const = 0;
  /** Gain map. */
  virtual const CsPad::CsPadGainMapCfg& gm() const = 0;
};

/** @class ConfigV1

  Configuration data for complete CsPad device.
*/


class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_CspadConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  virtual ~ConfigV1();
  bool operator==(const ConfigV1 &t) const { return this == &t; }
  virtual uint32_t concentratorVersion() const = 0;
  virtual uint32_t runDelay() const = 0;
  virtual uint32_t eventCode() const = 0;
  virtual uint32_t inactiveRunMode() const = 0;
  virtual uint32_t activeRunMode() const = 0;
  virtual uint32_t tdi() const = 0;
  virtual uint32_t payloadSize() const = 0;
  virtual uint32_t badAsicMask0() const = 0;
  virtual uint32_t badAsicMask1() const = 0;
  virtual uint32_t asicMask() const = 0;
  virtual uint32_t quadMask() const = 0;
  virtual const CsPad::ConfigV1QuadReg& quads(uint32_t i0) const = 0;
  virtual uint32_t numAsicsRead() const = 0;
  virtual uint32_t numQuads() const = 0;
  virtual uint32_t numSect() const = 0;
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  virtual std::vector<int> quads_shape() const = 0;
};

/** @class ConfigV2

  Configuration data for complete CsPad device.
*/


class ConfigV2 {
public:
  enum { TypeId = Pds::TypeId::Id_CspadConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  virtual ~ConfigV2();
  bool operator==(const ConfigV2 &t) const { return this == &t; }
  virtual uint32_t concentratorVersion() const = 0;
  virtual uint32_t runDelay() const = 0;
  virtual uint32_t eventCode() const = 0;
  virtual uint32_t inactiveRunMode() const = 0;
  virtual uint32_t activeRunMode() const = 0;
  virtual uint32_t tdi() const = 0;
  virtual uint32_t payloadSize() const = 0;
  virtual uint32_t badAsicMask0() const = 0;
  virtual uint32_t badAsicMask1() const = 0;
  virtual uint32_t asicMask() const = 0;
  virtual uint32_t quadMask() const = 0;
  virtual const CsPad::ConfigV1QuadReg& quads(uint32_t i0) const = 0;
  virtual uint32_t numAsicsRead() const = 0;
  /** ROI mask for given quadrant */
  virtual uint32_t roiMask(uint32_t iq) const = 0;
  /** Number of ASICs in given quadrant */
  virtual uint32_t numAsicsStored(uint32_t iq) const = 0;
  /** Total number of quadrants in setup */
  virtual uint32_t numQuads() const = 0;
  /** Total number of sections (2x1) in all quadrants */
  virtual uint32_t numSect() const = 0;
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  virtual std::vector<int> quads_shape() const = 0;
};

/** @class ConfigV3

  Configuration data for complete CsPad device.
*/


class ConfigV3 {
public:
  enum { TypeId = Pds::TypeId::Id_CspadConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 3 /**< XTC type version number */ };
  virtual ~ConfigV3();
  bool operator==(const ConfigV3 &t) const { return this == &t; }
  virtual uint32_t concentratorVersion() const = 0;
  virtual uint32_t runDelay() const = 0;
  virtual uint32_t eventCode() const = 0;
  virtual const CsPad::ProtectionSystemThreshold& protectionThresholds(uint32_t i0) const = 0;
  virtual uint32_t protectionEnable() const = 0;
  virtual uint32_t inactiveRunMode() const = 0;
  virtual uint32_t activeRunMode() const = 0;
  virtual uint32_t tdi() const = 0;
  virtual uint32_t payloadSize() const = 0;
  virtual uint32_t badAsicMask0() const = 0;
  virtual uint32_t badAsicMask1() const = 0;
  virtual uint32_t asicMask() const = 0;
  virtual uint32_t quadMask() const = 0;
  virtual const CsPad::ConfigV1QuadReg& quads(uint32_t i0) const = 0;
  virtual uint32_t numAsicsRead() const = 0;
  /** ROI mask for given quadrant */
  virtual uint32_t roiMask(uint32_t iq) const = 0;
  /** Number of ASICs in given quadrant */
  virtual uint32_t numAsicsStored(uint32_t iq) const = 0;
  /** Total number of quadrants in setup */
  virtual uint32_t numQuads() const = 0;
  /** Total number of sections (2x1) in all quadrants */
  virtual uint32_t numSect() const = 0;
  /** Method which returns the shape (dimensions) of the data returned by protectionThresholds() method. */
  virtual std::vector<int> protectionThresholds_shape() const = 0;
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  virtual std::vector<int> quads_shape() const = 0;
};

/** @class ElementV1

  CsPad data from single CsPad quadrant.
*/

class ConfigV1;
class ConfigV2;

class ElementV1 {
public:
  enum { Nsbtemp = 4 /**< Number of the elements in _sbtemp array. */ };
  virtual ~ElementV1();
  bool operator==(const ElementV1 &t) const { return this == &t; }
  /** Virtual channel number. */
  virtual uint32_t virtual_channel() const = 0;
  /** Lane number. */
  virtual uint32_t lane() const = 0;
  virtual uint32_t tid() const = 0;
  virtual uint32_t acq_count() const = 0;
  virtual uint32_t op_code() const = 0;
  /** Quadrant number. */
  virtual uint32_t quad() const = 0;
  /** Counter incremented on every event. */
  virtual uint32_t seq_count() const = 0;
  virtual uint32_t ticks() const = 0;
  virtual uint32_t fiducials() const = 0;
  virtual ndarray<uint16_t, 1> sb_temp() const = 0;
  virtual uint32_t frame_type() const = 0;
  virtual ndarray<int16_t, 3> data() const = 0;
  /** Returns section mask for this quadrant. Mask can contain up to 8 bits in the lower byte, 
				total bit count gives the number of sections active. */
  virtual uint32_t sectionMask() const = 0;
  /** Common mode value for a given section, section number can be 0 to config.numAsicsRead()/2.
                Will return 0 for data read from XTC, may be non-zero after calibration. */
  virtual float common_mode(uint32_t section) const = 0;
};

/** @class DataV1

  CsPad data from whole detector.
*/

class ConfigV1;
class ConfigV2;

class DataV1 {
public:
  enum { TypeId = Pds::TypeId::Id_CspadElement /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  virtual ~DataV1();
  bool operator==(const DataV1 &t) const { return this == &t; }
  /** Data objects, one element per quadrant. The size of the array is determined by 
            the numQuads() method of the configuration object. */
  virtual const CsPad::ElementV1& quads(uint32_t i0) const = 0;
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  virtual std::vector<int> quads_shape() const = 0;
};

/** @class ElementV2

  CsPad data from single CsPad quadrant.
*/

class ConfigV2;
class ConfigV3;

class ElementV2 {
public:
  enum { Nsbtemp = 4 /**< Number of the elements in _sbtemp array. */ };
  virtual ~ElementV2();
  bool operator==(const ElementV2 &t) const { return this == &t; }
  /** Virtual channel number. */
  virtual uint32_t virtual_channel() const = 0;
  /** Lane number. */
  virtual uint32_t lane() const = 0;
  virtual uint32_t tid() const = 0;
  virtual uint32_t acq_count() const = 0;
  virtual uint32_t op_code() const = 0;
  /** Quadrant number. */
  virtual uint32_t quad() const = 0;
  virtual uint32_t seq_count() const = 0;
  virtual uint32_t ticks() const = 0;
  virtual uint32_t fiducials() const = 0;
  virtual ndarray<uint16_t, 1> sb_temp() const = 0;
  virtual uint32_t frame_type() const = 0;
  virtual ndarray<int16_t, 3> data() const = 0;
  /** Returns section mask for this quadrant. Mask can contain up to 8 bits in the lower byte, 
				total bit count gives the number of sections active. */
  virtual uint32_t sectionMask() const = 0;
  /** Common mode value for a given section, section number can be 0 to config.numSect().
                Will return 0 for data read from XTC, may be non-zero after calibration. */
  virtual float common_mode(uint32_t section) const = 0;
};

/** @class DataV2

  CsPad data from whole detector.
*/

class ConfigV2;
class ConfigV3;

class DataV2 {
public:
  enum { TypeId = Pds::TypeId::Id_CspadElement /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  virtual ~DataV2();
  bool operator==(const DataV2 &t) const { return this == &t; }
  /** Data objects, one element per quadrant. The size of the array is determined by 
            the numQuads() method of the configuration object. */
  virtual const CsPad::ElementV2& quads(uint32_t i0) const = 0;
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  virtual std::vector<int> quads_shape() const = 0;
};
} // namespace CsPad
} // namespace Psana
#endif // PSANA_CSPAD_DDL_H
