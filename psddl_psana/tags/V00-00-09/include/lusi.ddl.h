#ifndef PSANA_LUSI_DDL_H
#define PSANA_LUSI_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include "pdsdata/xtc/TypeId.hh"

#include <vector>

namespace Psana {
namespace Lusi {

/** @class DiodeFexConfigV1

  
*/

#pragma pack(push,4)

class DiodeFexConfigV1 {
public:
  enum {
    Version = 1 /**< XTC type version number */
  };
  enum {
    TypeId = Pds::TypeId::Id_DiodeFexConfig /**< XTC type ID value (from Pds::TypeId class) */
  };
  enum {
    NRANGES = 3 /**<  */
  };
  DiodeFexConfigV1()
  {
  }
  DiodeFexConfigV1(const float* arg__base, const float* arg__scale)
  {
    std::copy(arg__base, arg__base+(3), _base);
    std::copy(arg__scale, arg__scale+(3), _scale);
  }
  const float* base() const {return &_base[0];}
  const float* scale() const {return &_scale[0];}
  static uint32_t _sizeof()  {return (0+(4*(NRANGES)))+(4*(NRANGES));}
  /** Method which returns the shape (dimensions) of the data returned by base() method. */
  std::vector<int> base_shape() const;
  /** Method which returns the shape (dimensions) of the data returned by scale() method. */
  std::vector<int> scale_shape() const;
private:
  float	_base[NRANGES];
  float	_scale[NRANGES];
};
#pragma pack(pop)

/** @class DiodeFexConfigV2

  
*/

#pragma pack(push,4)

class DiodeFexConfigV2 {
public:
  enum {
    Version = 2 /**< XTC type version number */
  };
  enum {
    TypeId = Pds::TypeId::Id_DiodeFexConfig /**< XTC type ID value (from Pds::TypeId class) */
  };
  enum {
    NRANGES = 16 /**<  */
  };
  DiodeFexConfigV2()
  {
  }
  DiodeFexConfigV2(const float* arg__base, const float* arg__scale)
  {
    std::copy(arg__base, arg__base+(16), _base);
    std::copy(arg__scale, arg__scale+(16), _scale);
  }
  const float* base() const {return &_base[0];}
  const float* scale() const {return &_scale[0];}
  static uint32_t _sizeof()  {return (0+(4*(NRANGES)))+(4*(NRANGES));}
  /** Method which returns the shape (dimensions) of the data returned by base() method. */
  std::vector<int> base_shape() const;
  /** Method which returns the shape (dimensions) of the data returned by scale() method. */
  std::vector<int> scale_shape() const;
private:
  float	_base[NRANGES];
  float	_scale[NRANGES];
};
#pragma pack(pop)

/** @class DiodeFexV1

  
*/

#pragma pack(push,4)

class DiodeFexV1 {
public:
  enum {
    Version = 1 /**< XTC type version number */
  };
  enum {
    TypeId = Pds::TypeId::Id_DiodeFex /**< XTC type ID value (from Pds::TypeId class) */
  };
  DiodeFexV1(float arg__value)
    : _value(arg__value)
  {
  }
  float value() const {return _value;}
  static uint32_t _sizeof()  {return 4;}
private:
  float	_value;
};
#pragma pack(pop)

/** @class IpmFexConfigV1

  
*/


class IpmFexConfigV1 {
public:
  enum {
    Version = 1 /**< XTC type version number */
  };
  enum {
    TypeId = Pds::TypeId::Id_IpmFexConfig /**< XTC type ID value (from Pds::TypeId class) */
  };
  enum {
    NCHANNELS = 4 /**<  */
  };
  virtual ~IpmFexConfigV1();
  virtual const Lusi::DiodeFexConfigV1& diode(uint32_t i0) const = 0;
  virtual float xscale() const = 0;
  virtual float yscale() const = 0;
  /** Method which returns the shape (dimensions) of the data returned by diode() method. */
  virtual std::vector<int> diode_shape() const = 0;
};

/** @class IpmFexConfigV2

  
*/


class IpmFexConfigV2 {
public:
  enum {
    Version = 2 /**< XTC type version number */
  };
  enum {
    TypeId = Pds::TypeId::Id_IpmFexConfig /**< XTC type ID value (from Pds::TypeId class) */
  };
  enum {
    NCHANNELS = 4 /**<  */
  };
  virtual ~IpmFexConfigV2();
  virtual const Lusi::DiodeFexConfigV2& diode(uint32_t i0) const = 0;
  virtual float xscale() const = 0;
  virtual float yscale() const = 0;
  /** Method which returns the shape (dimensions) of the data returned by diode() method. */
  virtual std::vector<int> diode_shape() const = 0;
};

/** @class IpmFexV1

  
*/

#pragma pack(push,4)

class IpmFexV1 {
public:
  enum {
    Version = 1 /**< XTC type version number */
  };
  enum {
    TypeId = Pds::TypeId::Id_IpmFex /**< XTC type ID value (from Pds::TypeId class) */
  };
  enum {
    NCHANNELS = 4 /**<  */
  };
  IpmFexV1(const float* arg__channel, float arg__sum, float arg__xpos, float arg__ypos)
    : _sum(arg__sum), _xpos(arg__xpos), _ypos(arg__ypos)
  {
    std::copy(arg__channel, arg__channel+(4), _channel);
  }
  const float* channel() const {return &_channel[0];}
  float sum() const {return _sum;}
  float xpos() const {return _xpos;}
  float ypos() const {return _ypos;}
  static uint32_t _sizeof()  {return (((0+(4*(NCHANNELS)))+4)+4)+4;}
  /** Method which returns the shape (dimensions) of the data returned by channel() method. */
  std::vector<int> channel_shape() const;
private:
  float	_channel[NCHANNELS];
  float	_sum;
  float	_xpos;
  float	_ypos;
};
#pragma pack(pop)

/** @class PimImageConfigV1

  
*/

#pragma pack(push,4)

class PimImageConfigV1 {
public:
  enum {
    Version = 1 /**< XTC type version number */
  };
  enum {
    TypeId = Pds::TypeId::Id_PimImageConfig /**< XTC type ID value (from Pds::TypeId class) */
  };
  PimImageConfigV1(float arg__xscale, float arg__yscale)
    : _xscale(arg__xscale), _yscale(arg__yscale)
  {
  }
  float xscale() const {return _xscale;}
  float yscale() const {return _yscale;}
  static uint32_t _sizeof()  {return 8;}
private:
  float	_xscale;
  float	_yscale;
};
#pragma pack(pop)
} // namespace Lusi
} // namespace Psana
#endif // PSANA_LUSI_DDL_H
