#ifndef PSANA_TIMETOOL_DDL_H
#define PSANA_TIMETOOL_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstring>
#include "ndarray/ndarray.h"
#include "pdsdata/xtc/TypeId.hh"
#include "psddl_psana/camera.ddl.h"
#include "pdsdata/xtc/Src.hh"
namespace Psana {
namespace TimeTool {

/** @class EventLogic

  
*/


class EventLogic {
public:
  enum LogicOp {
    L_OR = 0,
    L_AND = 1,
    L_OR_NOT = 2,
    L_AND_NOT = 3,
  };
  EventLogic(uint8_t arg__event_code, TimeTool::EventLogic::LogicOp arg__logic_op)
    : _Code(((arg__event_code) & 0xff)|(((arg__logic_op) & 0x3)<<8))
  {
  }
  EventLogic() {}
  /** Event Code */
  uint8_t event_code() const { return uint8_t(this->_Code & 0xff); }
  /** Logic Operation */
  TimeTool::EventLogic::LogicOp logic_op() const { return LogicOp((this->_Code>>8) & 0x3); }
  static uint32_t _sizeof() { return 4; }
private:
  uint32_t	_Code;
};
std::ostream& operator<<(std::ostream& str, TimeTool::EventLogic::LogicOp enval);

/** @class ConfigV1

  
*/


class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_TimeToolConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum Axis {
    X = 0,
    Y = 1,
  };
  virtual ~ConfigV1();
  /** Time Axis of Image */
  virtual TimeTool::ConfigV1::Axis project_axis() const = 0;
  /** Record Raw Image into Event */
  virtual uint8_t write_image() const = 0;
  /** Record Time Axis Projections into Event */
  virtual uint8_t write_projections() const = 0;
  /** Subtract Sideband Region */
  virtual uint8_t subtract_sideband() const = 0;
  /** Number of Digital Filter Weights */
  virtual uint16_t number_of_weights() const = 0;
  /** Pixel to Time Calibration Polynomial Dimension */
  virtual uint8_t calib_poly_dim() const = 0;
  /** Length of EPICS PV base name */
  virtual uint8_t base_name_length() const = 0;
  /** Number of Beam Logic Event Codes */
  virtual uint16_t number_of_beam_event_codes() const = 0;
  /** Number of Laser Logic Event Codes */
  virtual uint16_t number_of_laser_event_codes() const = 0;
  /** Projection Minimum Value for Validation */
  virtual uint32_t signal_cut() const = 0;
  /** Signal Region Coordinates Start */
  virtual const Camera::FrameCoord& sig_roi_lo() const = 0;
  /** Signal Region Coordinates End */
  virtual const Camera::FrameCoord& sig_roi_hi() const = 0;
  /** Sideband Region Coordinates Start */
  virtual const Camera::FrameCoord& sb_roi_lo() const = 0;
  /** Sideband Region Coordinates End */
  virtual const Camera::FrameCoord& sb_roi_hi() const = 0;
  /** Sideband Rolling Average Factor (1/NFrames) */
  virtual double sb_convergence() const = 0;
  /** Reference Rolling Average Factor (1/NFrames) */
  virtual double ref_convergence() const = 0;
  /** Beam Logic Event Codes */
  virtual ndarray<const TimeTool::EventLogic, 1> beam_logic() const = 0;
  /** Laser Logic Event Codes */
  virtual ndarray<const TimeTool::EventLogic, 1> laser_logic() const = 0;
  /** Digital Filter Weights */
  virtual ndarray<const double, 1> weights() const = 0;
  /** Pixel to Time Calibration Polynomial */
  virtual ndarray<const double, 1> calib_poly() const = 0;
  /** EPICS PV base name */
  virtual const char* base_name() const = 0;
  /** Size of projections */
  virtual uint32_t signal_projection_size() const = 0;
  virtual uint32_t sideband_projection_size() const = 0;
  /** Method which returns the shape (dimensions) of the data returned by base_name() method. */
  virtual std::vector<int> base_name_shape() const = 0;
};
std::ostream& operator<<(std::ostream& str, TimeTool::ConfigV1::Axis enval);

/** @class ConfigV2

  
*/


class ConfigV2 {
public:
  enum { TypeId = Pds::TypeId::Id_TimeToolConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  enum Axis {
    X = 0,
    Y = 1,
  };
  virtual ~ConfigV2();
  /** Time Axis of Image */
  virtual TimeTool::ConfigV2::Axis project_axis() const = 0;
  /** Record Raw Image into Event */
  virtual uint8_t write_image() const = 0;
  /** Record Time Axis Projections into Event */
  virtual uint8_t write_projections() const = 0;
  /** Subtract Sideband Region */
  virtual uint8_t subtract_sideband() const = 0;
  /** Use Separate Reference Region */
  virtual uint8_t use_reference_roi() const = 0;
  /** Number of Digital Filter Weights */
  virtual uint16_t number_of_weights() const = 0;
  /** Pixel to Time Calibration Polynomial Dimension */
  virtual uint8_t calib_poly_dim() const = 0;
  /** Length of EPICS PV base name */
  virtual uint8_t base_name_length() const = 0;
  /** Number of Beam Logic Event Codes */
  virtual uint16_t number_of_beam_event_codes() const = 0;
  /** Number of Laser Logic Event Codes */
  virtual uint16_t number_of_laser_event_codes() const = 0;
  /** Projection Minimum Value for Validation */
  virtual uint32_t signal_cut() const = 0;
  /** Signal Region Coordinates Start */
  virtual const Camera::FrameCoord& sig_roi_lo() const = 0;
  /** Signal Region Coordinates End */
  virtual const Camera::FrameCoord& sig_roi_hi() const = 0;
  /** Sideband Region Coordinates Start */
  virtual const Camera::FrameCoord& sb_roi_lo() const = 0;
  /** Sideband Region Coordinates End */
  virtual const Camera::FrameCoord& sb_roi_hi() const = 0;
  /** Sideband Rolling Average Factor (1/NFrames) */
  virtual double sb_convergence() const = 0;
  /** Reference Region Coordinates Start */
  virtual const Camera::FrameCoord& ref_roi_lo() const = 0;
  /** Sideband Region Coordinates End */
  virtual const Camera::FrameCoord& ref_roi_hi() const = 0;
  /** Reference Rolling Average Factor (1/NFrames) */
  virtual double ref_convergence() const = 0;
  /** Beam Logic Event Codes */
  virtual ndarray<const TimeTool::EventLogic, 1> beam_logic() const = 0;
  /** Laser Logic Event Codes */
  virtual ndarray<const TimeTool::EventLogic, 1> laser_logic() const = 0;
  /** Digital Filter Weights */
  virtual ndarray<const double, 1> weights() const = 0;
  /** Pixel to Time Calibration Polynomial */
  virtual ndarray<const double, 1> calib_poly() const = 0;
  /** EPICS PV base name */
  virtual const char* base_name() const = 0;
  /** Size of projections */
  virtual uint32_t signal_projection_size() const = 0;
  virtual uint32_t sideband_projection_size() const = 0;
  virtual uint32_t reference_projection_size() const = 0;
  /** Method which returns the shape (dimensions) of the data returned by base_name() method. */
  virtual std::vector<int> base_name_shape() const = 0;
};
std::ostream& operator<<(std::ostream& str, TimeTool::ConfigV2::Axis enval);

/** @class DataV1

  
*/

class ConfigV1;

class DataV1 {
public:
  enum { TypeId = Pds::TypeId::Id_TimeToolData /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum EventType {
    Dark, /**< No Laser */
    Reference, /**< No Beam */
    Signal, /**< Laser and Beam */
  };
  virtual ~DataV1();
  /** Event designation */
  virtual TimeTool::DataV1::EventType event_type() const = 0;
  /** Amplitude of the edge */
  virtual double amplitude() const = 0;
  /** Filtered pixel position of the edge */
  virtual double position_pixel() const = 0;
  /** Filtered time position of the edge */
  virtual double position_time() const = 0;
  /** Full-width half maximum of filtered edge (in pixels) */
  virtual double position_fwhm() const = 0;
  /** Amplitude of reference at the edge */
  virtual double ref_amplitude() const = 0;
  /** Amplitude of the next largest edge */
  virtual double nxt_amplitude() const = 0;
  /** Projected signal */
  virtual ndarray<const int32_t, 1> projected_signal() const = 0;
  /** Projected reference */
  virtual ndarray<const int32_t, 1> projected_sideband() const = 0;
};
std::ostream& operator<<(std::ostream& str, TimeTool::DataV1::EventType enval);

/** @class DataV2

  
*/

class ConfigV2;

class DataV2 {
public:
  enum { TypeId = Pds::TypeId::Id_TimeToolData /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  enum EventType {
    Dark, /**< No Laser */
    Reference, /**< No Beam */
    Signal, /**< Laser and Beam */
  };
  virtual ~DataV2();
  /** Event designation */
  virtual TimeTool::DataV2::EventType event_type() const = 0;
  /** Amplitude of the edge */
  virtual double amplitude() const = 0;
  /** Filtered pixel position of the edge */
  virtual double position_pixel() const = 0;
  /** Filtered time position of the edge */
  virtual double position_time() const = 0;
  /** Full-width half maximum of filtered edge (in pixels) */
  virtual double position_fwhm() const = 0;
  /** Amplitude of reference at the edge */
  virtual double ref_amplitude() const = 0;
  /** Amplitude of the next largest edge */
  virtual double nxt_amplitude() const = 0;
  /** Projected signal */
  virtual ndarray<const int32_t, 1> projected_signal() const = 0;
  /** Projected sideband */
  virtual ndarray<const int32_t, 1> projected_sideband() const = 0;
  /** Projected reference */
  virtual ndarray<const int32_t, 1> projected_reference() const = 0;
};
std::ostream& operator<<(std::ostream& str, TimeTool::DataV2::EventType enval);
} // namespace TimeTool
} // namespace Psana
#endif // PSANA_TIMETOOL_DDL_H
