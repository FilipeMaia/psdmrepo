#ifndef PSANA_ALIAS_DDL_H
#define PSANA_ALIAS_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstring>
#include "ndarray/ndarray.h"
#include "pdsdata/xtc/TypeId.hh"
#include "pdsdata/xtc/Src.hh"
namespace Psana {
namespace Alias {

/** @class SrcAlias

  
*/


class SrcAlias {
public:
  enum { AliasNameMax = 31 };
  SrcAlias(const Pds::Src& arg__src, const char* arg__aliasName);
  SrcAlias() {}
  /** The src identifier */
  const Pds::Src& src() const { return _src; }
  /** Alias name for src identifier */
  const char* aliasName() const { return _aliasName; }
  uint8_t operator<(const Alias::SrcAlias& other) const;
  uint8_t operator==(const Alias::SrcAlias& other) const;
  static uint32_t _sizeof() { return ((((((0+(Pds::Src::_sizeof()))+(1*(AliasNameMax)))+1)+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by aliasName() method. */
  std::vector<int> aliasName_shape() const;
private:
  Pds::Src	_src;	/**< The src identifier */
  char	_aliasName[AliasNameMax];	/**< Alias name for src identifier */
  char	_pad1;
};

/** @class ConfigV1

  
*/


class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_AliasConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  virtual ~ConfigV1();
  /** Number of alias definitions */
  virtual uint32_t numSrcAlias() const = 0;
  /** SrcAlias configuration objects */
  virtual ndarray<const Alias::SrcAlias, 1> srcAlias() const = 0;
};
} // namespace Alias
} // namespace Psana
#endif // PSANA_ALIAS_DDL_H
