#ifndef PSANA_LUSI_DDL_H
#define PSANA_LUSI_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstring>
#include "ndarray/ndarray.h"
#include "pdsdata/xtc/TypeId.hh"
namespace Psana {
namespace Lusi {

/** @class DiodeFexConfigV1

  
*/


class DiodeFexConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_DiodeFexConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { NRANGES = 3 };
  DiodeFexConfigV1(const float* arg__base, const float* arg__scale)
  {
    if (arg__base) std::copy(arg__base, arg__base+(3), &_base[0]);
    if (arg__scale) std::copy(arg__scale, arg__scale+(3), &_scale[0]);
  }
  DiodeFexConfigV1() {}
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const float, 1> base() const { return make_ndarray(&_base[0], NRANGES); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const float, 1> scale() const { return make_ndarray(&_scale[0], NRANGES); }
  static uint32_t _sizeof() { return (((((0+(4*(NRANGES)))+(4*(NRANGES)))+4)-1)/4)*4; }
private:
  float	_base[NRANGES];
  float	_scale[NRANGES];
};

/** @class DiodeFexConfigV2

  
*/


class DiodeFexConfigV2 {
public:
  enum { TypeId = Pds::TypeId::Id_DiodeFexConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  enum { NRANGES = 16 };
  DiodeFexConfigV2(const float* arg__base, const float* arg__scale)
  {
    if (arg__base) std::copy(arg__base, arg__base+(16), &_base[0]);
    if (arg__scale) std::copy(arg__scale, arg__scale+(16), &_scale[0]);
  }
  DiodeFexConfigV2() {}
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const float, 1> base() const { return make_ndarray(&_base[0], NRANGES); }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const float, 1> scale() const { return make_ndarray(&_scale[0], NRANGES); }
  static uint32_t _sizeof() { return (((((0+(4*(NRANGES)))+(4*(NRANGES)))+4)-1)/4)*4; }
private:
  float	_base[NRANGES];
  float	_scale[NRANGES];
};

/** @class DiodeFexV1

  
*/


class DiodeFexV1 {
public:
  enum { TypeId = Pds::TypeId::Id_DiodeFex /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  DiodeFexV1(float arg__value)
    : _value(arg__value)
  {
  }
  DiodeFexV1() {}
  float value() const { return _value; }
  static uint32_t _sizeof() { return 4; }
private:
  float	_value;
};

/** @class IpmFexConfigV1

  
*/


class IpmFexConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_IpmFexConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { NCHANNELS = 4 };
  virtual ~IpmFexConfigV1();
  virtual ndarray<const Lusi::DiodeFexConfigV1, 1> diode() const = 0;
  virtual float xscale() const = 0;
  virtual float yscale() const = 0;
};

/** @class IpmFexConfigV2

  
*/


class IpmFexConfigV2 {
public:
  enum { TypeId = Pds::TypeId::Id_IpmFexConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  enum { NCHANNELS = 4 };
  virtual ~IpmFexConfigV2();
  virtual ndarray<const Lusi::DiodeFexConfigV2, 1> diode() const = 0;
  virtual float xscale() const = 0;
  virtual float yscale() const = 0;
};

/** @class IpmFexV1

  
*/


class IpmFexV1 {
public:
  enum { TypeId = Pds::TypeId::Id_IpmFex /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { NCHANNELS = 4 };
  IpmFexV1(const float* arg__channel, float arg__sum, float arg__xpos, float arg__ypos)
    : _sum(arg__sum), _xpos(arg__xpos), _ypos(arg__ypos)
  {
    if (arg__channel) std::copy(arg__channel, arg__channel+(4), &_channel[0]);
  }
  IpmFexV1() {}
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const float, 1> channel() const { return make_ndarray(&_channel[0], NCHANNELS); }
  float sum() const { return _sum; }
  float xpos() const { return _xpos; }
  float ypos() const { return _ypos; }
  static uint32_t _sizeof() { return (((((((0+(4*(NCHANNELS)))+4)+4)+4)+4)-1)/4)*4; }
private:
  float	_channel[NCHANNELS];
  float	_sum;
  float	_xpos;
  float	_ypos;
};

/** @class PimImageConfigV1

  
*/


class PimImageConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_PimImageConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  PimImageConfigV1(float arg__xscale, float arg__yscale)
    : _xscale(arg__xscale), _yscale(arg__yscale)
  {
  }
  PimImageConfigV1() {}
  float xscale() const { return _xscale; }
  float yscale() const { return _yscale; }
  static uint32_t _sizeof() { return 8; }
private:
  float	_xscale;
  float	_yscale;
};
} // namespace Lusi
} // namespace Psana
#endif // PSANA_LUSI_DDL_H
