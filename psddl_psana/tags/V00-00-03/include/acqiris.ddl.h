#ifndef PSANA_ACQIRIS_DDL_H
#define PSANA_ACQIRIS_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include "pdsdata/xtc/TypeId.hh"

#include <vector>

namespace Psana {
namespace Acqiris {

/** Class: VertV1
  Pds.Acqiris class VertV1
*/

#pragma pack(push,4)

class VertV1 {
public:
  enum {Version = 1};
  enum Coupling {
    GND,
    DC,
    AC,
    DC50ohm,
    AC50ohm,
  };
  enum Bandwidth {
    None,
    MHz25,
    MHz700,
    MHz200,
    MHz20,
    MHz35,
  };
  VertV1()
  {
  }
  VertV1(double arg__fullScale, double arg__offset, uint32_t arg__coupling, uint32_t arg__bandwidth)
    : _fullScale(arg__fullScale), _offset(arg__offset), _coupling(arg__coupling), _bandwidth(arg__bandwidth)
  {
  }
  double fullScale() const {return _fullScale;}
  double offset() const {return _offset;}
  uint32_t coupling() const {return _coupling;}
  uint32_t bandwidth() const {return _bandwidth;}
  double slope() const;
  static uint32_t _sizeof()  {return 24;}
private:
  double	_fullScale;
  double	_offset;
  uint32_t	_coupling;
  uint32_t	_bandwidth;
};
#pragma pack(pop)

/** Class: HorizV1
  Pds.Acqiris class HorizV1
*/

#pragma pack(push,4)

class HorizV1 {
public:
  enum {Version = 1};
  HorizV1()
  {
  }
  HorizV1(double arg__sampInterval, double arg__delayTime, uint32_t arg__nbrSamples, uint32_t arg__nbrSegments)
    : _sampInterval(arg__sampInterval), _delayTime(arg__delayTime), _nbrSamples(arg__nbrSamples), _nbrSegments(arg__nbrSegments)
  {
  }
  double sampInterval() const {return _sampInterval;}
  double delayTime() const {return _delayTime;}
  uint32_t nbrSamples() const {return _nbrSamples;}
  uint32_t nbrSegments() const {return _nbrSegments;}
  static uint32_t _sizeof()  {return 24;}
private:
  double	_sampInterval;
  double	_delayTime;
  uint32_t	_nbrSamples;
  uint32_t	_nbrSegments;
};
#pragma pack(pop)

/** Class: TrigV1
  Pds.Acqiris class TrigV1
*/

#pragma pack(push,4)

class TrigV1 {
public:
  enum {Version = 1};
  enum Source {
    Internal = 1,
    External = -1,
  };
  enum Coupling {
    DC = 0,
    AC = 1,
    HFreject = 2,
    DC50ohm = 3,
    AC50ohm = 4,
  };
  enum Slope {
    Positive,
    Negative,
    OutOfWindow,
    IntoWindow,
    HFDivide,
    SpikeStretcher,
  };
  TrigV1()
  {
  }
  TrigV1(uint32_t arg__coupling, uint32_t arg__input, uint32_t arg__slope, double arg__level)
    : _coupling(arg__coupling), _input(arg__input), _slope(arg__slope), _level(arg__level)
  {
  }
  uint32_t coupling() const {return _coupling;}
  uint32_t input() const {return _input;}
  uint32_t slope() const {return _slope;}
  double level() const {return _level;}
  static uint32_t _sizeof()  {return 20;}
private:
  uint32_t	_coupling;
  uint32_t	_input;
  uint32_t	_slope;
  double	_level;
};
#pragma pack(pop)

/** Class: ConfigV1
  Pds.Acqiris class ConfigV1
*/


class ConfigV1 {
public:
  enum {Version = 1};
  enum {TypeId = Pds::TypeId::Id_AcqConfig};
  enum {MaxChan = 20};
  virtual ~ConfigV1();
  virtual uint32_t nbrConvertersPerChannel() const = 0;
  virtual uint32_t channelMask() const = 0;
  virtual uint32_t nbrBanks() const = 0;
  virtual const Acqiris::TrigV1& trig() const = 0;
  virtual const Acqiris::HorizV1& horiz() const = 0;
  virtual const Acqiris::VertV1& vert(uint32_t i0) const = 0;
  virtual uint32_t nbrChannels() const = 0;
  virtual std::vector<int> vert_shape() const = 0;
};

/** Class: TimestampV1
  Pds.Acqiris class "TimestampV1"
*/

#pragma pack(push,4)

class TimestampV1 {
public:
  enum {Version = 1};
  TimestampV1()
  {
  }
  TimestampV1(double arg__horPos, uint32_t arg__timeStampLo, uint32_t arg__timeStampHi)
    : _horPos(arg__horPos), _timeStampLo(arg__timeStampLo), _timeStampHi(arg__timeStampHi)
  {
  }
  double pos() const {return _horPos;}
  uint32_t timeStampLo() const {return _timeStampLo;}
  uint32_t timeStampHi() const {return _timeStampHi;}
  uint64_t value() const;
  static uint32_t _sizeof()  {return 16;}
private:
  double	_horPos;
  uint32_t	_timeStampLo;
  uint32_t	_timeStampHi;
};
#pragma pack(pop)

/** Class: DataDescV1Elem
  Pds.Acqiris class DataDescV1Elem
*/

class ConfigV1;

class DataDescV1Elem {
public:
  enum {Version = 1};
  enum {NumberOfBits = 10};
  enum {BitShift = 6};
  enum {_extra = 32*sizeof(short)};
  virtual ~DataDescV1Elem();
  virtual uint32_t nbrSamplesInSeg() const = 0;
  virtual uint32_t indexFirstPoint() const = 0;
  virtual uint32_t nbrSegments() const = 0;
  virtual const Acqiris::TimestampV1& timestamp(uint32_t i0) const = 0;
  virtual const int16_t* waveforms() const = 0;
  virtual std::vector<int> timestamps_shape() const = 0;
  virtual std::vector<int> waveforms_shape() const = 0;
  virtual std::vector<int> _extraSpace_shape() const = 0;
};

/** Class: DataDescV1
  Pds.Acqiris class DataDescV1
*/

class ConfigV1;

class DataDescV1 {
public:
  enum {Version = 1};
  enum {TypeId = Pds::TypeId::Id_AcqWaveform};
  virtual ~DataDescV1();
  virtual const Acqiris::DataDescV1Elem& data(uint32_t i0) const = 0;
  virtual std::vector<int> data_shape() const = 0;
};

/** Class: TdcChannel
  Pds.Acqiris class "TdcChannel"
*/

#pragma pack(push,4)

class TdcChannel {
public:
  enum Channel {
    Veto = -2,
    Common = -1,
    Input1 = 1,
    Input2 = 2,
    Input3 = 3,
    Input4 = 4,
    Input5 = 5,
    Input6 = 6,
  };
  enum Mode {
    Active = 0,
    Inactive = 1,
  };
  enum Slope {
    Positive,
    Negative,
  };
  TdcChannel()
  {
  }
  TdcChannel(uint32_t arg__channel, uint32_t arg__mode, double arg__level)
    : _channel(arg__channel), _mode(arg__mode), _level(arg__level)
  {
  }
  uint32_t _channel_int() const {return _channel;}
  uint32_t _mode_int() const {return _mode;}
  Acqiris::TdcChannel::Slope slope() const {return Slope(this->_mode & 0x1);}
  Acqiris::TdcChannel::Mode mode() const {return Mode((this->_mode>>31) & 0x1);}
  double level() const {return _level;}
  Acqiris::TdcChannel::Channel channel() const {return Channel(this->_channel);}
  static uint32_t _sizeof()  {return 16;}
private:
  uint32_t	_channel;
  uint32_t	_mode;
  double	_level;
};
#pragma pack(pop)

/** Class: TdcAuxIO
  Pds.Acqiris class "TdcAuxIO"
*/

#pragma pack(push,4)

class TdcAuxIO {
public:
  enum Channel {
    IOAux1 = 1,
    IOAux2 = 2,
  };
  enum Mode {
    BankSwitch = 1,
    Marker = 2,
    OutputLo = 32,
    OutputHi = 33,
  };
  enum Termination {
    ZHigh = 0,
    Z50 = 1,
  };
  TdcAuxIO()
  {
  }
  TdcAuxIO(uint32_t arg__channel, uint32_t arg__signal, uint32_t arg__qualifier)
    : _channel(arg__channel), _signal(arg__signal), _qualifier(arg__qualifier)
  {
  }
  uint32_t channel_int() const {return _channel;}
  uint32_t signal_int() const {return _signal;}
  uint32_t qualifier_int() const {return _qualifier;}
  Acqiris::TdcAuxIO::Channel channel() const {return Channel(this->_channel);}
  Acqiris::TdcAuxIO::Mode mode() const {return Mode(this->_signal);}
  Acqiris::TdcAuxIO::Termination term() const {return Termination(this->_qualifier);}
  static uint32_t _sizeof()  {return 12;}
private:
  uint32_t	_channel;
  uint32_t	_signal;
  uint32_t	_qualifier;
};
#pragma pack(pop)

/** Class: TdcVetoIO
  Pds.Acqiris class "TdcVetoIO"
*/

#pragma pack(push,4)

class TdcVetoIO {
public:
  enum Channel {
    ChVeto = 13,
  };
  enum Mode {
    Veto = 1,
    SwitchVeto = 2,
    InvertedVeto = 3,
    InvertedSwitchVeto = 4,
  };
  enum Termination {
    ZHigh = 0,
    Z50 = 1,
  };
  TdcVetoIO()
  {
  }
  TdcVetoIO(uint32_t mode, uint32_t term)
    : _channel(ChVeto), _signal(mode), _qualifier(term)
  {
  }
  uint32_t signal_int() const {return _signal;}
  uint32_t qualifier_int() const {return _qualifier;}
  Acqiris::TdcVetoIO::Channel channel() const {return Channel(this->_channel);}
  Acqiris::TdcVetoIO::Mode mode() const {return Mode(this->_signal);}
  Acqiris::TdcVetoIO::Termination term() const {return Termination(this->_qualifier);}
  static uint32_t _sizeof()  {return 12;}
private:
  uint32_t	_channel;
  uint32_t	_signal;
  uint32_t	_qualifier;
};
#pragma pack(pop)

/** Class: TdcConfigV1
  Pds.Acqiris class TdcConfigV1
*/


class TdcConfigV1 {
public:
  enum {Version = 1};
  enum {TypeId = Pds::TypeId::Id_AcqTdcConfig};
  enum {NChannels = 8};
  enum {NAuxIO = 2};
  virtual ~TdcConfigV1();
  virtual const Acqiris::TdcChannel& channels(uint32_t i0) const = 0;
  virtual const Acqiris::TdcAuxIO& auxio(uint32_t i0) const = 0;
  virtual const Acqiris::TdcVetoIO& veto() const = 0;
  virtual std::vector<int> channels_shape() const = 0;
  virtual std::vector<int> auxio_shape() const = 0;
};

/** Class: TdcDataV1_Item
  Pds.Acqiris class TdcDataV1
*/


class TdcDataV1_Item {
public:
  enum Source {
    Comm,
    Chan1,
    Chan2,
    Chan3,
    Chan4,
    Chan5,
    Chan6,
    AuxIO,
  };
  TdcDataV1_Item()
  {
  }
  TdcDataV1_Item(uint32_t arg__value)
    : _value(arg__value)
  {
  }
  uint32_t value() const {return _value;}
protected:
  uint32_t bf_val_() const {return uint32_t(this->_value & 0xfffffff);}
public:
  Acqiris::TdcDataV1_Item::Source source() const {return Source((this->_value>>28) & 0x7);}
protected:
  uint8_t bf_ofv_() const {return uint8_t((this->_value>>31) & 0x1);}
public:
  static uint32_t _sizeof()  {return 4;}
private:
  uint32_t	_value;
};

/** Class: TdcDataV1Common
  Pds.Acqiris class TdcDataV1::Common
*/


class TdcDataV1Common: public TdcDataV1_Item {
public:
  uint32_t nhits() const;
  uint8_t overflow() const;
  static uint32_t _sizeof()  {return Acqiris::TdcDataV1_Item::_sizeof();}
};

/** Class: TdcDataV1Channel
  Pds.Acqiris class TdcDataV1::Channel
*/


class TdcDataV1Channel: public TdcDataV1_Item {
public:
  uint32_t ticks() const;
  uint8_t overflow() const;
  double time() const;
  static uint32_t _sizeof()  {return Acqiris::TdcDataV1_Item::_sizeof();}
};

/** Class: TdcDataV1Marker
  Pds.Acqiris class TdcDataV1::Marker
*/


class TdcDataV1Marker: public TdcDataV1_Item {
public:
  enum Type {
    AuxIOSwitch = 0,
    EventCntSwitch = 1,
    MemFullSwitch = 2,
    AuxIOMarker = 16,
  };
  Acqiris::TdcDataV1Marker::Type type() const;
  static uint32_t _sizeof()  {return Acqiris::TdcDataV1_Item::_sizeof();}
};

/** Class: TdcDataV1
  Pds.Acqiris class TdcDataV1
*/


class TdcDataV1 {
public:
  enum {Version = 1};
  enum {TypeId = Pds::TypeId::Id_AcqTdcData};
  virtual ~TdcDataV1();
  virtual const Acqiris::TdcDataV1_Item& data(uint32_t i0) const = 0;
  virtual std::vector<int> data_shape() const = 0;
};
} // namespace Acqiris
} // namespace Psana
#endif // PSANA_ACQIRIS_DDL_H
