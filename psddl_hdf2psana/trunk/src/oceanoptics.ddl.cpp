
// *** Do not edit this file, it is auto-generated ***

#include "psddl_hdf2psana/oceanoptics.ddl.h"
#include "hdf5pp/CompoundType.h"
#include "hdf5pp/EnumType.h"
#include "hdf5pp/Utils.h"
#include "PSEvt/DataProxy.h"
namespace psddl_hdf2psana {
namespace OceanOptics {

hdf5pp::Type ns_ConfigV1_v0_dataset_config_stored_type()
{
  typedef ns_ConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("exposureTime", offsetof(DsType, exposureTime), hdf5pp::TypeTraits<float>::stored_type());
  type.insert("waveLenCalib", offsetof(DsType, waveLenCalib), hdf5pp::TypeTraits<double>::stored_type());
  type.insert("nonlinCorrect", offsetof(DsType, nonlinCorrect), hdf5pp::TypeTraits<double>::stored_type());
  type.insert("strayLightConstant", offsetof(DsType, strayLightConstant), hdf5pp::TypeTraits<double>::stored_type());
  return type;
}

hdf5pp::Type ns_ConfigV1_v0::dataset_config::stored_type()
{
  static hdf5pp::Type type = ns_ConfigV1_v0_dataset_config_stored_type();
  return type;
}

hdf5pp::Type ns_ConfigV1_v0_dataset_config_native_type()
{
  typedef ns_ConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("exposureTime", offsetof(DsType, exposureTime), hdf5pp::TypeTraits<float>::native_type());
  type.insert("waveLenCalib", offsetof(DsType, waveLenCalib), hdf5pp::TypeTraits<double>::native_type());
  type.insert("nonlinCorrect", offsetof(DsType, nonlinCorrect), hdf5pp::TypeTraits<double>::native_type());
  type.insert("strayLightConstant", offsetof(DsType, strayLightConstant), hdf5pp::TypeTraits<double>::native_type());
  return type;
}

hdf5pp::Type ns_ConfigV1_v0::dataset_config::native_type()
{
  static hdf5pp::Type type = ns_ConfigV1_v0_dataset_config_native_type();
  return type;
}
ns_ConfigV1_v0::dataset_config::dataset_config()
{
}
ns_ConfigV1_v0::dataset_config::~dataset_config()
{
}
float ConfigV1_v0::exposureTime() const {
  if (not m_ds_config.get()) read_ds_config();
  return float(m_ds_config->exposureTime);
}
ndarray<const double, 1> ConfigV1_v0::waveLenCalib() const {
  if (not m_ds_config.get()) read_ds_config();
  boost::shared_ptr<double> ptr(m_ds_config, m_ds_config->waveLenCalib);
  return make_ndarray(ptr, 4);
}
ndarray<const double, 1> ConfigV1_v0::nonlinCorrect() const {
  if (not m_ds_config.get()) read_ds_config();
  boost::shared_ptr<double> ptr(m_ds_config, m_ds_config->nonlinCorrect);
  return make_ndarray(ptr, 8);
}
double ConfigV1_v0::strayLightConstant() const {
  if (not m_ds_config.get()) read_ds_config();
  return double(m_ds_config->strayLightConstant);
}
void ConfigV1_v0::read_ds_config() const {
  m_ds_config = hdf5pp::Utils::readGroup<OceanOptics::ns_ConfigV1_v0::dataset_config>(m_group, "config", m_idx);
}
boost::shared_ptr<PSEvt::Proxy<Psana::OceanOptics::ConfigV1> > make_ConfigV1(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::OceanOptics::ConfigV1> >(boost::make_shared<ConfigV1_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::OceanOptics::ConfigV1> >(boost::shared_ptr<Psana::OceanOptics::ConfigV1>());
  }
}

hdf5pp::Type ns_timespec64_v0_dataset_data_stored_type()
{
  typedef ns_timespec64_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("tv_sec", offsetof(DsType, tv_sec), hdf5pp::TypeTraits<uint64_t>::stored_type());
  type.insert("tv_nsec", offsetof(DsType, tv_nsec), hdf5pp::TypeTraits<uint64_t>::stored_type());
  return type;
}

hdf5pp::Type ns_timespec64_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_timespec64_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_timespec64_v0_dataset_data_native_type()
{
  typedef ns_timespec64_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("tv_sec", offsetof(DsType, tv_sec), hdf5pp::TypeTraits<uint64_t>::native_type());
  type.insert("tv_nsec", offsetof(DsType, tv_nsec), hdf5pp::TypeTraits<uint64_t>::native_type());
  return type;
}

hdf5pp::Type ns_timespec64_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_timespec64_v0_dataset_data_native_type();
  return type;
}
ns_timespec64_v0::dataset_data::dataset_data()
{
}
ns_timespec64_v0::dataset_data::~dataset_data()
{
}
boost::shared_ptr<Psana::OceanOptics::timespec64>
Proxy_timespec64_v0::getTypedImpl(PSEvt::ProxyDictI* dict, const Pds::Src& source, const std::string& key)
{
  boost::shared_ptr<OceanOptics::ns_timespec64_v0::dataset_data> ds_data = hdf5pp::Utils::readGroup<OceanOptics::ns_timespec64_v0::dataset_data>(m_group, "data", m_idx);
  return boost::make_shared<PsanaType>(ds_data->tv_sec, ds_data->tv_nsec);
}

boost::shared_ptr<PSEvt::Proxy<Psana::OceanOptics::timespec64> > make_timespec64(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<Proxy_timespec64_v0>(group, idx);
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::OceanOptics::timespec64> >(boost::shared_ptr<Psana::OceanOptics::timespec64>());
  }
}

hdf5pp::Type ns_DataV1_v0_dataset_data_stored_type()
{
  typedef ns_DataV1_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("data", offsetof(DsType, data), hdf5pp::TypeTraits<uint16_t>::stored_type());
  type.insert("frameCounter", offsetof(DsType, frameCounter), hdf5pp::TypeTraits<uint64_t>::stored_type());
  type.insert("numDelayedFrames", offsetof(DsType, numDelayedFrames), hdf5pp::TypeTraits<uint64_t>::stored_type());
  type.insert("numDiscardFrames", offsetof(DsType, numDiscardFrames), hdf5pp::TypeTraits<uint64_t>::stored_type());
  type.insert("timeFrameStart", offsetof(DsType, timeFrameStart), hdf5pp::TypeTraits<OceanOptics::ns_timespec64_v0::dataset_data>::stored_type());
  type.insert("timeFrameFirstData", offsetof(DsType, timeFrameFirstData), hdf5pp::TypeTraits<OceanOptics::ns_timespec64_v0::dataset_data>::stored_type());
  type.insert("timeFrameEnd", offsetof(DsType, timeFrameEnd), hdf5pp::TypeTraits<OceanOptics::ns_timespec64_v0::dataset_data>::stored_type());
  type.insert("version", offsetof(DsType, version), hdf5pp::TypeTraits<int32_t>::stored_type());
  type.insert("numSpectraInData", offsetof(DsType, numSpectraInData), hdf5pp::TypeTraits<int8_t>::stored_type());
  type.insert("numSpectraInQueue", offsetof(DsType, numSpectraInQueue), hdf5pp::TypeTraits<int8_t>::stored_type());
  type.insert("numSpectraUnused", offsetof(DsType, numSpectraUnused), hdf5pp::TypeTraits<int8_t>::stored_type());
  return type;
}

hdf5pp::Type ns_DataV1_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_DataV1_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_DataV1_v0_dataset_data_native_type()
{
  typedef ns_DataV1_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("data", offsetof(DsType, data), hdf5pp::TypeTraits<uint16_t>::native_type());
  type.insert("frameCounter", offsetof(DsType, frameCounter), hdf5pp::TypeTraits<uint64_t>::native_type());
  type.insert("numDelayedFrames", offsetof(DsType, numDelayedFrames), hdf5pp::TypeTraits<uint64_t>::native_type());
  type.insert("numDiscardFrames", offsetof(DsType, numDiscardFrames), hdf5pp::TypeTraits<uint64_t>::native_type());
  type.insert("timeFrameStart", offsetof(DsType, timeFrameStart), hdf5pp::TypeTraits<OceanOptics::ns_timespec64_v0::dataset_data>::native_type());
  type.insert("timeFrameFirstData", offsetof(DsType, timeFrameFirstData), hdf5pp::TypeTraits<OceanOptics::ns_timespec64_v0::dataset_data>::native_type());
  type.insert("timeFrameEnd", offsetof(DsType, timeFrameEnd), hdf5pp::TypeTraits<OceanOptics::ns_timespec64_v0::dataset_data>::native_type());
  type.insert("version", offsetof(DsType, version), hdf5pp::TypeTraits<int32_t>::native_type());
  type.insert("numSpectraInData", offsetof(DsType, numSpectraInData), hdf5pp::TypeTraits<int8_t>::native_type());
  type.insert("numSpectraInQueue", offsetof(DsType, numSpectraInQueue), hdf5pp::TypeTraits<int8_t>::native_type());
  type.insert("numSpectraUnused", offsetof(DsType, numSpectraUnused), hdf5pp::TypeTraits<int8_t>::native_type());
  return type;
}

hdf5pp::Type ns_DataV1_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_DataV1_v0_dataset_data_native_type();
  return type;
}
ns_DataV1_v0::dataset_data::dataset_data()
{
}
ns_DataV1_v0::dataset_data::~dataset_data()
{
}
template <typename Config>
ndarray<const uint16_t, 1> DataV1_v0<Config>::data() const {
  if (not m_ds_data.get()) read_ds_data();
  boost::shared_ptr<uint16_t> ptr(m_ds_data, m_ds_data->data);
  return make_ndarray(ptr, iNumPixels);
}
template <typename Config>
uint64_t DataV1_v0<Config>::frameCounter() const {
  if (not m_ds_data.get()) read_ds_data();
  return uint64_t(m_ds_data->frameCounter);
}
template <typename Config>
uint64_t DataV1_v0<Config>::numDelayedFrames() const {
  if (not m_ds_data.get()) read_ds_data();
  return uint64_t(m_ds_data->numDelayedFrames);
}
template <typename Config>
uint64_t DataV1_v0<Config>::numDiscardFrames() const {
  if (not m_ds_data.get()) read_ds_data();
  return uint64_t(m_ds_data->numDiscardFrames);
}
template <typename Config>
const Psana::OceanOptics::timespec64& DataV1_v0<Config>::timeFrameStart() const {
  if (not m_ds_data.get()) read_ds_data();
  m_ds_storage_data_timeFrameStart = Psana::OceanOptics::timespec64(m_ds_data->timeFrameStart);
  return m_ds_storage_data_timeFrameStart;
}
template <typename Config>
const Psana::OceanOptics::timespec64& DataV1_v0<Config>::timeFrameFirstData() const {
  if (not m_ds_data.get()) read_ds_data();
  m_ds_storage_data_timeFrameFirstData = Psana::OceanOptics::timespec64(m_ds_data->timeFrameFirstData);
  return m_ds_storage_data_timeFrameFirstData;
}
template <typename Config>
const Psana::OceanOptics::timespec64& DataV1_v0<Config>::timeFrameEnd() const {
  if (not m_ds_data.get()) read_ds_data();
  m_ds_storage_data_timeFrameEnd = Psana::OceanOptics::timespec64(m_ds_data->timeFrameEnd);
  return m_ds_storage_data_timeFrameEnd;
}
template <typename Config>
int32_t DataV1_v0<Config>::version() const {
  if (not m_ds_data.get()) read_ds_data();
  return int32_t(m_ds_data->version);
}
template <typename Config>
int8_t DataV1_v0<Config>::numSpectraInData() const {
  if (not m_ds_data.get()) read_ds_data();
  return int8_t(m_ds_data->numSpectraInData);
}
template <typename Config>
int8_t DataV1_v0<Config>::numSpectraInQueue() const {
  if (not m_ds_data.get()) read_ds_data();
  return int8_t(m_ds_data->numSpectraInQueue);
}
template <typename Config>
int8_t DataV1_v0<Config>::numSpectraUnused() const {
  if (not m_ds_data.get()) read_ds_data();
  return int8_t(m_ds_data->numSpectraUnused);
}

template <typename Config>
double
DataV1_v0<Config>::nonlinerCorrected(uint32_t iPixel) const{ 
double fRawValue = (double) (this->data()[iPixel] ^ 0x2000);                     const ndarray<const double, 1>& corr = m_cfg->nonlinCorrect();                     return fRawValue / (                      corr[0] + fRawValue *                      (corr[1] + fRawValue *                      (corr[2] + fRawValue *                      (corr[3] + fRawValue *                      (corr[4] + fRawValue *                      (corr[5] + fRawValue *                      (corr[6] + fRawValue *                       corr[7]))))))); 
}
template <typename Config>
void DataV1_v0<Config>::read_ds_data() const {
  m_ds_data = hdf5pp::Utils::readGroup<OceanOptics::ns_DataV1_v0::dataset_data>(m_group, "data", m_idx);
}
template class DataV1_v0<Psana::OceanOptics::ConfigV1>;
boost::shared_ptr<PSEvt::Proxy<Psana::OceanOptics::DataV1> > make_DataV1(int version, hdf5pp::Group group, hsize_t idx, const boost::shared_ptr<Psana::OceanOptics::ConfigV1>& cfg) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::OceanOptics::DataV1> >(boost::make_shared<DataV1_v0<Psana::OceanOptics::ConfigV1> >(group, idx, cfg));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::OceanOptics::DataV1> >(boost::shared_ptr<Psana::OceanOptics::DataV1>());
  }
}
} // namespace OceanOptics
} // namespace psddl_hdf2psana
