
// *** Do not edit this file, it is auto-generated ***

#include "psddl_hdf2psana/evr.ddl.h"
#include "hdf5pp/ArrayType.h"
#include "hdf5pp/CompoundType.h"
#include "hdf5pp/EnumType.h"
#include "hdf5pp/VlenType.h"
#include "hdf5pp/Utils.h"
#include "PSEvt/DataProxy.h"
#include "psddl_hdf2psana/Exceptions.h"
#include "psddl_hdf2psana/evr.h"
namespace psddl_hdf2psana {
namespace EvrData {

hdf5pp::Type ns_PulseConfig_v0_dataset_data_stored_type()
{
  typedef ns_PulseConfig_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("pulse", offsetof(DsType, pulse), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("_input_control_value", offsetof(DsType, _input_control_value), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("_output_control_value", offsetof(DsType, _output_control_value), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("polarity", offsetof(DsType, polarity), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("map_set_enable", offsetof(DsType, map_set_enable), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("map_reset_enable", offsetof(DsType, map_reset_enable), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("map_trigger_enable", offsetof(DsType, map_trigger_enable), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("prescale", offsetof(DsType, prescale), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("delay", offsetof(DsType, delay), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("width", offsetof(DsType, width), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("trigger", offsetof(DsType, trigger), hdf5pp::TypeTraits<int16_t>::stored_type());
  type.insert("set", offsetof(DsType, set), hdf5pp::TypeTraits<int16_t>::stored_type());
  type.insert("clear", offsetof(DsType, clear), hdf5pp::TypeTraits<int16_t>::stored_type());
  return type;
}

hdf5pp::Type ns_PulseConfig_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_PulseConfig_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_PulseConfig_v0_dataset_data_native_type()
{
  typedef ns_PulseConfig_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("pulse", offsetof(DsType, pulse), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("_input_control_value", offsetof(DsType, _input_control_value), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("_output_control_value", offsetof(DsType, _output_control_value), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("polarity", offsetof(DsType, polarity), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("map_set_enable", offsetof(DsType, map_set_enable), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("map_reset_enable", offsetof(DsType, map_reset_enable), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("map_trigger_enable", offsetof(DsType, map_trigger_enable), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("prescale", offsetof(DsType, prescale), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("delay", offsetof(DsType, delay), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("width", offsetof(DsType, width), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("trigger", offsetof(DsType, trigger), hdf5pp::TypeTraits<int16_t>::native_type());
  type.insert("set", offsetof(DsType, set), hdf5pp::TypeTraits<int16_t>::native_type());
  type.insert("clear", offsetof(DsType, clear), hdf5pp::TypeTraits<int16_t>::native_type());
  return type;
}

hdf5pp::Type ns_PulseConfig_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_PulseConfig_v0_dataset_data_native_type();
  return type;
}

ns_PulseConfig_v0::dataset_data::dataset_data()
{
}

ns_PulseConfig_v0::dataset_data::dataset_data(const Psana::EvrData::PulseConfig& psanaobj)
  : pulse(psanaobj.pulse())
  , _input_control_value(psanaobj._input_control_value())
  , _output_control_value(psanaobj._output_control_value())
  , polarity(psanaobj.polarity())
  , map_set_enable(psanaobj.map_set_enable())
  , map_reset_enable(psanaobj.map_reset_enable())
  , map_trigger_enable(psanaobj.map_trigger_enable())
  , prescale(psanaobj.prescale())
  , delay(psanaobj.delay())
  , width(psanaobj.width())
  , trigger(psanaobj.trigger())
  , set(psanaobj.set())
  , clear(psanaobj.clear())
{
}

ns_PulseConfig_v0::dataset_data::~dataset_data()
{
}

hdf5pp::Type ns_PulseConfigV3_v0_dataset_data_stored_type()
{
  typedef ns_PulseConfigV3_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("pulseId", offsetof(DsType, pulseId), hdf5pp::TypeTraits<uint16_t>::stored_type());
  type.insert("polarity", offsetof(DsType, polarity), hdf5pp::TypeTraits<uint16_t>::stored_type());
  type.insert("prescale", offsetof(DsType, prescale), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("delay", offsetof(DsType, delay), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("width", offsetof(DsType, width), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_PulseConfigV3_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_PulseConfigV3_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_PulseConfigV3_v0_dataset_data_native_type()
{
  typedef ns_PulseConfigV3_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("pulseId", offsetof(DsType, pulseId), hdf5pp::TypeTraits<uint16_t>::native_type());
  type.insert("polarity", offsetof(DsType, polarity), hdf5pp::TypeTraits<uint16_t>::native_type());
  type.insert("prescale", offsetof(DsType, prescale), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("delay", offsetof(DsType, delay), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("width", offsetof(DsType, width), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_PulseConfigV3_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_PulseConfigV3_v0_dataset_data_native_type();
  return type;
}

ns_PulseConfigV3_v0::dataset_data::dataset_data()
{
}

ns_PulseConfigV3_v0::dataset_data::dataset_data(const Psana::EvrData::PulseConfigV3& psanaobj)
  : pulseId(psanaobj.pulseId())
  , polarity(psanaobj.polarity())
  , prescale(psanaobj.prescale())
  , delay(psanaobj.delay())
  , width(psanaobj.width())
{
}

ns_PulseConfigV3_v0::dataset_data::~dataset_data()
{
}

hdf5pp::Type ns_EventCodeV3_v0_dataset_data_stored_type()
{
  typedef ns_EventCodeV3_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("code", offsetof(DsType, code), hdf5pp::TypeTraits<uint16_t>::stored_type());
  type.insert("isReadout", offsetof(DsType, isReadout), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("isTerminator", offsetof(DsType, isTerminator), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("maskTrigger", offsetof(DsType, maskTrigger), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("maskSet", offsetof(DsType, maskSet), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("maskClear", offsetof(DsType, maskClear), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_EventCodeV3_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_EventCodeV3_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_EventCodeV3_v0_dataset_data_native_type()
{
  typedef ns_EventCodeV3_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("code", offsetof(DsType, code), hdf5pp::TypeTraits<uint16_t>::native_type());
  type.insert("isReadout", offsetof(DsType, isReadout), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("isTerminator", offsetof(DsType, isTerminator), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("maskTrigger", offsetof(DsType, maskTrigger), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("maskSet", offsetof(DsType, maskSet), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("maskClear", offsetof(DsType, maskClear), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_EventCodeV3_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_EventCodeV3_v0_dataset_data_native_type();
  return type;
}

ns_EventCodeV3_v0::dataset_data::dataset_data()
{
}

ns_EventCodeV3_v0::dataset_data::dataset_data(const Psana::EvrData::EventCodeV3& psanaobj)
  : code(psanaobj.code())
  , isReadout(psanaobj.isReadout())
  , isTerminator(psanaobj.isTerminator())
  , maskTrigger(psanaobj.maskTrigger())
  , maskSet(psanaobj.maskSet())
  , maskClear(psanaobj.maskClear())
{
}

ns_EventCodeV3_v0::dataset_data::~dataset_data()
{
}

hdf5pp::Type ns_EventCodeV4_v0_dataset_data_stored_type()
{
  typedef ns_EventCodeV4_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("code", offsetof(DsType, code), hdf5pp::TypeTraits<uint16_t>::stored_type());
  type.insert("isReadout", offsetof(DsType, isReadout), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("isTerminator", offsetof(DsType, isTerminator), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("reportDelay", offsetof(DsType, reportDelay), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("reportWidth", offsetof(DsType, reportWidth), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("maskTrigger", offsetof(DsType, maskTrigger), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("maskSet", offsetof(DsType, maskSet), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("maskClear", offsetof(DsType, maskClear), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_EventCodeV4_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_EventCodeV4_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_EventCodeV4_v0_dataset_data_native_type()
{
  typedef ns_EventCodeV4_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("code", offsetof(DsType, code), hdf5pp::TypeTraits<uint16_t>::native_type());
  type.insert("isReadout", offsetof(DsType, isReadout), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("isTerminator", offsetof(DsType, isTerminator), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("reportDelay", offsetof(DsType, reportDelay), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("reportWidth", offsetof(DsType, reportWidth), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("maskTrigger", offsetof(DsType, maskTrigger), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("maskSet", offsetof(DsType, maskSet), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("maskClear", offsetof(DsType, maskClear), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_EventCodeV4_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_EventCodeV4_v0_dataset_data_native_type();
  return type;
}

ns_EventCodeV4_v0::dataset_data::dataset_data()
{
}

ns_EventCodeV4_v0::dataset_data::dataset_data(const Psana::EvrData::EventCodeV4& psanaobj)
  : code(psanaobj.code())
  , isReadout(psanaobj.isReadout())
  , isTerminator(psanaobj.isTerminator())
  , reportDelay(psanaobj.reportDelay())
  , reportWidth(psanaobj.reportWidth())
  , maskTrigger(psanaobj.maskTrigger())
  , maskSet(psanaobj.maskSet())
  , maskClear(psanaobj.maskClear())
{
}

ns_EventCodeV4_v0::dataset_data::~dataset_data()
{
}

hdf5pp::Type ns_EventCodeV5_v0_dataset_data_stored_type()
{
  typedef ns_EventCodeV5_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("code", offsetof(DsType, code), hdf5pp::TypeTraits<uint16_t>::stored_type());
  type.insert("isReadout", offsetof(DsType, isReadout), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("isCommand", offsetof(DsType, isCommand), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("isLatch", offsetof(DsType, isLatch), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("reportDelay", offsetof(DsType, reportDelay), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("reportWidth", offsetof(DsType, reportWidth), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("maskTrigger", offsetof(DsType, maskTrigger), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("maskSet", offsetof(DsType, maskSet), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("maskClear", offsetof(DsType, maskClear), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("desc", offsetof(DsType, desc), hdf5pp::TypeTraits<const char*>::stored_type());
  type.insert("releaseCode", offsetof(DsType, releaseCode), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_EventCodeV5_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_EventCodeV5_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_EventCodeV5_v0_dataset_data_native_type()
{
  typedef ns_EventCodeV5_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("code", offsetof(DsType, code), hdf5pp::TypeTraits<uint16_t>::native_type());
  type.insert("isReadout", offsetof(DsType, isReadout), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("isCommand", offsetof(DsType, isCommand), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("isLatch", offsetof(DsType, isLatch), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("reportDelay", offsetof(DsType, reportDelay), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("reportWidth", offsetof(DsType, reportWidth), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("maskTrigger", offsetof(DsType, maskTrigger), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("maskSet", offsetof(DsType, maskSet), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("maskClear", offsetof(DsType, maskClear), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("desc", offsetof(DsType, desc), hdf5pp::TypeTraits<const char*>::native_type());
  type.insert("releaseCode", offsetof(DsType, releaseCode), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_EventCodeV5_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_EventCodeV5_v0_dataset_data_native_type();
  return type;
}

ns_EventCodeV5_v0::dataset_data::dataset_data()
{
}

ns_EventCodeV5_v0::dataset_data::dataset_data(const Psana::EvrData::EventCodeV5& psanaobj)
  : code(psanaobj.code())
  , isReadout(psanaobj.isReadout())
  , isCommand(psanaobj.isCommand())
  , isLatch(psanaobj.isLatch())
  , reportDelay(psanaobj.reportDelay())
  , reportWidth(psanaobj.reportWidth())
  , maskTrigger(psanaobj.maskTrigger())
  , maskSet(psanaobj.maskSet())
  , maskClear(psanaobj.maskClear())
  , desc(0)
  , releaseCode(psanaobj.releaseCode())
{
  desc = strdup(psanaobj.desc());
}

ns_EventCodeV5_v0::dataset_data::~dataset_data()
{
}

hdf5pp::Type ns_EventCodeV6_v0_dataset_data_stored_type()
{
  typedef ns_EventCodeV6_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("code", offsetof(DsType, code), hdf5pp::TypeTraits<uint16_t>::stored_type());
  type.insert("isReadout", offsetof(DsType, isReadout), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("isCommand", offsetof(DsType, isCommand), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("isLatch", offsetof(DsType, isLatch), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("reportDelay", offsetof(DsType, reportDelay), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("reportWidth", offsetof(DsType, reportWidth), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("maskTrigger", offsetof(DsType, maskTrigger), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("maskSet", offsetof(DsType, maskSet), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("maskClear", offsetof(DsType, maskClear), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("desc", offsetof(DsType, desc), hdf5pp::TypeTraits<const char*>::stored_type());
  type.insert("readoutGroup", offsetof(DsType, readoutGroup), hdf5pp::TypeTraits<uint16_t>::stored_type());
  type.insert("releaseCode", offsetof(DsType, releaseCode), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_EventCodeV6_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_EventCodeV6_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_EventCodeV6_v0_dataset_data_native_type()
{
  typedef ns_EventCodeV6_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("code", offsetof(DsType, code), hdf5pp::TypeTraits<uint16_t>::native_type());
  type.insert("isReadout", offsetof(DsType, isReadout), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("isCommand", offsetof(DsType, isCommand), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("isLatch", offsetof(DsType, isLatch), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("reportDelay", offsetof(DsType, reportDelay), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("reportWidth", offsetof(DsType, reportWidth), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("maskTrigger", offsetof(DsType, maskTrigger), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("maskSet", offsetof(DsType, maskSet), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("maskClear", offsetof(DsType, maskClear), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("desc", offsetof(DsType, desc), hdf5pp::TypeTraits<const char*>::native_type());
  type.insert("readoutGroup", offsetof(DsType, readoutGroup), hdf5pp::TypeTraits<uint16_t>::native_type());
  type.insert("releaseCode", offsetof(DsType, releaseCode), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_EventCodeV6_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_EventCodeV6_v0_dataset_data_native_type();
  return type;
}

ns_EventCodeV6_v0::dataset_data::dataset_data()
{
}

ns_EventCodeV6_v0::dataset_data::dataset_data(const Psana::EvrData::EventCodeV6& psanaobj)
  : code(psanaobj.code())
  , isReadout(psanaobj.isReadout())
  , isCommand(psanaobj.isCommand())
  , isLatch(psanaobj.isLatch())
  , reportDelay(psanaobj.reportDelay())
  , reportWidth(psanaobj.reportWidth())
  , maskTrigger(psanaobj.maskTrigger())
  , maskSet(psanaobj.maskSet())
  , maskClear(psanaobj.maskClear())
  , desc(0)
  , readoutGroup(psanaobj.readoutGroup())
  , releaseCode(psanaobj.releaseCode())
{
  desc = strdup(psanaobj.desc());
}

ns_EventCodeV6_v0::dataset_data::~dataset_data()
{
}

hdf5pp::Type ns_SrcEventCode_v0_dataset_data_stored_type()
{
  typedef ns_SrcEventCode_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("code", offsetof(DsType, code), hdf5pp::TypeTraits<uint16_t>::stored_type());
  type.insert("period", offsetof(DsType, period), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("maskTriggerP", offsetof(DsType, maskTriggerP), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("maskTriggerR", offsetof(DsType, maskTriggerR), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("desc", offsetof(DsType, desc), hdf5pp::TypeTraits<const char*>::stored_type());
  type.insert("readoutGroup", offsetof(DsType, readoutGroup), hdf5pp::TypeTraits<uint16_t>::stored_type());
  return type;
}

hdf5pp::Type ns_SrcEventCode_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_SrcEventCode_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_SrcEventCode_v0_dataset_data_native_type()
{
  typedef ns_SrcEventCode_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("code", offsetof(DsType, code), hdf5pp::TypeTraits<uint16_t>::native_type());
  type.insert("period", offsetof(DsType, period), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("maskTriggerP", offsetof(DsType, maskTriggerP), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("maskTriggerR", offsetof(DsType, maskTriggerR), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("desc", offsetof(DsType, desc), hdf5pp::TypeTraits<const char*>::native_type());
  type.insert("readoutGroup", offsetof(DsType, readoutGroup), hdf5pp::TypeTraits<uint16_t>::native_type());
  return type;
}

hdf5pp::Type ns_SrcEventCode_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_SrcEventCode_v0_dataset_data_native_type();
  return type;
}

ns_SrcEventCode_v0::dataset_data::dataset_data()
{
}

ns_SrcEventCode_v0::dataset_data::dataset_data(const Psana::EvrData::SrcEventCode& psanaobj)
  : code(psanaobj.code())
  , period(psanaobj.period())
  , maskTriggerP(psanaobj.maskTriggerP())
  , maskTriggerR(psanaobj.maskTriggerR())
  , desc(0)
  , readoutGroup(psanaobj.readoutGroup())
{
  desc = strdup(psanaobj.desc());
}

ns_SrcEventCode_v0::dataset_data::~dataset_data()
{
}
boost::shared_ptr<Psana::EvrData::SrcEventCode>
Proxy_SrcEventCode_v0::getTypedImpl(PSEvt::ProxyDictI* dict, const Pds::Src& source, const std::string& key)
{
  if (not m_data) {
    boost::shared_ptr<EvrData::ns_SrcEventCode_v0::dataset_data> ds_data = hdf5pp::Utils::readGroup<EvrData::ns_SrcEventCode_v0::dataset_data>(m_group, "data", m_idx);
    m_data.reset(new PsanaType(ds_data->code, ds_data->period, ds_data->maskTriggerP, ds_data->maskTriggerR, ds_data->desc, ds_data->readoutGroup));
  }
  return m_data;
}


void make_datasets_SrcEventCode_v0(const Psana::EvrData::SrcEventCode& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = EvrData::ns_SrcEventCode_v0::dataset_data::stored_type();
    hdf5pp::Utils::createDataset(group, "data", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_SrcEventCode_v0(const Psana::EvrData::SrcEventCode* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    EvrData::ns_SrcEventCode_v0::dataset_data ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "data", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "data", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "data", index < 0 ? index : index + 1);
  }
}

boost::shared_ptr<PSEvt::Proxy<Psana::EvrData::SrcEventCode> > make_SrcEventCode(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<Proxy_SrcEventCode_v0>(group, idx);
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::SrcEventCode> >(boost::shared_ptr<Psana::EvrData::SrcEventCode>());
  }
}

void make_datasets(const Psana::EvrData::SrcEventCode& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_SrcEventCode_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.SrcEventCode", version);
  }
}

void store_SrcEventCode(const Psana::EvrData::SrcEventCode* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_SrcEventCode_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.SrcEventCode", version);
  }
}

void store(const Psana::EvrData::SrcEventCode& obj, hdf5pp::Group group, int version) 
{
  store_SrcEventCode(&obj, group, 0, version, false);
}

void store_at(const Psana::EvrData::SrcEventCode* obj, hdf5pp::Group group, long index, int version)
{
  store_SrcEventCode(obj, group, index, version, true);
}


hdf5pp::Type ns_OutputMap_v0_dataset_data_stored_type()
{
  typedef ns_OutputMap_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  hdf5pp::EnumType<int16_t> _enum_type_source = hdf5pp::EnumType<int16_t>::enumType();
  _enum_type_source.insert("Pulse", Psana::EvrData::OutputMap::Pulse);
  _enum_type_source.insert("DBus", Psana::EvrData::OutputMap::DBus);
  _enum_type_source.insert("Prescaler", Psana::EvrData::OutputMap::Prescaler);
  _enum_type_source.insert("Force_High", Psana::EvrData::OutputMap::Force_High);
  _enum_type_source.insert("Force_Low", Psana::EvrData::OutputMap::Force_Low);
  type.insert("source", offsetof(DsType, source), _enum_type_source);
  type.insert("source_id", offsetof(DsType, source_id), hdf5pp::TypeTraits<uint8_t>::stored_type());
  hdf5pp::EnumType<int16_t> _enum_type_conn = hdf5pp::EnumType<int16_t>::enumType();
  _enum_type_conn.insert("FrontPanel", Psana::EvrData::OutputMap::FrontPanel);
  _enum_type_conn.insert("UnivIO", Psana::EvrData::OutputMap::UnivIO);
  type.insert("conn", offsetof(DsType, conn), _enum_type_conn);
  type.insert("conn_id", offsetof(DsType, conn_id), hdf5pp::TypeTraits<uint8_t>::stored_type());
  return type;
}

hdf5pp::Type ns_OutputMap_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_OutputMap_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_OutputMap_v0_dataset_data_native_type()
{
  typedef ns_OutputMap_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  hdf5pp::EnumType<int16_t> _enum_type_source = hdf5pp::EnumType<int16_t>::enumType();
  _enum_type_source.insert("Pulse", Psana::EvrData::OutputMap::Pulse);
  _enum_type_source.insert("DBus", Psana::EvrData::OutputMap::DBus);
  _enum_type_source.insert("Prescaler", Psana::EvrData::OutputMap::Prescaler);
  _enum_type_source.insert("Force_High", Psana::EvrData::OutputMap::Force_High);
  _enum_type_source.insert("Force_Low", Psana::EvrData::OutputMap::Force_Low);
  type.insert("source", offsetof(DsType, source), _enum_type_source);
  type.insert("source_id", offsetof(DsType, source_id), hdf5pp::TypeTraits<uint8_t>::native_type());
  hdf5pp::EnumType<int16_t> _enum_type_conn = hdf5pp::EnumType<int16_t>::enumType();
  _enum_type_conn.insert("FrontPanel", Psana::EvrData::OutputMap::FrontPanel);
  _enum_type_conn.insert("UnivIO", Psana::EvrData::OutputMap::UnivIO);
  type.insert("conn", offsetof(DsType, conn), _enum_type_conn);
  type.insert("conn_id", offsetof(DsType, conn_id), hdf5pp::TypeTraits<uint8_t>::native_type());
  return type;
}

hdf5pp::Type ns_OutputMap_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_OutputMap_v0_dataset_data_native_type();
  return type;
}

ns_OutputMap_v0::dataset_data::dataset_data()
{
}

ns_OutputMap_v0::dataset_data::dataset_data(const Psana::EvrData::OutputMap& psanaobj)
  : source(psanaobj.source())
  , source_id(psanaobj.source_id())
  , conn(psanaobj.conn())
  , conn_id(psanaobj.conn_id())
{
}

ns_OutputMap_v0::dataset_data::~dataset_data()
{
}

hdf5pp::Type ns_OutputMapV2_v0_dataset_data_stored_type()
{
  typedef ns_OutputMapV2_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  hdf5pp::EnumType<int16_t> _enum_type_source = hdf5pp::EnumType<int16_t>::enumType();
  _enum_type_source.insert("Pulse", Psana::EvrData::OutputMapV2::Pulse);
  _enum_type_source.insert("DBus", Psana::EvrData::OutputMapV2::DBus);
  _enum_type_source.insert("Prescaler", Psana::EvrData::OutputMapV2::Prescaler);
  _enum_type_source.insert("Force_High", Psana::EvrData::OutputMapV2::Force_High);
  _enum_type_source.insert("Force_Low", Psana::EvrData::OutputMapV2::Force_Low);
  type.insert("source", offsetof(DsType, source), _enum_type_source);
  type.insert("source_id", offsetof(DsType, source_id), hdf5pp::TypeTraits<uint8_t>::stored_type());
  hdf5pp::EnumType<int16_t> _enum_type_conn = hdf5pp::EnumType<int16_t>::enumType();
  _enum_type_conn.insert("FrontPanel", Psana::EvrData::OutputMapV2::FrontPanel);
  _enum_type_conn.insert("UnivIO", Psana::EvrData::OutputMapV2::UnivIO);
  type.insert("conn", offsetof(DsType, conn), _enum_type_conn);
  type.insert("conn_id", offsetof(DsType, conn_id), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("module", offsetof(DsType, module), hdf5pp::TypeTraits<uint8_t>::stored_type());
  return type;
}

hdf5pp::Type ns_OutputMapV2_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_OutputMapV2_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_OutputMapV2_v0_dataset_data_native_type()
{
  typedef ns_OutputMapV2_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  hdf5pp::EnumType<int16_t> _enum_type_source = hdf5pp::EnumType<int16_t>::enumType();
  _enum_type_source.insert("Pulse", Psana::EvrData::OutputMapV2::Pulse);
  _enum_type_source.insert("DBus", Psana::EvrData::OutputMapV2::DBus);
  _enum_type_source.insert("Prescaler", Psana::EvrData::OutputMapV2::Prescaler);
  _enum_type_source.insert("Force_High", Psana::EvrData::OutputMapV2::Force_High);
  _enum_type_source.insert("Force_Low", Psana::EvrData::OutputMapV2::Force_Low);
  type.insert("source", offsetof(DsType, source), _enum_type_source);
  type.insert("source_id", offsetof(DsType, source_id), hdf5pp::TypeTraits<uint8_t>::native_type());
  hdf5pp::EnumType<int16_t> _enum_type_conn = hdf5pp::EnumType<int16_t>::enumType();
  _enum_type_conn.insert("FrontPanel", Psana::EvrData::OutputMapV2::FrontPanel);
  _enum_type_conn.insert("UnivIO", Psana::EvrData::OutputMapV2::UnivIO);
  type.insert("conn", offsetof(DsType, conn), _enum_type_conn);
  type.insert("conn_id", offsetof(DsType, conn_id), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("module", offsetof(DsType, module), hdf5pp::TypeTraits<uint8_t>::native_type());
  return type;
}

hdf5pp::Type ns_OutputMapV2_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_OutputMapV2_v0_dataset_data_native_type();
  return type;
}

ns_OutputMapV2_v0::dataset_data::dataset_data()
{
}

ns_OutputMapV2_v0::dataset_data::dataset_data(const Psana::EvrData::OutputMapV2& psanaobj)
  : source(psanaobj.source())
  , source_id(psanaobj.source_id())
  , conn(psanaobj.conn())
  , conn_id(psanaobj.conn_id())
  , module(psanaobj.module())
{
}

ns_OutputMapV2_v0::dataset_data::~dataset_data()
{
}

hdf5pp::Type ns_ConfigV1_v0_dataset_config_stored_type()
{
  typedef ns_ConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("npulses", offsetof(DsType, npulses), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("noutputs", offsetof(DsType, noutputs), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_ConfigV1_v0::dataset_config::stored_type()
{
  static hdf5pp::Type type = ns_ConfigV1_v0_dataset_config_stored_type();
  return type;
}

hdf5pp::Type ns_ConfigV1_v0_dataset_config_native_type()
{
  typedef ns_ConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("npulses", offsetof(DsType, npulses), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("noutputs", offsetof(DsType, noutputs), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_ConfigV1_v0::dataset_config::native_type()
{
  static hdf5pp::Type type = ns_ConfigV1_v0_dataset_config_native_type();
  return type;
}

ns_ConfigV1_v0::dataset_config::dataset_config()
{
}

ns_ConfigV1_v0::dataset_config::dataset_config(const Psana::EvrData::ConfigV1& psanaobj)
  : npulses(psanaobj.npulses())
  , noutputs(psanaobj.noutputs())
{
}

ns_ConfigV1_v0::dataset_config::~dataset_config()
{
}
uint32_t ConfigV1_v0::npulses() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->npulses);
}
uint32_t ConfigV1_v0::noutputs() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->noutputs);
}
ndarray<const Psana::EvrData::PulseConfig, 1> ConfigV1_v0::pulses() const {
  if (m_ds_pulses.empty()) read_ds_pulses();
  return m_ds_pulses;
}
ndarray<const Psana::EvrData::OutputMap, 1> ConfigV1_v0::output_maps() const {
  if (m_ds_output_maps.empty()) read_ds_output_maps();
  return m_ds_output_maps;
}
void ConfigV1_v0::read_ds_config() const {
  m_ds_config = hdf5pp::Utils::readGroup<EvrData::ns_ConfigV1_v0::dataset_config>(m_group, "config", m_idx);
}
void ConfigV1_v0::read_ds_pulses() const {
  ndarray<EvrData::ns_PulseConfig_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_PulseConfig_v0::dataset_data, 1>(m_group, "pulses", m_idx);
  ndarray<Psana::EvrData::PulseConfig, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_pulses = tmp;
}
void ConfigV1_v0::read_ds_output_maps() const {
  ndarray<EvrData::ns_OutputMap_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_OutputMap_v0::dataset_data, 1>(m_group, "output_maps", m_idx);
  ndarray<Psana::EvrData::OutputMap, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_output_maps = tmp;
}

void make_datasets_ConfigV1_v0(const Psana::EvrData::ConfigV1& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = EvrData::ns_ConfigV1_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.pulses()) PsanaArray;
    const PsanaArray& psana_array = obj.pulses();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_PulseConfig_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "pulses", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.output_maps()) PsanaArray;
    const PsanaArray& psana_array = obj.output_maps();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_OutputMap_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "output_maps", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_ConfigV1_v0(const Psana::EvrData::ConfigV1* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    EvrData::ns_ConfigV1_v0::dataset_config ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "config", index < 0 ? index : index + 1);
  }
  if (obj) {
    typedef __typeof__(obj->pulses()) PsanaArray;
    typedef ndarray<EvrData::ns_PulseConfig_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->pulses();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_PulseConfig_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "pulses", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "pulses", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "pulses", index < 0 ? index : index + 1);
  }

  if (obj) {
    typedef __typeof__(obj->output_maps()) PsanaArray;
    typedef ndarray<EvrData::ns_OutputMap_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->output_maps();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_OutputMap_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "output_maps", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "output_maps", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "output_maps", index < 0 ? index : index + 1);
  }

}

boost::shared_ptr<PSEvt::Proxy<Psana::EvrData::ConfigV1> > make_ConfigV1(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::ConfigV1> >(boost::make_shared<ConfigV1_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::ConfigV1> >(boost::shared_ptr<Psana::EvrData::ConfigV1>());
  }
}

void make_datasets(const Psana::EvrData::ConfigV1& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_ConfigV1_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.ConfigV1", version);
  }
}

void store_ConfigV1(const Psana::EvrData::ConfigV1* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_ConfigV1_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.ConfigV1", version);
  }
}

void store(const Psana::EvrData::ConfigV1& obj, hdf5pp::Group group, int version) 
{
  store_ConfigV1(&obj, group, 0, version, false);
}

void store_at(const Psana::EvrData::ConfigV1* obj, hdf5pp::Group group, long index, int version)
{
  store_ConfigV1(obj, group, index, version, true);
}


hdf5pp::Type ns_ConfigV2_v0_dataset_config_stored_type()
{
  typedef ns_ConfigV2_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("opcode", offsetof(DsType, opcode), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("npulses", offsetof(DsType, npulses), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("noutputs", offsetof(DsType, noutputs), hdf5pp::TypeTraits<uint32_t>::stored_type());
  hdf5pp::EnumType<int16_t> _enum_type_beam = hdf5pp::EnumType<int16_t>::enumType();
  _enum_type_beam.insert("Off", Psana::EvrData::ConfigV2::Off);
  _enum_type_beam.insert("On", Psana::EvrData::ConfigV2::On);
  type.insert("beam", offsetof(DsType, beam), _enum_type_beam);
  hdf5pp::EnumType<int16_t> _enum_type_rate = hdf5pp::EnumType<int16_t>::enumType();
  _enum_type_rate.insert("r120Hz", Psana::EvrData::ConfigV2::r120Hz);
  _enum_type_rate.insert("r60Hz", Psana::EvrData::ConfigV2::r60Hz);
  _enum_type_rate.insert("r30Hz", Psana::EvrData::ConfigV2::r30Hz);
  _enum_type_rate.insert("r10Hz", Psana::EvrData::ConfigV2::r10Hz);
  _enum_type_rate.insert("r5Hz", Psana::EvrData::ConfigV2::r5Hz);
  _enum_type_rate.insert("r1Hz", Psana::EvrData::ConfigV2::r1Hz);
  _enum_type_rate.insert("r0_5Hz", Psana::EvrData::ConfigV2::r0_5Hz);
  _enum_type_rate.insert("Single", Psana::EvrData::ConfigV2::Single);
  _enum_type_rate.insert("NumberOfRates", Psana::EvrData::ConfigV2::NumberOfRates);
  type.insert("rate", offsetof(DsType, rate), _enum_type_rate);
  return type;
}

hdf5pp::Type ns_ConfigV2_v0::dataset_config::stored_type()
{
  static hdf5pp::Type type = ns_ConfigV2_v0_dataset_config_stored_type();
  return type;
}

hdf5pp::Type ns_ConfigV2_v0_dataset_config_native_type()
{
  typedef ns_ConfigV2_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("opcode", offsetof(DsType, opcode), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("npulses", offsetof(DsType, npulses), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("noutputs", offsetof(DsType, noutputs), hdf5pp::TypeTraits<uint32_t>::native_type());
  hdf5pp::EnumType<int16_t> _enum_type_beam = hdf5pp::EnumType<int16_t>::enumType();
  _enum_type_beam.insert("Off", Psana::EvrData::ConfigV2::Off);
  _enum_type_beam.insert("On", Psana::EvrData::ConfigV2::On);
  type.insert("beam", offsetof(DsType, beam), _enum_type_beam);
  hdf5pp::EnumType<int16_t> _enum_type_rate = hdf5pp::EnumType<int16_t>::enumType();
  _enum_type_rate.insert("r120Hz", Psana::EvrData::ConfigV2::r120Hz);
  _enum_type_rate.insert("r60Hz", Psana::EvrData::ConfigV2::r60Hz);
  _enum_type_rate.insert("r30Hz", Psana::EvrData::ConfigV2::r30Hz);
  _enum_type_rate.insert("r10Hz", Psana::EvrData::ConfigV2::r10Hz);
  _enum_type_rate.insert("r5Hz", Psana::EvrData::ConfigV2::r5Hz);
  _enum_type_rate.insert("r1Hz", Psana::EvrData::ConfigV2::r1Hz);
  _enum_type_rate.insert("r0_5Hz", Psana::EvrData::ConfigV2::r0_5Hz);
  _enum_type_rate.insert("Single", Psana::EvrData::ConfigV2::Single);
  _enum_type_rate.insert("NumberOfRates", Psana::EvrData::ConfigV2::NumberOfRates);
  type.insert("rate", offsetof(DsType, rate), _enum_type_rate);
  return type;
}

hdf5pp::Type ns_ConfigV2_v0::dataset_config::native_type()
{
  static hdf5pp::Type type = ns_ConfigV2_v0_dataset_config_native_type();
  return type;
}

ns_ConfigV2_v0::dataset_config::dataset_config()
{
}

ns_ConfigV2_v0::dataset_config::dataset_config(const Psana::EvrData::ConfigV2& psanaobj)
  : opcode(psanaobj.opcode())
  , npulses(psanaobj.npulses())
  , noutputs(psanaobj.noutputs())
  , beam(psanaobj.beam())
  , rate(psanaobj.rate())
{
}

ns_ConfigV2_v0::dataset_config::~dataset_config()
{
}
uint32_t ConfigV2_v0::opcode() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->opcode);
}
uint32_t ConfigV2_v0::npulses() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->npulses);
}
uint32_t ConfigV2_v0::noutputs() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->noutputs);
}
ndarray<const Psana::EvrData::PulseConfig, 1> ConfigV2_v0::pulses() const {
  if (m_ds_pulses.empty()) read_ds_pulses();
  return m_ds_pulses;
}
ndarray<const Psana::EvrData::OutputMap, 1> ConfigV2_v0::output_maps() const {
  if (m_ds_output_maps.empty()) read_ds_output_maps();
  return m_ds_output_maps;
}
Psana::EvrData::ConfigV2::BeamCode ConfigV2_v0::beam() const {
  if (not m_ds_config) read_ds_config();
  return Psana::EvrData::ConfigV2::BeamCode(m_ds_config->beam);
}
Psana::EvrData::ConfigV2::RateCode ConfigV2_v0::rate() const {
  if (not m_ds_config) read_ds_config();
  return Psana::EvrData::ConfigV2::RateCode(m_ds_config->rate);
}
void ConfigV2_v0::read_ds_config() const {
  m_ds_config = hdf5pp::Utils::readGroup<EvrData::ns_ConfigV2_v0::dataset_config>(m_group, "config", m_idx);
}
void ConfigV2_v0::read_ds_pulses() const {
  ndarray<EvrData::ns_PulseConfig_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_PulseConfig_v0::dataset_data, 1>(m_group, "pulses", m_idx);
  ndarray<Psana::EvrData::PulseConfig, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_pulses = tmp;
}
void ConfigV2_v0::read_ds_output_maps() const {
  ndarray<EvrData::ns_OutputMap_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_OutputMap_v0::dataset_data, 1>(m_group, "output_maps", m_idx);
  ndarray<Psana::EvrData::OutputMap, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_output_maps = tmp;
}

void make_datasets_ConfigV2_v0(const Psana::EvrData::ConfigV2& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = EvrData::ns_ConfigV2_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.pulses()) PsanaArray;
    const PsanaArray& psana_array = obj.pulses();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_PulseConfig_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "pulses", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.output_maps()) PsanaArray;
    const PsanaArray& psana_array = obj.output_maps();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_OutputMap_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "output_maps", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_ConfigV2_v0(const Psana::EvrData::ConfigV2* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    EvrData::ns_ConfigV2_v0::dataset_config ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "config", index < 0 ? index : index + 1);
  }
  if (obj) {
    typedef __typeof__(obj->pulses()) PsanaArray;
    typedef ndarray<EvrData::ns_PulseConfig_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->pulses();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_PulseConfig_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "pulses", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "pulses", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "pulses", index < 0 ? index : index + 1);
  }

  if (obj) {
    typedef __typeof__(obj->output_maps()) PsanaArray;
    typedef ndarray<EvrData::ns_OutputMap_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->output_maps();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_OutputMap_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "output_maps", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "output_maps", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "output_maps", index < 0 ? index : index + 1);
  }

}

boost::shared_ptr<PSEvt::Proxy<Psana::EvrData::ConfigV2> > make_ConfigV2(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::ConfigV2> >(boost::make_shared<ConfigV2_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::ConfigV2> >(boost::shared_ptr<Psana::EvrData::ConfigV2>());
  }
}

void make_datasets(const Psana::EvrData::ConfigV2& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_ConfigV2_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.ConfigV2", version);
  }
}

void store_ConfigV2(const Psana::EvrData::ConfigV2* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_ConfigV2_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.ConfigV2", version);
  }
}

void store(const Psana::EvrData::ConfigV2& obj, hdf5pp::Group group, int version) 
{
  store_ConfigV2(&obj, group, 0, version, false);
}

void store_at(const Psana::EvrData::ConfigV2* obj, hdf5pp::Group group, long index, int version)
{
  store_ConfigV2(obj, group, index, version, true);
}


hdf5pp::Type ns_ConfigV3_v0_dataset_config_stored_type()
{
  typedef ns_ConfigV3_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("neventcodes", offsetof(DsType, neventcodes), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("npulses", offsetof(DsType, npulses), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("noutputs", offsetof(DsType, noutputs), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_ConfigV3_v0::dataset_config::stored_type()
{
  static hdf5pp::Type type = ns_ConfigV3_v0_dataset_config_stored_type();
  return type;
}

hdf5pp::Type ns_ConfigV3_v0_dataset_config_native_type()
{
  typedef ns_ConfigV3_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("neventcodes", offsetof(DsType, neventcodes), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("npulses", offsetof(DsType, npulses), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("noutputs", offsetof(DsType, noutputs), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_ConfigV3_v0::dataset_config::native_type()
{
  static hdf5pp::Type type = ns_ConfigV3_v0_dataset_config_native_type();
  return type;
}

ns_ConfigV3_v0::dataset_config::dataset_config()
{
}

ns_ConfigV3_v0::dataset_config::dataset_config(const Psana::EvrData::ConfigV3& psanaobj)
  : neventcodes(psanaobj.neventcodes())
  , npulses(psanaobj.npulses())
  , noutputs(psanaobj.noutputs())
{
}

ns_ConfigV3_v0::dataset_config::~dataset_config()
{
}
uint32_t ConfigV3_v0::neventcodes() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->neventcodes);
}
uint32_t ConfigV3_v0::npulses() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->npulses);
}
uint32_t ConfigV3_v0::noutputs() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->noutputs);
}
ndarray<const Psana::EvrData::EventCodeV3, 1> ConfigV3_v0::eventcodes() const {
  if (m_ds_eventcodes.empty()) read_ds_eventcodes();
  return m_ds_eventcodes;
}
ndarray<const Psana::EvrData::PulseConfigV3, 1> ConfigV3_v0::pulses() const {
  if (m_ds_pulses.empty()) read_ds_pulses();
  return m_ds_pulses;
}
ndarray<const Psana::EvrData::OutputMap, 1> ConfigV3_v0::output_maps() const {
  if (m_ds_output_maps.empty()) read_ds_output_maps();
  return m_ds_output_maps;
}
void ConfigV3_v0::read_ds_config() const {
  m_ds_config = hdf5pp::Utils::readGroup<EvrData::ns_ConfigV3_v0::dataset_config>(m_group, "config", m_idx);
}
void ConfigV3_v0::read_ds_eventcodes() const {
  ndarray<EvrData::ns_EventCodeV3_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_EventCodeV3_v0::dataset_data, 1>(m_group, "eventcodes", m_idx);
  ndarray<Psana::EvrData::EventCodeV3, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_eventcodes = tmp;
}
void ConfigV3_v0::read_ds_pulses() const {
  ndarray<EvrData::ns_PulseConfigV3_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_PulseConfigV3_v0::dataset_data, 1>(m_group, "pulses", m_idx);
  ndarray<Psana::EvrData::PulseConfigV3, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_pulses = tmp;
}
void ConfigV3_v0::read_ds_output_maps() const {
  ndarray<EvrData::ns_OutputMap_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_OutputMap_v0::dataset_data, 1>(m_group, "output_maps", m_idx);
  ndarray<Psana::EvrData::OutputMap, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_output_maps = tmp;
}

void make_datasets_ConfigV3_v0(const Psana::EvrData::ConfigV3& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = EvrData::ns_ConfigV3_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.eventcodes()) PsanaArray;
    const PsanaArray& psana_array = obj.eventcodes();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_EventCodeV3_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "eventcodes", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.pulses()) PsanaArray;
    const PsanaArray& psana_array = obj.pulses();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_PulseConfigV3_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "pulses", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.output_maps()) PsanaArray;
    const PsanaArray& psana_array = obj.output_maps();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_OutputMap_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "output_maps", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_ConfigV3_v0(const Psana::EvrData::ConfigV3* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    EvrData::ns_ConfigV3_v0::dataset_config ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "config", index < 0 ? index : index + 1);
  }
  if (obj) {
    typedef __typeof__(obj->eventcodes()) PsanaArray;
    typedef ndarray<EvrData::ns_EventCodeV3_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->eventcodes();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_EventCodeV3_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "eventcodes", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "eventcodes", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "eventcodes", index < 0 ? index : index + 1);
  }

  if (obj) {
    typedef __typeof__(obj->pulses()) PsanaArray;
    typedef ndarray<EvrData::ns_PulseConfigV3_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->pulses();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_PulseConfigV3_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "pulses", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "pulses", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "pulses", index < 0 ? index : index + 1);
  }

  if (obj) {
    typedef __typeof__(obj->output_maps()) PsanaArray;
    typedef ndarray<EvrData::ns_OutputMap_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->output_maps();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_OutputMap_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "output_maps", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "output_maps", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "output_maps", index < 0 ? index : index + 1);
  }

}

boost::shared_ptr<PSEvt::Proxy<Psana::EvrData::ConfigV3> > make_ConfigV3(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::ConfigV3> >(boost::make_shared<ConfigV3_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::ConfigV3> >(boost::shared_ptr<Psana::EvrData::ConfigV3>());
  }
}

void make_datasets(const Psana::EvrData::ConfigV3& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_ConfigV3_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.ConfigV3", version);
  }
}

void store_ConfigV3(const Psana::EvrData::ConfigV3* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_ConfigV3_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.ConfigV3", version);
  }
}

void store(const Psana::EvrData::ConfigV3& obj, hdf5pp::Group group, int version) 
{
  store_ConfigV3(&obj, group, 0, version, false);
}

void store_at(const Psana::EvrData::ConfigV3* obj, hdf5pp::Group group, long index, int version)
{
  store_ConfigV3(obj, group, index, version, true);
}


hdf5pp::Type ns_ConfigV4_v0_dataset_config_stored_type()
{
  typedef ns_ConfigV4_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("neventcodes", offsetof(DsType, neventcodes), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("npulses", offsetof(DsType, npulses), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("noutputs", offsetof(DsType, noutputs), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_ConfigV4_v0::dataset_config::stored_type()
{
  static hdf5pp::Type type = ns_ConfigV4_v0_dataset_config_stored_type();
  return type;
}

hdf5pp::Type ns_ConfigV4_v0_dataset_config_native_type()
{
  typedef ns_ConfigV4_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("neventcodes", offsetof(DsType, neventcodes), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("npulses", offsetof(DsType, npulses), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("noutputs", offsetof(DsType, noutputs), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_ConfigV4_v0::dataset_config::native_type()
{
  static hdf5pp::Type type = ns_ConfigV4_v0_dataset_config_native_type();
  return type;
}

ns_ConfigV4_v0::dataset_config::dataset_config()
{
}

ns_ConfigV4_v0::dataset_config::dataset_config(const Psana::EvrData::ConfigV4& psanaobj)
  : neventcodes(psanaobj.neventcodes())
  , npulses(psanaobj.npulses())
  , noutputs(psanaobj.noutputs())
{
}

ns_ConfigV4_v0::dataset_config::~dataset_config()
{
}
uint32_t ConfigV4_v0::neventcodes() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->neventcodes);
}
uint32_t ConfigV4_v0::npulses() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->npulses);
}
uint32_t ConfigV4_v0::noutputs() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->noutputs);
}
ndarray<const Psana::EvrData::EventCodeV4, 1> ConfigV4_v0::eventcodes() const {
  if (m_ds_eventcodes.empty()) read_ds_eventcodes();
  return m_ds_eventcodes;
}
ndarray<const Psana::EvrData::PulseConfigV3, 1> ConfigV4_v0::pulses() const {
  if (m_ds_pulses.empty()) read_ds_pulses();
  return m_ds_pulses;
}
ndarray<const Psana::EvrData::OutputMap, 1> ConfigV4_v0::output_maps() const {
  if (m_ds_output_maps.empty()) read_ds_output_maps();
  return m_ds_output_maps;
}
void ConfigV4_v0::read_ds_config() const {
  m_ds_config = hdf5pp::Utils::readGroup<EvrData::ns_ConfigV4_v0::dataset_config>(m_group, "config", m_idx);
}
void ConfigV4_v0::read_ds_eventcodes() const {
  ndarray<EvrData::ns_EventCodeV4_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_EventCodeV4_v0::dataset_data, 1>(m_group, "eventcodes", m_idx);
  ndarray<Psana::EvrData::EventCodeV4, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_eventcodes = tmp;
}
void ConfigV4_v0::read_ds_pulses() const {
  ndarray<EvrData::ns_PulseConfigV3_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_PulseConfigV3_v0::dataset_data, 1>(m_group, "pulses", m_idx);
  ndarray<Psana::EvrData::PulseConfigV3, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_pulses = tmp;
}
void ConfigV4_v0::read_ds_output_maps() const {
  ndarray<EvrData::ns_OutputMap_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_OutputMap_v0::dataset_data, 1>(m_group, "output_maps", m_idx);
  ndarray<Psana::EvrData::OutputMap, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_output_maps = tmp;
}

void make_datasets_ConfigV4_v0(const Psana::EvrData::ConfigV4& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = EvrData::ns_ConfigV4_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.eventcodes()) PsanaArray;
    const PsanaArray& psana_array = obj.eventcodes();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_EventCodeV4_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "eventcodes", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.pulses()) PsanaArray;
    const PsanaArray& psana_array = obj.pulses();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_PulseConfigV3_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "pulses", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.output_maps()) PsanaArray;
    const PsanaArray& psana_array = obj.output_maps();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_OutputMap_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "output_maps", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_ConfigV4_v0(const Psana::EvrData::ConfigV4* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    EvrData::ns_ConfigV4_v0::dataset_config ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "config", index < 0 ? index : index + 1);
  }
  if (obj) {
    typedef __typeof__(obj->eventcodes()) PsanaArray;
    typedef ndarray<EvrData::ns_EventCodeV4_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->eventcodes();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_EventCodeV4_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "eventcodes", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "eventcodes", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "eventcodes", index < 0 ? index : index + 1);
  }

  if (obj) {
    typedef __typeof__(obj->pulses()) PsanaArray;
    typedef ndarray<EvrData::ns_PulseConfigV3_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->pulses();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_PulseConfigV3_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "pulses", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "pulses", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "pulses", index < 0 ? index : index + 1);
  }

  if (obj) {
    typedef __typeof__(obj->output_maps()) PsanaArray;
    typedef ndarray<EvrData::ns_OutputMap_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->output_maps();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_OutputMap_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "output_maps", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "output_maps", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "output_maps", index < 0 ? index : index + 1);
  }

}

boost::shared_ptr<PSEvt::Proxy<Psana::EvrData::ConfigV4> > make_ConfigV4(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::ConfigV4> >(boost::make_shared<ConfigV4_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::ConfigV4> >(boost::shared_ptr<Psana::EvrData::ConfigV4>());
  }
}

void make_datasets(const Psana::EvrData::ConfigV4& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_ConfigV4_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.ConfigV4", version);
  }
}

void store_ConfigV4(const Psana::EvrData::ConfigV4* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_ConfigV4_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.ConfigV4", version);
  }
}

void store(const Psana::EvrData::ConfigV4& obj, hdf5pp::Group group, int version) 
{
  store_ConfigV4(&obj, group, 0, version, false);
}

void store_at(const Psana::EvrData::ConfigV4* obj, hdf5pp::Group group, long index, int version)
{
  store_ConfigV4(obj, group, index, version, true);
}


hdf5pp::Type ns_SequencerEntry_v0_dataset_data_stored_type()
{
  typedef ns_SequencerEntry_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("delay", offsetof(DsType, delay), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("eventcode", offsetof(DsType, eventcode), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_SequencerEntry_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_SequencerEntry_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_SequencerEntry_v0_dataset_data_native_type()
{
  typedef ns_SequencerEntry_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("delay", offsetof(DsType, delay), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("eventcode", offsetof(DsType, eventcode), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_SequencerEntry_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_SequencerEntry_v0_dataset_data_native_type();
  return type;
}

ns_SequencerEntry_v0::dataset_data::dataset_data()
{
}

ns_SequencerEntry_v0::dataset_data::dataset_data(const Psana::EvrData::SequencerEntry& psanaobj)
  : delay(psanaobj.delay())
  , eventcode(psanaobj.eventcode())
{
}

ns_SequencerEntry_v0::dataset_data::~dataset_data()
{
}

hdf5pp::Type ns_SequencerConfigV1_v0_dataset_config_stored_type()
{
  typedef ns_SequencerConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  hdf5pp::EnumType<int32_t> _enum_type_sync_source = hdf5pp::EnumType<int32_t>::enumType();
  _enum_type_sync_source.insert("r120Hz", Psana::EvrData::SequencerConfigV1::r120Hz);
  _enum_type_sync_source.insert("r60Hz", Psana::EvrData::SequencerConfigV1::r60Hz);
  _enum_type_sync_source.insert("r30Hz", Psana::EvrData::SequencerConfigV1::r30Hz);
  _enum_type_sync_source.insert("r10Hz", Psana::EvrData::SequencerConfigV1::r10Hz);
  _enum_type_sync_source.insert("r5Hz", Psana::EvrData::SequencerConfigV1::r5Hz);
  _enum_type_sync_source.insert("r1Hz", Psana::EvrData::SequencerConfigV1::r1Hz);
  _enum_type_sync_source.insert("r0_5Hz", Psana::EvrData::SequencerConfigV1::r0_5Hz);
  _enum_type_sync_source.insert("Disable", Psana::EvrData::SequencerConfigV1::Disable);
  type.insert("sync_source", offsetof(DsType, sync_source), _enum_type_sync_source);
  hdf5pp::EnumType<int32_t> _enum_type_beam_source = hdf5pp::EnumType<int32_t>::enumType();
  _enum_type_beam_source.insert("r120Hz", Psana::EvrData::SequencerConfigV1::r120Hz);
  _enum_type_beam_source.insert("r60Hz", Psana::EvrData::SequencerConfigV1::r60Hz);
  _enum_type_beam_source.insert("r30Hz", Psana::EvrData::SequencerConfigV1::r30Hz);
  _enum_type_beam_source.insert("r10Hz", Psana::EvrData::SequencerConfigV1::r10Hz);
  _enum_type_beam_source.insert("r5Hz", Psana::EvrData::SequencerConfigV1::r5Hz);
  _enum_type_beam_source.insert("r1Hz", Psana::EvrData::SequencerConfigV1::r1Hz);
  _enum_type_beam_source.insert("r0_5Hz", Psana::EvrData::SequencerConfigV1::r0_5Hz);
  _enum_type_beam_source.insert("Disable", Psana::EvrData::SequencerConfigV1::Disable);
  type.insert("beam_source", offsetof(DsType, beam_source), _enum_type_beam_source);
  type.insert("length", offsetof(DsType, length), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("cycles", offsetof(DsType, cycles), hdf5pp::TypeTraits<uint32_t>::stored_type());
  hdf5pp::VlenType _array_type_entries = hdf5pp::VlenType::vlenType(hdf5pp::TypeTraits<EvrData::ns_SequencerEntry_v0::dataset_data>::stored_type());
  type.insert("entries", offsetof(DsType, vlen_entries), _array_type_entries);
  return type;
}

hdf5pp::Type ns_SequencerConfigV1_v0::dataset_config::stored_type()
{
  static hdf5pp::Type type = ns_SequencerConfigV1_v0_dataset_config_stored_type();
  return type;
}

hdf5pp::Type ns_SequencerConfigV1_v0_dataset_config_native_type()
{
  typedef ns_SequencerConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  hdf5pp::EnumType<int32_t> _enum_type_sync_source = hdf5pp::EnumType<int32_t>::enumType();
  _enum_type_sync_source.insert("r120Hz", Psana::EvrData::SequencerConfigV1::r120Hz);
  _enum_type_sync_source.insert("r60Hz", Psana::EvrData::SequencerConfigV1::r60Hz);
  _enum_type_sync_source.insert("r30Hz", Psana::EvrData::SequencerConfigV1::r30Hz);
  _enum_type_sync_source.insert("r10Hz", Psana::EvrData::SequencerConfigV1::r10Hz);
  _enum_type_sync_source.insert("r5Hz", Psana::EvrData::SequencerConfigV1::r5Hz);
  _enum_type_sync_source.insert("r1Hz", Psana::EvrData::SequencerConfigV1::r1Hz);
  _enum_type_sync_source.insert("r0_5Hz", Psana::EvrData::SequencerConfigV1::r0_5Hz);
  _enum_type_sync_source.insert("Disable", Psana::EvrData::SequencerConfigV1::Disable);
  type.insert("sync_source", offsetof(DsType, sync_source), _enum_type_sync_source);
  hdf5pp::EnumType<int32_t> _enum_type_beam_source = hdf5pp::EnumType<int32_t>::enumType();
  _enum_type_beam_source.insert("r120Hz", Psana::EvrData::SequencerConfigV1::r120Hz);
  _enum_type_beam_source.insert("r60Hz", Psana::EvrData::SequencerConfigV1::r60Hz);
  _enum_type_beam_source.insert("r30Hz", Psana::EvrData::SequencerConfigV1::r30Hz);
  _enum_type_beam_source.insert("r10Hz", Psana::EvrData::SequencerConfigV1::r10Hz);
  _enum_type_beam_source.insert("r5Hz", Psana::EvrData::SequencerConfigV1::r5Hz);
  _enum_type_beam_source.insert("r1Hz", Psana::EvrData::SequencerConfigV1::r1Hz);
  _enum_type_beam_source.insert("r0_5Hz", Psana::EvrData::SequencerConfigV1::r0_5Hz);
  _enum_type_beam_source.insert("Disable", Psana::EvrData::SequencerConfigV1::Disable);
  type.insert("beam_source", offsetof(DsType, beam_source), _enum_type_beam_source);
  type.insert("length", offsetof(DsType, length), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("cycles", offsetof(DsType, cycles), hdf5pp::TypeTraits<uint32_t>::native_type());
  hdf5pp::VlenType _array_type_entries = hdf5pp::VlenType::vlenType(hdf5pp::TypeTraits<EvrData::ns_SequencerEntry_v0::dataset_data>::native_type());
  type.insert("entries", offsetof(DsType, vlen_entries), _array_type_entries);
  return type;
}

hdf5pp::Type ns_SequencerConfigV1_v0::dataset_config::native_type()
{
  static hdf5pp::Type type = ns_SequencerConfigV1_v0_dataset_config_native_type();
  return type;
}

ns_SequencerConfigV1_v0::dataset_config::dataset_config()
{
  this->vlen_entries = 0;
  this->entries = 0;
}

ns_SequencerConfigV1_v0::dataset_config::dataset_config(const Psana::EvrData::SequencerConfigV1& psanaobj)
  : sync_source(psanaobj.sync_source())
  , beam_source(psanaobj.beam_source())
  , length(psanaobj.length())
  , cycles(psanaobj.cycles())
  , vlen_entries(0)
  , entries(0)
{
  {
    const __typeof__(psanaobj.entries())& arr = psanaobj.entries();
    vlen_entries = arr.size();
    entries = static_cast<EvrData::ns_SequencerEntry_v0::dataset_data*>(malloc(vlen_entries*sizeof(EvrData::ns_SequencerEntry_v0::dataset_data)));
    std::copy(arr.begin(), arr.end(), entries);
  }
}

ns_SequencerConfigV1_v0::dataset_config::~dataset_config()
{
  free(this->entries);
}
Psana::EvrData::SequencerConfigV1::Source SequencerConfigV1_v0::sync_source() const {
  if (not m_ds_config) read_ds_config();
  return Psana::EvrData::SequencerConfigV1::Source(m_ds_config->sync_source);
}
Psana::EvrData::SequencerConfigV1::Source SequencerConfigV1_v0::beam_source() const {
  if (not m_ds_config) read_ds_config();
  return Psana::EvrData::SequencerConfigV1::Source(m_ds_config->beam_source);
}
uint32_t SequencerConfigV1_v0::length() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->length);
}
uint32_t SequencerConfigV1_v0::cycles() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->cycles);
}
ndarray<const Psana::EvrData::SequencerEntry, 1> SequencerConfigV1_v0::entries() const {
  if (not m_ds_config) read_ds_config();
  if (m_ds_storage_config_entries.empty()) {
    unsigned shape[] = {m_ds_config->vlen_entries};
    ndarray<Psana::EvrData::SequencerEntry, 1> tmparr(shape);
    unsigned size = tmparr.size();
    ndarray<Psana::EvrData::SequencerEntry, 1>::iterator it = tmparr.begin();
    for (unsigned i = 0; i != size; ++ i, ++ it) {
      *it = Psana::EvrData::SequencerEntry(m_ds_config->entries[i]);
    }
    m_ds_storage_config_entries = tmparr;
  }
  return m_ds_storage_config_entries;
}
void SequencerConfigV1_v0::read_ds_config() const {
  m_ds_config = hdf5pp::Utils::readGroup<EvrData::ns_SequencerConfigV1_v0::dataset_config>(m_group, "config", m_idx);
}

void make_datasets_SequencerConfigV1_v0(const Psana::EvrData::SequencerConfigV1& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = EvrData::ns_SequencerConfigV1_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_SequencerConfigV1_v0(const Psana::EvrData::SequencerConfigV1* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    EvrData::ns_SequencerConfigV1_v0::dataset_config ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "config", index < 0 ? index : index + 1);
  }
}


hdf5pp::Type ns_ConfigV5_v0_dataset_config_stored_type()
{
  typedef ns_ConfigV5_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("neventcodes", offsetof(DsType, neventcodes), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("npulses", offsetof(DsType, npulses), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("noutputs", offsetof(DsType, noutputs), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_ConfigV5_v0::dataset_config::stored_type()
{
  static hdf5pp::Type type = ns_ConfigV5_v0_dataset_config_stored_type();
  return type;
}

hdf5pp::Type ns_ConfigV5_v0_dataset_config_native_type()
{
  typedef ns_ConfigV5_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("neventcodes", offsetof(DsType, neventcodes), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("npulses", offsetof(DsType, npulses), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("noutputs", offsetof(DsType, noutputs), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_ConfigV5_v0::dataset_config::native_type()
{
  static hdf5pp::Type type = ns_ConfigV5_v0_dataset_config_native_type();
  return type;
}

ns_ConfigV5_v0::dataset_config::dataset_config()
{
}

ns_ConfigV5_v0::dataset_config::dataset_config(const Psana::EvrData::ConfigV5& psanaobj)
  : neventcodes(psanaobj.neventcodes())
  , npulses(psanaobj.npulses())
  , noutputs(psanaobj.noutputs())
{
}

ns_ConfigV5_v0::dataset_config::~dataset_config()
{
}
uint32_t ConfigV5_v0::neventcodes() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->neventcodes);
}
uint32_t ConfigV5_v0::npulses() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->npulses);
}
uint32_t ConfigV5_v0::noutputs() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->noutputs);
}
ndarray<const Psana::EvrData::EventCodeV5, 1> ConfigV5_v0::eventcodes() const {
  if (m_ds_eventcodes.empty()) read_ds_eventcodes();
  return m_ds_eventcodes;
}
ndarray<const Psana::EvrData::PulseConfigV3, 1> ConfigV5_v0::pulses() const {
  if (m_ds_pulses.empty()) read_ds_pulses();
  return m_ds_pulses;
}
ndarray<const Psana::EvrData::OutputMap, 1> ConfigV5_v0::output_maps() const {
  if (m_ds_output_maps.empty()) read_ds_output_maps();
  return m_ds_output_maps;
}
const Psana::EvrData::SequencerConfigV1& ConfigV5_v0::seq_config() const {
  if (not m_ds_storage_seq_config) {
    if (not m_ds_seq_config) read_ds_seq_config();
    m_ds_storage_seq_config = boost::make_shared<EvrData::SequencerConfigV1_v0>(m_ds_seq_config);
  }
  return *m_ds_storage_seq_config;
}
void ConfigV5_v0::read_ds_config() const {
  m_ds_config = hdf5pp::Utils::readGroup<EvrData::ns_ConfigV5_v0::dataset_config>(m_group, "config", m_idx);
}
void ConfigV5_v0::read_ds_eventcodes() const {
  ndarray<EvrData::ns_EventCodeV5_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_EventCodeV5_v0::dataset_data, 1>(m_group, "eventcodes", m_idx);
  ndarray<Psana::EvrData::EventCodeV5, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_eventcodes = tmp;
}
void ConfigV5_v0::read_ds_pulses() const {
  ndarray<EvrData::ns_PulseConfigV3_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_PulseConfigV3_v0::dataset_data, 1>(m_group, "pulses", m_idx);
  ndarray<Psana::EvrData::PulseConfigV3, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_pulses = tmp;
}
void ConfigV5_v0::read_ds_output_maps() const {
  ndarray<EvrData::ns_OutputMap_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_OutputMap_v0::dataset_data, 1>(m_group, "output_maps", m_idx);
  ndarray<Psana::EvrData::OutputMap, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_output_maps = tmp;
}
void ConfigV5_v0::read_ds_seq_config() const {
  m_ds_seq_config = hdf5pp::Utils::readGroup<EvrData::ns_SequencerConfigV1_v0::dataset_config>(m_group, "seq_config", m_idx);
  m_ds_storage_seq_config = boost::make_shared<SequencerConfigV1_v0>(m_ds_seq_config);
}

void make_datasets_ConfigV5_v0(const Psana::EvrData::ConfigV5& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = EvrData::ns_ConfigV5_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.eventcodes()) PsanaArray;
    const PsanaArray& psana_array = obj.eventcodes();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_EventCodeV5_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "eventcodes", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.pulses()) PsanaArray;
    const PsanaArray& psana_array = obj.pulses();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_PulseConfigV3_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "pulses", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.output_maps()) PsanaArray;
    const PsanaArray& psana_array = obj.output_maps();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_OutputMap_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "output_maps", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    hdf5pp::Type dstype = EvrData::ns_SequencerConfigV1_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "seq_config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_ConfigV5_v0(const Psana::EvrData::ConfigV5* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    EvrData::ns_ConfigV5_v0::dataset_config ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "config", index < 0 ? index : index + 1);
  }
  if (obj) {
    typedef __typeof__(obj->eventcodes()) PsanaArray;
    typedef ndarray<EvrData::ns_EventCodeV5_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->eventcodes();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_EventCodeV5_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "eventcodes", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "eventcodes", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "eventcodes", index < 0 ? index : index + 1);
  }

  if (obj) {
    typedef __typeof__(obj->pulses()) PsanaArray;
    typedef ndarray<EvrData::ns_PulseConfigV3_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->pulses();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_PulseConfigV3_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "pulses", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "pulses", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "pulses", index < 0 ? index : index + 1);
  }

  if (obj) {
    typedef __typeof__(obj->output_maps()) PsanaArray;
    typedef ndarray<EvrData::ns_OutputMap_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->output_maps();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_OutputMap_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "output_maps", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "output_maps", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "output_maps", index < 0 ? index : index + 1);
  }

  if (obj) {
    EvrData::ns_SequencerConfigV1_v0::dataset_config ds_data(obj->seq_config());
    if (append) {
      hdf5pp::Utils::storeAt(group, "seq_config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "seq_config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "seq_config", index < 0 ? index : index + 1);
  }
}

boost::shared_ptr<PSEvt::Proxy<Psana::EvrData::ConfigV5> > make_ConfigV5(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::ConfigV5> >(boost::make_shared<ConfigV5_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::ConfigV5> >(boost::shared_ptr<Psana::EvrData::ConfigV5>());
  }
}

void make_datasets(const Psana::EvrData::ConfigV5& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_ConfigV5_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.ConfigV5", version);
  }
}

void store_ConfigV5(const Psana::EvrData::ConfigV5* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_ConfigV5_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.ConfigV5", version);
  }
}

void store(const Psana::EvrData::ConfigV5& obj, hdf5pp::Group group, int version) 
{
  store_ConfigV5(&obj, group, 0, version, false);
}

void store_at(const Psana::EvrData::ConfigV5* obj, hdf5pp::Group group, long index, int version)
{
  store_ConfigV5(obj, group, index, version, true);
}


hdf5pp::Type ns_ConfigV6_v0_dataset_config_stored_type()
{
  typedef ns_ConfigV6_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("neventcodes", offsetof(DsType, neventcodes), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("npulses", offsetof(DsType, npulses), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("noutputs", offsetof(DsType, noutputs), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_ConfigV6_v0::dataset_config::stored_type()
{
  static hdf5pp::Type type = ns_ConfigV6_v0_dataset_config_stored_type();
  return type;
}

hdf5pp::Type ns_ConfigV6_v0_dataset_config_native_type()
{
  typedef ns_ConfigV6_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("neventcodes", offsetof(DsType, neventcodes), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("npulses", offsetof(DsType, npulses), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("noutputs", offsetof(DsType, noutputs), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_ConfigV6_v0::dataset_config::native_type()
{
  static hdf5pp::Type type = ns_ConfigV6_v0_dataset_config_native_type();
  return type;
}

ns_ConfigV6_v0::dataset_config::dataset_config()
{
}

ns_ConfigV6_v0::dataset_config::dataset_config(const Psana::EvrData::ConfigV6& psanaobj)
  : neventcodes(psanaobj.neventcodes())
  , npulses(psanaobj.npulses())
  , noutputs(psanaobj.noutputs())
{
}

ns_ConfigV6_v0::dataset_config::~dataset_config()
{
}
uint32_t ConfigV6_v0::neventcodes() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->neventcodes);
}
uint32_t ConfigV6_v0::npulses() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->npulses);
}
uint32_t ConfigV6_v0::noutputs() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->noutputs);
}
ndarray<const Psana::EvrData::EventCodeV5, 1> ConfigV6_v0::eventcodes() const {
  if (m_ds_eventcodes.empty()) read_ds_eventcodes();
  return m_ds_eventcodes;
}
ndarray<const Psana::EvrData::PulseConfigV3, 1> ConfigV6_v0::pulses() const {
  if (m_ds_pulses.empty()) read_ds_pulses();
  return m_ds_pulses;
}
ndarray<const Psana::EvrData::OutputMapV2, 1> ConfigV6_v0::output_maps() const {
  if (m_ds_output_maps.empty()) read_ds_output_maps();
  return m_ds_output_maps;
}
const Psana::EvrData::SequencerConfigV1& ConfigV6_v0::seq_config() const {
  if (not m_ds_storage_seq_config) {
    if (not m_ds_seq_config) read_ds_seq_config();
    m_ds_storage_seq_config = boost::make_shared<EvrData::SequencerConfigV1_v0>(m_ds_seq_config);
  }
  return *m_ds_storage_seq_config;
}
void ConfigV6_v0::read_ds_config() const {
  m_ds_config = hdf5pp::Utils::readGroup<EvrData::ns_ConfigV6_v0::dataset_config>(m_group, "config", m_idx);
}
void ConfigV6_v0::read_ds_eventcodes() const {
  ndarray<EvrData::ns_EventCodeV5_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_EventCodeV5_v0::dataset_data, 1>(m_group, "eventcodes", m_idx);
  ndarray<Psana::EvrData::EventCodeV5, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_eventcodes = tmp;
}
void ConfigV6_v0::read_ds_pulses() const {
  ndarray<EvrData::ns_PulseConfigV3_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_PulseConfigV3_v0::dataset_data, 1>(m_group, "pulses", m_idx);
  ndarray<Psana::EvrData::PulseConfigV3, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_pulses = tmp;
}
void ConfigV6_v0::read_ds_output_maps() const {
  ndarray<EvrData::ns_OutputMapV2_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_OutputMapV2_v0::dataset_data, 1>(m_group, "output_maps", m_idx);
  ndarray<Psana::EvrData::OutputMapV2, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_output_maps = tmp;
}
void ConfigV6_v0::read_ds_seq_config() const {
  m_ds_seq_config = hdf5pp::Utils::readGroup<EvrData::ns_SequencerConfigV1_v0::dataset_config>(m_group, "seq_config", m_idx);
  m_ds_storage_seq_config = boost::make_shared<SequencerConfigV1_v0>(m_ds_seq_config);
}

void make_datasets_ConfigV6_v0(const Psana::EvrData::ConfigV6& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = EvrData::ns_ConfigV6_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.eventcodes()) PsanaArray;
    const PsanaArray& psana_array = obj.eventcodes();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_EventCodeV5_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "eventcodes", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.pulses()) PsanaArray;
    const PsanaArray& psana_array = obj.pulses();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_PulseConfigV3_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "pulses", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.output_maps()) PsanaArray;
    const PsanaArray& psana_array = obj.output_maps();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_OutputMapV2_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "output_maps", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    hdf5pp::Type dstype = EvrData::ns_SequencerConfigV1_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "seq_config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_ConfigV6_v0(const Psana::EvrData::ConfigV6* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    EvrData::ns_ConfigV6_v0::dataset_config ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "config", index < 0 ? index : index + 1);
  }
  if (obj) {
    typedef __typeof__(obj->eventcodes()) PsanaArray;
    typedef ndarray<EvrData::ns_EventCodeV5_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->eventcodes();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_EventCodeV5_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "eventcodes", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "eventcodes", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "eventcodes", index < 0 ? index : index + 1);
  }

  if (obj) {
    typedef __typeof__(obj->pulses()) PsanaArray;
    typedef ndarray<EvrData::ns_PulseConfigV3_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->pulses();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_PulseConfigV3_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "pulses", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "pulses", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "pulses", index < 0 ? index : index + 1);
  }

  if (obj) {
    typedef __typeof__(obj->output_maps()) PsanaArray;
    typedef ndarray<EvrData::ns_OutputMapV2_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->output_maps();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_OutputMapV2_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "output_maps", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "output_maps", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "output_maps", index < 0 ? index : index + 1);
  }

  if (obj) {
    EvrData::ns_SequencerConfigV1_v0::dataset_config ds_data(obj->seq_config());
    if (append) {
      hdf5pp::Utils::storeAt(group, "seq_config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "seq_config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "seq_config", index < 0 ? index : index + 1);
  }
}

boost::shared_ptr<PSEvt::Proxy<Psana::EvrData::ConfigV6> > make_ConfigV6(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::ConfigV6> >(boost::make_shared<ConfigV6_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::ConfigV6> >(boost::shared_ptr<Psana::EvrData::ConfigV6>());
  }
}

void make_datasets(const Psana::EvrData::ConfigV6& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_ConfigV6_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.ConfigV6", version);
  }
}

void store_ConfigV6(const Psana::EvrData::ConfigV6* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_ConfigV6_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.ConfigV6", version);
  }
}

void store(const Psana::EvrData::ConfigV6& obj, hdf5pp::Group group, int version) 
{
  store_ConfigV6(&obj, group, 0, version, false);
}

void store_at(const Psana::EvrData::ConfigV6* obj, hdf5pp::Group group, long index, int version)
{
  store_ConfigV6(obj, group, index, version, true);
}


hdf5pp::Type ns_ConfigV7_v0_dataset_config_stored_type()
{
  typedef ns_ConfigV7_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("neventcodes", offsetof(DsType, neventcodes), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("npulses", offsetof(DsType, npulses), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("noutputs", offsetof(DsType, noutputs), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_ConfigV7_v0::dataset_config::stored_type()
{
  static hdf5pp::Type type = ns_ConfigV7_v0_dataset_config_stored_type();
  return type;
}

hdf5pp::Type ns_ConfigV7_v0_dataset_config_native_type()
{
  typedef ns_ConfigV7_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("neventcodes", offsetof(DsType, neventcodes), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("npulses", offsetof(DsType, npulses), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("noutputs", offsetof(DsType, noutputs), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_ConfigV7_v0::dataset_config::native_type()
{
  static hdf5pp::Type type = ns_ConfigV7_v0_dataset_config_native_type();
  return type;
}

ns_ConfigV7_v0::dataset_config::dataset_config()
{
}

ns_ConfigV7_v0::dataset_config::dataset_config(const Psana::EvrData::ConfigV7& psanaobj)
  : neventcodes(psanaobj.neventcodes())
  , npulses(psanaobj.npulses())
  , noutputs(psanaobj.noutputs())
{
}

ns_ConfigV7_v0::dataset_config::~dataset_config()
{
}
uint32_t ConfigV7_v0::neventcodes() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->neventcodes);
}
uint32_t ConfigV7_v0::npulses() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->npulses);
}
uint32_t ConfigV7_v0::noutputs() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->noutputs);
}
ndarray<const Psana::EvrData::EventCodeV6, 1> ConfigV7_v0::eventcodes() const {
  if (m_ds_eventcodes.empty()) read_ds_eventcodes();
  return m_ds_eventcodes;
}
ndarray<const Psana::EvrData::PulseConfigV3, 1> ConfigV7_v0::pulses() const {
  if (m_ds_pulses.empty()) read_ds_pulses();
  return m_ds_pulses;
}
ndarray<const Psana::EvrData::OutputMapV2, 1> ConfigV7_v0::output_maps() const {
  if (m_ds_output_maps.empty()) read_ds_output_maps();
  return m_ds_output_maps;
}
const Psana::EvrData::SequencerConfigV1& ConfigV7_v0::seq_config() const {
  if (not m_ds_storage_seq_config) {
    if (not m_ds_seq_config) read_ds_seq_config();
    m_ds_storage_seq_config = boost::make_shared<EvrData::SequencerConfigV1_v0>(m_ds_seq_config);
  }
  return *m_ds_storage_seq_config;
}
void ConfigV7_v0::read_ds_config() const {
  m_ds_config = hdf5pp::Utils::readGroup<EvrData::ns_ConfigV7_v0::dataset_config>(m_group, "config", m_idx);
}
void ConfigV7_v0::read_ds_eventcodes() const {
  ndarray<EvrData::ns_EventCodeV6_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_EventCodeV6_v0::dataset_data, 1>(m_group, "eventcodes", m_idx);
  ndarray<Psana::EvrData::EventCodeV6, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_eventcodes = tmp;
}
void ConfigV7_v0::read_ds_pulses() const {
  ndarray<EvrData::ns_PulseConfigV3_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_PulseConfigV3_v0::dataset_data, 1>(m_group, "pulses", m_idx);
  ndarray<Psana::EvrData::PulseConfigV3, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_pulses = tmp;
}
void ConfigV7_v0::read_ds_output_maps() const {
  ndarray<EvrData::ns_OutputMapV2_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_OutputMapV2_v0::dataset_data, 1>(m_group, "output_maps", m_idx);
  ndarray<Psana::EvrData::OutputMapV2, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_output_maps = tmp;
}
void ConfigV7_v0::read_ds_seq_config() const {
  m_ds_seq_config = hdf5pp::Utils::readGroup<EvrData::ns_SequencerConfigV1_v0::dataset_config>(m_group, "seq_config", m_idx);
  m_ds_storage_seq_config = boost::make_shared<SequencerConfigV1_v0>(m_ds_seq_config);
}

void make_datasets_ConfigV7_v0(const Psana::EvrData::ConfigV7& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = EvrData::ns_ConfigV7_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.eventcodes()) PsanaArray;
    const PsanaArray& psana_array = obj.eventcodes();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_EventCodeV6_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "eventcodes", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.pulses()) PsanaArray;
    const PsanaArray& psana_array = obj.pulses();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_PulseConfigV3_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "pulses", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.output_maps()) PsanaArray;
    const PsanaArray& psana_array = obj.output_maps();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_OutputMapV2_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "output_maps", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    hdf5pp::Type dstype = EvrData::ns_SequencerConfigV1_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "seq_config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_ConfigV7_v0(const Psana::EvrData::ConfigV7* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    EvrData::ns_ConfigV7_v0::dataset_config ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "config", index < 0 ? index : index + 1);
  }
  if (obj) {
    typedef __typeof__(obj->eventcodes()) PsanaArray;
    typedef ndarray<EvrData::ns_EventCodeV6_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->eventcodes();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_EventCodeV6_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "eventcodes", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "eventcodes", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "eventcodes", index < 0 ? index : index + 1);
  }

  if (obj) {
    typedef __typeof__(obj->pulses()) PsanaArray;
    typedef ndarray<EvrData::ns_PulseConfigV3_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->pulses();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_PulseConfigV3_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "pulses", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "pulses", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "pulses", index < 0 ? index : index + 1);
  }

  if (obj) {
    typedef __typeof__(obj->output_maps()) PsanaArray;
    typedef ndarray<EvrData::ns_OutputMapV2_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->output_maps();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_OutputMapV2_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "output_maps", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "output_maps", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "output_maps", index < 0 ? index : index + 1);
  }

  if (obj) {
    EvrData::ns_SequencerConfigV1_v0::dataset_config ds_data(obj->seq_config());
    if (append) {
      hdf5pp::Utils::storeAt(group, "seq_config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "seq_config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "seq_config", index < 0 ? index : index + 1);
  }
}

boost::shared_ptr<PSEvt::Proxy<Psana::EvrData::ConfigV7> > make_ConfigV7(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::ConfigV7> >(boost::make_shared<ConfigV7_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::ConfigV7> >(boost::shared_ptr<Psana::EvrData::ConfigV7>());
  }
}

void make_datasets(const Psana::EvrData::ConfigV7& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_ConfigV7_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.ConfigV7", version);
  }
}

void store_ConfigV7(const Psana::EvrData::ConfigV7* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_ConfigV7_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.ConfigV7", version);
  }
}

void store(const Psana::EvrData::ConfigV7& obj, hdf5pp::Group group, int version) 
{
  store_ConfigV7(&obj, group, 0, version, false);
}

void store_at(const Psana::EvrData::ConfigV7* obj, hdf5pp::Group group, long index, int version)
{
  store_ConfigV7(obj, group, index, version, true);
}


hdf5pp::Type ns_SrcConfigV1_v0_dataset_config_stored_type()
{
  typedef ns_SrcConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("neventcodes", offsetof(DsType, neventcodes), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("npulses", offsetof(DsType, npulses), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("noutputs", offsetof(DsType, noutputs), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_SrcConfigV1_v0::dataset_config::stored_type()
{
  static hdf5pp::Type type = ns_SrcConfigV1_v0_dataset_config_stored_type();
  return type;
}

hdf5pp::Type ns_SrcConfigV1_v0_dataset_config_native_type()
{
  typedef ns_SrcConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("neventcodes", offsetof(DsType, neventcodes), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("npulses", offsetof(DsType, npulses), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("noutputs", offsetof(DsType, noutputs), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_SrcConfigV1_v0::dataset_config::native_type()
{
  static hdf5pp::Type type = ns_SrcConfigV1_v0_dataset_config_native_type();
  return type;
}

ns_SrcConfigV1_v0::dataset_config::dataset_config()
{
}

ns_SrcConfigV1_v0::dataset_config::dataset_config(const Psana::EvrData::SrcConfigV1& psanaobj)
  : neventcodes(psanaobj.neventcodes())
  , npulses(psanaobj.npulses())
  , noutputs(psanaobj.noutputs())
{
}

ns_SrcConfigV1_v0::dataset_config::~dataset_config()
{
}
uint32_t SrcConfigV1_v0::neventcodes() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->neventcodes);
}
uint32_t SrcConfigV1_v0::npulses() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->npulses);
}
uint32_t SrcConfigV1_v0::noutputs() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->noutputs);
}
ndarray<const Psana::EvrData::SrcEventCode, 1> SrcConfigV1_v0::eventcodes() const {
  if (m_ds_eventcodes.empty()) read_ds_eventcodes();
  return m_ds_eventcodes;
}
ndarray<const Psana::EvrData::PulseConfigV3, 1> SrcConfigV1_v0::pulses() const {
  if (m_ds_pulses.empty()) read_ds_pulses();
  return m_ds_pulses;
}
ndarray<const Psana::EvrData::OutputMapV2, 1> SrcConfigV1_v0::output_maps() const {
  if (m_ds_output_maps.empty()) read_ds_output_maps();
  return m_ds_output_maps;
}
void SrcConfigV1_v0::read_ds_config() const {
  m_ds_config = hdf5pp::Utils::readGroup<EvrData::ns_SrcConfigV1_v0::dataset_config>(m_group, "config", m_idx);
}
void SrcConfigV1_v0::read_ds_eventcodes() const {
  ndarray<EvrData::ns_SrcEventCode_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_SrcEventCode_v0::dataset_data, 1>(m_group, "eventcodes", m_idx);
  ndarray<Psana::EvrData::SrcEventCode, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_eventcodes = tmp;
}
void SrcConfigV1_v0::read_ds_pulses() const {
  ndarray<EvrData::ns_PulseConfigV3_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_PulseConfigV3_v0::dataset_data, 1>(m_group, "pulses", m_idx);
  ndarray<Psana::EvrData::PulseConfigV3, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_pulses = tmp;
}
void SrcConfigV1_v0::read_ds_output_maps() const {
  ndarray<EvrData::ns_OutputMapV2_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<EvrData::ns_OutputMapV2_v0::dataset_data, 1>(m_group, "output_maps", m_idx);
  ndarray<Psana::EvrData::OutputMapV2, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_output_maps = tmp;
}

void make_datasets_SrcConfigV1_v0(const Psana::EvrData::SrcConfigV1& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = EvrData::ns_SrcConfigV1_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.eventcodes()) PsanaArray;
    const PsanaArray& psana_array = obj.eventcodes();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_SrcEventCode_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "eventcodes", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.pulses()) PsanaArray;
    const PsanaArray& psana_array = obj.pulses();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_PulseConfigV3_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "pulses", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.output_maps()) PsanaArray;
    const PsanaArray& psana_array = obj.output_maps();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<EvrData::ns_OutputMapV2_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "output_maps", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_SrcConfigV1_v0(const Psana::EvrData::SrcConfigV1* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    EvrData::ns_SrcConfigV1_v0::dataset_config ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "config", index < 0 ? index : index + 1);
  }
  if (obj) {
    typedef __typeof__(obj->eventcodes()) PsanaArray;
    typedef ndarray<EvrData::ns_SrcEventCode_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->eventcodes();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_SrcEventCode_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "eventcodes", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "eventcodes", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "eventcodes", index < 0 ? index : index + 1);
  }

  if (obj) {
    typedef __typeof__(obj->pulses()) PsanaArray;
    typedef ndarray<EvrData::ns_PulseConfigV3_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->pulses();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_PulseConfigV3_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "pulses", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "pulses", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "pulses", index < 0 ? index : index + 1);
  }

  if (obj) {
    typedef __typeof__(obj->output_maps()) PsanaArray;
    typedef ndarray<EvrData::ns_OutputMapV2_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->output_maps();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = EvrData::ns_OutputMapV2_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "output_maps", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "output_maps", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "output_maps", index < 0 ? index : index + 1);
  }

}

boost::shared_ptr<PSEvt::Proxy<Psana::EvrData::SrcConfigV1> > make_SrcConfigV1(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::SrcConfigV1> >(boost::make_shared<SrcConfigV1_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::SrcConfigV1> >(boost::shared_ptr<Psana::EvrData::SrcConfigV1>());
  }
}

void make_datasets(const Psana::EvrData::SrcConfigV1& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_SrcConfigV1_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.SrcConfigV1", version);
  }
}

void store_SrcConfigV1(const Psana::EvrData::SrcConfigV1* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_SrcConfigV1_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.SrcConfigV1", version);
  }
}

void store(const Psana::EvrData::SrcConfigV1& obj, hdf5pp::Group group, int version) 
{
  store_SrcConfigV1(&obj, group, 0, version, false);
}

void store_at(const Psana::EvrData::SrcConfigV1* obj, hdf5pp::Group group, long index, int version)
{
  store_SrcConfigV1(obj, group, index, version, true);
}


hdf5pp::Type ns_FIFOEvent_v0_dataset_data_stored_type()
{
  typedef ns_FIFOEvent_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("timestampHigh", offsetof(DsType, timestampHigh), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("timestampLow", offsetof(DsType, timestampLow), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("eventCode", offsetof(DsType, eventCode), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_FIFOEvent_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_FIFOEvent_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_FIFOEvent_v0_dataset_data_native_type()
{
  typedef ns_FIFOEvent_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("timestampHigh", offsetof(DsType, timestampHigh), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("timestampLow", offsetof(DsType, timestampLow), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("eventCode", offsetof(DsType, eventCode), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_FIFOEvent_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_FIFOEvent_v0_dataset_data_native_type();
  return type;
}

ns_FIFOEvent_v0::dataset_data::dataset_data()
{
}

ns_FIFOEvent_v0::dataset_data::dataset_data(const Psana::EvrData::FIFOEvent& psanaobj)
  : timestampHigh(psanaobj.timestampHigh())
  , timestampLow(psanaobj.timestampLow())
  , eventCode(psanaobj.eventCode())
{
}

ns_FIFOEvent_v0::dataset_data::~dataset_data()
{
}
boost::shared_ptr<PSEvt::Proxy<Psana::EvrData::DataV3> > make_DataV3(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::DataV3> >(boost::make_shared<DataV3_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::DataV3> >(boost::shared_ptr<Psana::EvrData::DataV3>());
  }
}

void make_datasets(const Psana::EvrData::DataV3& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_DataV3_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.DataV3", version);
  }
}

void store_DataV3(const Psana::EvrData::DataV3* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_DataV3_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.DataV3", version);
  }
}

void store(const Psana::EvrData::DataV3& obj, hdf5pp::Group group, int version) 
{
  store_DataV3(&obj, group, 0, version, false);
}

void store_at(const Psana::EvrData::DataV3* obj, hdf5pp::Group group, long index, int version)
{
  store_DataV3(obj, group, index, version, true);
}

boost::shared_ptr<PSEvt::Proxy<Psana::EvrData::DataV4> > make_DataV4(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::DataV4> >(boost::make_shared<DataV4_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::DataV4> >(boost::shared_ptr<Psana::EvrData::DataV4>());
  }
}

void make_datasets(const Psana::EvrData::DataV4& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_DataV4_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.DataV4", version);
  }
}

void store_DataV4(const Psana::EvrData::DataV4* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_DataV4_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.DataV4", version);
  }
}

void store(const Psana::EvrData::DataV4& obj, hdf5pp::Group group, int version) 
{
  store_DataV4(&obj, group, 0, version, false);
}

void store_at(const Psana::EvrData::DataV4* obj, hdf5pp::Group group, long index, int version)
{
  store_DataV4(obj, group, index, version, true);
}

boost::shared_ptr<PSEvt::Proxy<Psana::EvrData::IOConfigV1> > make_IOConfigV1(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::IOConfigV1> >(boost::make_shared<IOConfigV1_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::IOConfigV1> >(boost::shared_ptr<Psana::EvrData::IOConfigV1>());
  }
}

void make_datasets(const Psana::EvrData::IOConfigV1& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_IOConfigV1_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.IOConfigV1", version);
  }
}

void store_IOConfigV1(const Psana::EvrData::IOConfigV1* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_IOConfigV1_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.IOConfigV1", version);
  }
}

void store(const Psana::EvrData::IOConfigV1& obj, hdf5pp::Group group, int version) 
{
  store_IOConfigV1(&obj, group, 0, version, false);
}

void store_at(const Psana::EvrData::IOConfigV1* obj, hdf5pp::Group group, long index, int version)
{
  store_IOConfigV1(obj, group, index, version, true);
}

boost::shared_ptr<PSEvt::Proxy<Psana::EvrData::IOConfigV2> > make_IOConfigV2(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::IOConfigV2> >(boost::make_shared<IOConfigV2_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::EvrData::IOConfigV2> >(boost::shared_ptr<Psana::EvrData::IOConfigV2>());
  }
}

void make_datasets(const Psana::EvrData::IOConfigV2& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_IOConfigV2_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.IOConfigV2", version);
  }
}

void store_IOConfigV2(const Psana::EvrData::IOConfigV2* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_IOConfigV2_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EvrData.IOConfigV2", version);
  }
}

void store(const Psana::EvrData::IOConfigV2& obj, hdf5pp::Group group, int version) 
{
  store_IOConfigV2(&obj, group, 0, version, false);
}

void store_at(const Psana::EvrData::IOConfigV2* obj, hdf5pp::Group group, long index, int version)
{
  store_IOConfigV2(obj, group, index, version, true);
}

} // namespace EvrData
} // namespace psddl_hdf2psana
