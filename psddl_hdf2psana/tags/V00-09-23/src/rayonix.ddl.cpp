
// *** Do not edit this file, it is auto-generated ***

#include "psddl_hdf2psana/rayonix.ddl.h"
#include "hdf5pp/ArrayType.h"
#include "hdf5pp/CompoundType.h"
#include "hdf5pp/EnumType.h"
#include "hdf5pp/VlenType.h"
#include "hdf5pp/Utils.h"
#include "PSEvt/DataProxy.h"
#include "psddl_hdf2psana/Exceptions.h"
namespace psddl_hdf2psana {
namespace Rayonix {

hdf5pp::Type ns_ConfigV1_v0_dataset_config_stored_type()
{
  typedef ns_ConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("binning_f", offsetof(DsType, binning_f), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("binning_s", offsetof(DsType, binning_s), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("exposure", offsetof(DsType, exposure), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("trigger", offsetof(DsType, trigger), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("rawMode", offsetof(DsType, rawMode), hdf5pp::TypeTraits<uint16_t>::stored_type());
  type.insert("darkFlag", offsetof(DsType, darkFlag), hdf5pp::TypeTraits<uint16_t>::stored_type());
  hdf5pp::EnumType<uint32_t> _enum_type_readoutMode = hdf5pp::EnumType<uint32_t>::enumType();
  _enum_type_readoutMode.insert("Standard", Psana::Rayonix::ConfigV1::Standard);
  _enum_type_readoutMode.insert("HighGain", Psana::Rayonix::ConfigV1::HighGain);
  _enum_type_readoutMode.insert("LowNoise", Psana::Rayonix::ConfigV1::LowNoise);
  _enum_type_readoutMode.insert("EDR", Psana::Rayonix::ConfigV1::EDR);
  type.insert("readoutMode", offsetof(DsType, readoutMode), _enum_type_readoutMode);
  type.insert("deviceID", offsetof(DsType, deviceID), hdf5pp::TypeTraits<const char*>::stored_type(40));
  return type;
}

hdf5pp::Type ns_ConfigV1_v0::dataset_config::stored_type()
{
  static hdf5pp::Type type = ns_ConfigV1_v0_dataset_config_stored_type();
  return type;
}

hdf5pp::Type ns_ConfigV1_v0_dataset_config_native_type()
{
  typedef ns_ConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("binning_f", offsetof(DsType, binning_f), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("binning_s", offsetof(DsType, binning_s), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("exposure", offsetof(DsType, exposure), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("trigger", offsetof(DsType, trigger), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("rawMode", offsetof(DsType, rawMode), hdf5pp::TypeTraits<uint16_t>::native_type());
  type.insert("darkFlag", offsetof(DsType, darkFlag), hdf5pp::TypeTraits<uint16_t>::native_type());
  hdf5pp::EnumType<uint32_t> _enum_type_readoutMode = hdf5pp::EnumType<uint32_t>::enumType();
  _enum_type_readoutMode.insert("Standard", Psana::Rayonix::ConfigV1::Standard);
  _enum_type_readoutMode.insert("HighGain", Psana::Rayonix::ConfigV1::HighGain);
  _enum_type_readoutMode.insert("LowNoise", Psana::Rayonix::ConfigV1::LowNoise);
  _enum_type_readoutMode.insert("EDR", Psana::Rayonix::ConfigV1::EDR);
  type.insert("readoutMode", offsetof(DsType, readoutMode), _enum_type_readoutMode);
  type.insert("deviceID", offsetof(DsType, deviceID), hdf5pp::TypeTraits<const char*>::native_type(40));
  return type;
}

hdf5pp::Type ns_ConfigV1_v0::dataset_config::native_type()
{
  static hdf5pp::Type type = ns_ConfigV1_v0_dataset_config_native_type();
  return type;
}

ns_ConfigV1_v0::dataset_config::dataset_config()
{
}

ns_ConfigV1_v0::dataset_config::dataset_config(const Psana::Rayonix::ConfigV1& psanaobj)
  : binning_f(psanaobj.binning_f())
  , binning_s(psanaobj.binning_s())
  , exposure(psanaobj.exposure())
  , trigger(psanaobj.trigger())
  , rawMode(psanaobj.rawMode())
  , darkFlag(psanaobj.darkFlag())
  , readoutMode(psanaobj.readoutMode())
{
  strncpy(deviceID, psanaobj.deviceID(), 40);
}

ns_ConfigV1_v0::dataset_config::~dataset_config()
{
}
uint8_t ConfigV1_v0::binning_f() const {
  if (not m_ds_config) read_ds_config();
  return uint8_t(m_ds_config->binning_f);
}
uint8_t ConfigV1_v0::binning_s() const {
  if (not m_ds_config) read_ds_config();
  return uint8_t(m_ds_config->binning_s);
}
uint32_t ConfigV1_v0::exposure() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->exposure);
}
uint32_t ConfigV1_v0::trigger() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->trigger);
}
uint16_t ConfigV1_v0::rawMode() const {
  if (not m_ds_config) read_ds_config();
  return uint16_t(m_ds_config->rawMode);
}
uint16_t ConfigV1_v0::darkFlag() const {
  if (not m_ds_config) read_ds_config();
  return uint16_t(m_ds_config->darkFlag);
}
Psana::Rayonix::ConfigV1::ReadoutMode ConfigV1_v0::readoutMode() const {
  if (not m_ds_config) read_ds_config();
  return Psana::Rayonix::ConfigV1::ReadoutMode(m_ds_config->readoutMode);
}
const char* ConfigV1_v0::deviceID() const {
  if (not m_ds_config) read_ds_config();
  return (const char*)(m_ds_config->deviceID);
}
void ConfigV1_v0::read_ds_config() const {
  m_ds_config = hdf5pp::Utils::readGroup<Rayonix::ns_ConfigV1_v0::dataset_config>(m_group, "config", m_idx);
}

void make_datasets_ConfigV1_v0(const Psana::Rayonix::ConfigV1& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = Rayonix::ns_ConfigV1_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_ConfigV1_v0(const Psana::Rayonix::ConfigV1* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    Rayonix::ns_ConfigV1_v0::dataset_config ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "config", index < 0 ? index : index + 1);
  }
}

boost::shared_ptr<PSEvt::Proxy<Psana::Rayonix::ConfigV1> > make_ConfigV1(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::Rayonix::ConfigV1> >(boost::make_shared<ConfigV1_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::Rayonix::ConfigV1> >(boost::shared_ptr<Psana::Rayonix::ConfigV1>());
  }
}

void make_datasets(const Psana::Rayonix::ConfigV1& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_ConfigV1_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Rayonix.ConfigV1", version);
  }
}

void store_ConfigV1(const Psana::Rayonix::ConfigV1* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_ConfigV1_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Rayonix.ConfigV1", version);
  }
}

void store(const Psana::Rayonix::ConfigV1& obj, hdf5pp::Group group, int version) 
{
  store_ConfigV1(&obj, group, 0, version, false);
}

void store_at(const Psana::Rayonix::ConfigV1* obj, hdf5pp::Group group, long index, int version)
{
  store_ConfigV1(obj, group, index, version, true);
}


hdf5pp::Type ns_ConfigV2_v0_dataset_config_stored_type()
{
  typedef ns_ConfigV2_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("binning_f", offsetof(DsType, binning_f), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("binning_s", offsetof(DsType, binning_s), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("testPattern", offsetof(DsType, testPattern), hdf5pp::TypeTraits<int16_t>::stored_type());
  type.insert("exposure", offsetof(DsType, exposure), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("trigger", offsetof(DsType, trigger), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("rawMode", offsetof(DsType, rawMode), hdf5pp::TypeTraits<uint16_t>::stored_type());
  type.insert("darkFlag", offsetof(DsType, darkFlag), hdf5pp::TypeTraits<uint16_t>::stored_type());
  hdf5pp::EnumType<uint32_t> _enum_type_readoutMode = hdf5pp::EnumType<uint32_t>::enumType();
  _enum_type_readoutMode.insert("Unknown", Psana::Rayonix::ConfigV2::Unknown);
  _enum_type_readoutMode.insert("Standard", Psana::Rayonix::ConfigV2::Standard);
  _enum_type_readoutMode.insert("HighGain", Psana::Rayonix::ConfigV2::HighGain);
  _enum_type_readoutMode.insert("LowNoise", Psana::Rayonix::ConfigV2::LowNoise);
  _enum_type_readoutMode.insert("HDR", Psana::Rayonix::ConfigV2::HDR);
  type.insert("readoutMode", offsetof(DsType, readoutMode), _enum_type_readoutMode);
  type.insert("deviceID", offsetof(DsType, deviceID), hdf5pp::TypeTraits<const char*>::stored_type());
  return type;
}

hdf5pp::Type ns_ConfigV2_v0::dataset_config::stored_type()
{
  static hdf5pp::Type type = ns_ConfigV2_v0_dataset_config_stored_type();
  return type;
}

hdf5pp::Type ns_ConfigV2_v0_dataset_config_native_type()
{
  typedef ns_ConfigV2_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("binning_f", offsetof(DsType, binning_f), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("binning_s", offsetof(DsType, binning_s), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("testPattern", offsetof(DsType, testPattern), hdf5pp::TypeTraits<int16_t>::native_type());
  type.insert("exposure", offsetof(DsType, exposure), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("trigger", offsetof(DsType, trigger), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("rawMode", offsetof(DsType, rawMode), hdf5pp::TypeTraits<uint16_t>::native_type());
  type.insert("darkFlag", offsetof(DsType, darkFlag), hdf5pp::TypeTraits<uint16_t>::native_type());
  hdf5pp::EnumType<uint32_t> _enum_type_readoutMode = hdf5pp::EnumType<uint32_t>::enumType();
  _enum_type_readoutMode.insert("Unknown", Psana::Rayonix::ConfigV2::Unknown);
  _enum_type_readoutMode.insert("Standard", Psana::Rayonix::ConfigV2::Standard);
  _enum_type_readoutMode.insert("HighGain", Psana::Rayonix::ConfigV2::HighGain);
  _enum_type_readoutMode.insert("LowNoise", Psana::Rayonix::ConfigV2::LowNoise);
  _enum_type_readoutMode.insert("HDR", Psana::Rayonix::ConfigV2::HDR);
  type.insert("readoutMode", offsetof(DsType, readoutMode), _enum_type_readoutMode);
  type.insert("deviceID", offsetof(DsType, deviceID), hdf5pp::TypeTraits<const char*>::native_type());
  return type;
}

hdf5pp::Type ns_ConfigV2_v0::dataset_config::native_type()
{
  static hdf5pp::Type type = ns_ConfigV2_v0_dataset_config_native_type();
  return type;
}

ns_ConfigV2_v0::dataset_config::dataset_config()
{
}

ns_ConfigV2_v0::dataset_config::dataset_config(const Psana::Rayonix::ConfigV2& psanaobj)
  : binning_f(psanaobj.binning_f())
  , binning_s(psanaobj.binning_s())
  , testPattern(psanaobj.testPattern())
  , exposure(psanaobj.exposure())
  , trigger(psanaobj.trigger())
  , rawMode(psanaobj.rawMode())
  , darkFlag(psanaobj.darkFlag())
  , readoutMode(psanaobj.readoutMode())
  , deviceID(0)
{
  deviceID = strdup(psanaobj.deviceID());
}

ns_ConfigV2_v0::dataset_config::~dataset_config()
{
}
uint8_t ConfigV2_v0::binning_f() const {
  if (not m_ds_config) read_ds_config();
  return uint8_t(m_ds_config->binning_f);
}
uint8_t ConfigV2_v0::binning_s() const {
  if (not m_ds_config) read_ds_config();
  return uint8_t(m_ds_config->binning_s);
}
int16_t ConfigV2_v0::testPattern() const {
  if (not m_ds_config) read_ds_config();
  return int16_t(m_ds_config->testPattern);
}
uint32_t ConfigV2_v0::exposure() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->exposure);
}
uint32_t ConfigV2_v0::trigger() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->trigger);
}
uint16_t ConfigV2_v0::rawMode() const {
  if (not m_ds_config) read_ds_config();
  return uint16_t(m_ds_config->rawMode);
}
uint16_t ConfigV2_v0::darkFlag() const {
  if (not m_ds_config) read_ds_config();
  return uint16_t(m_ds_config->darkFlag);
}
Psana::Rayonix::ConfigV2::ReadoutMode ConfigV2_v0::readoutMode() const {
  if (not m_ds_config) read_ds_config();
  return Psana::Rayonix::ConfigV2::ReadoutMode(m_ds_config->readoutMode);
}
const char* ConfigV2_v0::deviceID() const {
  if (not m_ds_config) read_ds_config();
  return (const char*)(m_ds_config->deviceID);
}
void ConfigV2_v0::read_ds_config() const {
  m_ds_config = hdf5pp::Utils::readGroup<Rayonix::ns_ConfigV2_v0::dataset_config>(m_group, "config", m_idx);
}

void make_datasets_ConfigV2_v0(const Psana::Rayonix::ConfigV2& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = Rayonix::ns_ConfigV2_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_ConfigV2_v0(const Psana::Rayonix::ConfigV2* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    Rayonix::ns_ConfigV2_v0::dataset_config ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "config", index < 0 ? index : index + 1);
  }
}

boost::shared_ptr<PSEvt::Proxy<Psana::Rayonix::ConfigV2> > make_ConfigV2(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::Rayonix::ConfigV2> >(boost::make_shared<ConfigV2_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::Rayonix::ConfigV2> >(boost::shared_ptr<Psana::Rayonix::ConfigV2>());
  }
}

void make_datasets(const Psana::Rayonix::ConfigV2& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_ConfigV2_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Rayonix.ConfigV2", version);
  }
}

void store_ConfigV2(const Psana::Rayonix::ConfigV2* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_ConfigV2_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Rayonix.ConfigV2", version);
  }
}

void store(const Psana::Rayonix::ConfigV2& obj, hdf5pp::Group group, int version) 
{
  store_ConfigV2(&obj, group, 0, version, false);
}

void store_at(const Psana::Rayonix::ConfigV2* obj, hdf5pp::Group group, long index, int version)
{
  store_ConfigV2(obj, group, index, version, true);
}

} // namespace Rayonix
} // namespace psddl_hdf2psana
