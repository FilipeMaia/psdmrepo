
// *** Do not edit this file, it is auto-generated ***

#include "psddl_hdf2psana/arraychar.ddl.h"
#include "hdf5pp/ArrayType.h"
#include "hdf5pp/CompoundType.h"
#include "hdf5pp/EnumType.h"
#include "hdf5pp/VlenType.h"
#include "hdf5pp/Utils.h"
#include "PSEvt/DataProxy.h"
#include "psddl_hdf2psana/Exceptions.h"
namespace psddl_hdf2psana {
namespace Arraychar {

hdf5pp::Type ns_DataV1_v0_dataset_data_stored_type()
{
  typedef ns_DataV1_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("numChars", offsetof(DsType, numChars), hdf5pp::TypeTraits<uint64_t>::stored_type());
  hdf5pp::VlenType _array_type_data = hdf5pp::VlenType::vlenType(hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("data", offsetof(DsType, vlen_data), _array_type_data);
  return type;
}

hdf5pp::Type ns_DataV1_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_DataV1_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_DataV1_v0_dataset_data_native_type()
{
  typedef ns_DataV1_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("numChars", offsetof(DsType, numChars), hdf5pp::TypeTraits<uint64_t>::native_type());
  hdf5pp::VlenType _array_type_data = hdf5pp::VlenType::vlenType(hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("data", offsetof(DsType, vlen_data), _array_type_data);
  return type;
}

hdf5pp::Type ns_DataV1_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_DataV1_v0_dataset_data_native_type();
  return type;
}

ns_DataV1_v0::dataset_data::dataset_data()
{
  this->vlen_data = 0;
  this->data = 0;
}

ns_DataV1_v0::dataset_data::dataset_data(const Psana::Arraychar::DataV1& psanaobj)
  : numChars(psanaobj.numChars())
  , vlen_data(0)
  , data(0)
{
  {
    const __typeof__(psanaobj.data())& arr = psanaobj.data();
    vlen_data = arr.size();
    data = static_cast<uint8_t*>(malloc(vlen_data*sizeof(uint8_t)));
    std::copy(arr.begin(), arr.end(), data);
  }
}

ns_DataV1_v0::dataset_data::~dataset_data()
{
  free(this->data);
}
uint64_t DataV1_v0::numChars() const {
  if (not m_ds_data) read_ds_data();
  return uint64_t(m_ds_data->numChars);
}
ndarray<const uint8_t, 1> DataV1_v0::data() const {
  if (not m_ds_data) read_ds_data();
  boost::shared_ptr<uint8_t> ptr(m_ds_data, m_ds_data->data);
  return make_ndarray(ptr, m_ds_data->vlen_data);
}
void DataV1_v0::read_ds_data() const {
  m_ds_data = hdf5pp::Utils::readGroup<Arraychar::ns_DataV1_v0::dataset_data>(m_group, "data", m_idx);
}

void make_datasets_DataV1_v0(const Psana::Arraychar::DataV1& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = Arraychar::ns_DataV1_v0::dataset_data::stored_type();
    hdf5pp::Utils::createDataset(group, "data", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_DataV1_v0(const Psana::Arraychar::DataV1* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    Arraychar::ns_DataV1_v0::dataset_data ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "data", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "data", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "data", index < 0 ? index : index + 1);
  }
}

boost::shared_ptr<PSEvt::Proxy<Psana::Arraychar::DataV1> > make_DataV1(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::Arraychar::DataV1> >(boost::make_shared<DataV1_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::Arraychar::DataV1> >(boost::shared_ptr<Psana::Arraychar::DataV1>());
  }
}

void make_datasets(const Psana::Arraychar::DataV1& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_DataV1_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Arraychar.DataV1", version);
  }
}

void store_DataV1(const Psana::Arraychar::DataV1* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_DataV1_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Arraychar.DataV1", version);
  }
}

void store(const Psana::Arraychar::DataV1& obj, hdf5pp::Group group, int version) 
{
  store_DataV1(&obj, group, 0, version, false);
}

void store_at(const Psana::Arraychar::DataV1* obj, hdf5pp::Group group, long index, int version)
{
  store_DataV1(obj, group, index, version, true);
}

} // namespace Arraychar
} // namespace psddl_hdf2psana
