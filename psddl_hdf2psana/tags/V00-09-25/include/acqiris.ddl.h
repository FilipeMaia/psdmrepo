#ifndef PSDDL_HDF2PSANA_ACQIRIS_DDL_H
#define PSDDL_HDF2PSANA_ACQIRIS_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include "psddl_psana/acqiris.ddl.h"
#include "hdf5pp/Group.h"
#include "hdf5pp/Type.h"
#include "PSEvt/Proxy.h"
#include "psddl_hdf2psana/ChunkPolicy.h"
namespace psddl_hdf2psana {
namespace Acqiris {

namespace ns_VertV1_v0 {
struct dataset_data {
  static hdf5pp::Type native_type();
  static hdf5pp::Type stored_type();

  dataset_data();
  dataset_data(const Psana::Acqiris::VertV1& psanaobj);
  ~dataset_data();

  double fullScale;
  double offset;
  uint32_t coupling;
  uint32_t bandwidth;

  operator Psana::Acqiris::VertV1() const { return Psana::Acqiris::VertV1(fullScale, offset, coupling, bandwidth); }

};
}

namespace ns_HorizV1_v0 {
struct dataset_data {
  static hdf5pp::Type native_type();
  static hdf5pp::Type stored_type();

  dataset_data();
  dataset_data(const Psana::Acqiris::HorizV1& psanaobj);
  ~dataset_data();

  double sampInterval;
  double delayTime;
  uint32_t nbrSamples;
  uint32_t nbrSegments;

  operator Psana::Acqiris::HorizV1() const { return Psana::Acqiris::HorizV1(sampInterval, delayTime, nbrSamples, nbrSegments); }

};
}

namespace ns_TrigV1_v0 {
struct dataset_data {
  static hdf5pp::Type native_type();
  static hdf5pp::Type stored_type();

  dataset_data();
  dataset_data(const Psana::Acqiris::TrigV1& psanaobj);
  ~dataset_data();

  uint32_t coupling;
  uint32_t input;
  uint32_t slope;
  double level;

  operator Psana::Acqiris::TrigV1() const { return Psana::Acqiris::TrigV1(coupling, input, slope, level); }

};
}

namespace ns_ConfigV1_v0 {
struct dataset_config {
  static hdf5pp::Type native_type();
  static hdf5pp::Type stored_type();

  dataset_config();
  dataset_config(const Psana::Acqiris::ConfigV1& psanaobj);
  ~dataset_config();

  uint32_t nbrConvertersPerChannel;
  uint32_t channelMask;
  uint32_t nbrBanks;
  uint32_t nbrChannels;


};
}


class ConfigV1_v0 : public Psana::Acqiris::ConfigV1 {
public:
  typedef Psana::Acqiris::ConfigV1 PsanaType;
  ConfigV1_v0() {}
  ConfigV1_v0(hdf5pp::Group group, hsize_t idx)
    : m_group(group), m_idx(idx) {}
  virtual ~ConfigV1_v0() {}
  virtual uint32_t nbrConvertersPerChannel() const;
  virtual uint32_t channelMask() const;
  virtual uint32_t nbrBanks() const;
  virtual const Psana::Acqiris::TrigV1& trig() const;
  virtual const Psana::Acqiris::HorizV1& horiz() const;
  virtual ndarray<const Psana::Acqiris::VertV1, 1> vert() const;
  virtual uint32_t nbrChannels() const;
private:
  mutable hdf5pp::Group m_group;
  hsize_t m_idx;
  mutable boost::shared_ptr<Acqiris::ns_ConfigV1_v0::dataset_config> m_ds_config;
  void read_ds_config() const;
  mutable boost::shared_ptr<Acqiris::ns_HorizV1_v0::dataset_data> m_ds_horiz;
  void read_ds_horiz() const;
  mutable Psana::Acqiris::HorizV1 m_ds_storage_horiz;
  mutable boost::shared_ptr<Acqiris::ns_TrigV1_v0::dataset_data> m_ds_trig;
  void read_ds_trig() const;
  mutable Psana::Acqiris::TrigV1 m_ds_storage_trig;
  mutable ndarray<const Psana::Acqiris::VertV1, 1> m_ds_vert;
  void read_ds_vert() const;
};

boost::shared_ptr<PSEvt::Proxy<Psana::Acqiris::ConfigV1> > make_ConfigV1(int version, hdf5pp::Group group, hsize_t idx);

/// Store object as a single instance (scalar dataset) inside specified group.
void store(const Psana::Acqiris::ConfigV1& obj, hdf5pp::Group group, int version = -1);
/// Create container (rank=1) datasets for storing objects of specified type.
void make_datasets(const Psana::Acqiris::ConfigV1& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version = -1);
/// Add one more object to the containers created by previous method at the specified index,
/// negative index means append to the end of dataset. If pointer to object is zero then
/// datsets are extended with zero-filled of default-initialized data.
void store_at(const Psana::Acqiris::ConfigV1* obj, hdf5pp::Group group, long index = -1, int version = -1);


namespace ns_TimestampV1_v0 {
struct dataset_data {
  static hdf5pp::Type native_type();
  static hdf5pp::Type stored_type();

  dataset_data();
  dataset_data(const Psana::Acqiris::TimestampV1& psanaobj);
  ~dataset_data();

  double pos;
  uint64_t value;


};
}
boost::shared_ptr<PSEvt::Proxy<Psana::Acqiris::DataDescV1> > make_DataDescV1(int version, hdf5pp::Group group, hsize_t idx, const boost::shared_ptr<Psana::Acqiris::ConfigV1>& cfg);

/// Store object as a single instance (scalar dataset) inside specified group.
void store(const Psana::Acqiris::DataDescV1& obj, hdf5pp::Group group, int version = -1);
/// Create container (rank=1) datasets for storing objects of specified type.
void make_datasets(const Psana::Acqiris::DataDescV1& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version = -1);
/// Add one more object to the containers created by previous method at the specified index,
/// negative index means append to the end of dataset. If pointer to object is zero then
/// datsets are extended with zero-filled of default-initialized data.
void store_at(const Psana::Acqiris::DataDescV1* obj, hdf5pp::Group group, long index = -1, int version = -1);


namespace ns_TdcChannel_v0 {
struct dataset_data {
  static hdf5pp::Type native_type();
  static hdf5pp::Type stored_type();

  dataset_data();
  dataset_data(const Psana::Acqiris::TdcChannel& psanaobj);
  ~dataset_data();

  int32_t channel;
  uint32_t _mode_int;
  uint16_t slope;
  uint16_t mode;
  double level;

  operator Psana::Acqiris::TdcChannel() const { return Psana::Acqiris::TdcChannel(Psana::Acqiris::TdcChannel::Channel(channel), Psana::Acqiris::TdcChannel::Slope(slope), Psana::Acqiris::TdcChannel::Mode(mode), level); }

};
}

namespace ns_TdcAuxIO_v0 {
struct dataset_data {
  static hdf5pp::Type native_type();
  static hdf5pp::Type stored_type();

  dataset_data();
  dataset_data(const Psana::Acqiris::TdcAuxIO& psanaobj);
  ~dataset_data();

  uint32_t channel;
  uint32_t mode;
  uint32_t term;

  operator Psana::Acqiris::TdcAuxIO() const { return Psana::Acqiris::TdcAuxIO(Psana::Acqiris::TdcAuxIO::Channel(channel), Psana::Acqiris::TdcAuxIO::Mode(mode), Psana::Acqiris::TdcAuxIO::Termination(term)); }

};
}

namespace ns_TdcVetoIO_v0 {
struct dataset_data {
  static hdf5pp::Type native_type();
  static hdf5pp::Type stored_type();

  dataset_data();
  dataset_data(const Psana::Acqiris::TdcVetoIO& psanaobj);
  ~dataset_data();

  uint32_t channel;
  uint32_t mode;
  uint32_t term;

  operator Psana::Acqiris::TdcVetoIO() const { return Psana::Acqiris::TdcVetoIO(Psana::Acqiris::TdcVetoIO::Mode(mode), Psana::Acqiris::TdcVetoIO::Termination(term)); }

};
}


class TdcConfigV1_v0 : public Psana::Acqiris::TdcConfigV1 {
public:
  typedef Psana::Acqiris::TdcConfigV1 PsanaType;
  TdcConfigV1_v0() {}
  TdcConfigV1_v0(hdf5pp::Group group, hsize_t idx)
    : m_group(group), m_idx(idx) {}
  virtual ~TdcConfigV1_v0() {}
  virtual ndarray<const Psana::Acqiris::TdcChannel, 1> channels() const;
  virtual ndarray<const Psana::Acqiris::TdcAuxIO, 1> auxio() const;
  virtual const Psana::Acqiris::TdcVetoIO& veto() const;
private:
  mutable hdf5pp::Group m_group;
  hsize_t m_idx;
  mutable boost::shared_ptr<Acqiris::ns_TdcVetoIO_v0::dataset_data> m_ds_veto;
  void read_ds_veto() const;
  mutable Psana::Acqiris::TdcVetoIO m_ds_storage_veto;
  mutable ndarray<const Psana::Acqiris::TdcChannel, 1> m_ds_channel;
  void read_ds_channel() const;
  mutable ndarray<const Psana::Acqiris::TdcAuxIO, 1> m_ds_auxio;
  void read_ds_auxio() const;
};

boost::shared_ptr<PSEvt::Proxy<Psana::Acqiris::TdcConfigV1> > make_TdcConfigV1(int version, hdf5pp::Group group, hsize_t idx);

/// Store object as a single instance (scalar dataset) inside specified group.
void store(const Psana::Acqiris::TdcConfigV1& obj, hdf5pp::Group group, int version = -1);
/// Create container (rank=1) datasets for storing objects of specified type.
void make_datasets(const Psana::Acqiris::TdcConfigV1& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version = -1);
/// Add one more object to the containers created by previous method at the specified index,
/// negative index means append to the end of dataset. If pointer to object is zero then
/// datsets are extended with zero-filled of default-initialized data.
void store_at(const Psana::Acqiris::TdcConfigV1* obj, hdf5pp::Group group, long index = -1, int version = -1);


namespace ns_TdcDataV1_Item_v0 {
struct dataset_data {
  static hdf5pp::Type native_type();
  static hdf5pp::Type stored_type();

  dataset_data();
  dataset_data(const Psana::Acqiris::TdcDataV1_Item& psanaobj);
  ~dataset_data();

  uint8_t source;
  uint8_t overflow;
  uint32_t value;

  operator Psana::Acqiris::TdcDataV1_Item() const { return Psana::Acqiris::TdcDataV1_Item(value, Psana::Acqiris::TdcDataV1_Item::Source(source), overflow); }

};
}


class TdcDataV1_v0 : public Psana::Acqiris::TdcDataV1 {
public:
  typedef Psana::Acqiris::TdcDataV1 PsanaType;
  TdcDataV1_v0() {}
  TdcDataV1_v0(hdf5pp::Group group, hsize_t idx)
    : m_group(group), m_idx(idx) {}
  TdcDataV1_v0(const ndarray<const Psana::Acqiris::TdcDataV1_Item, 1>& ds) : m_ds_data(ds) {}
  virtual ~TdcDataV1_v0() {}
  virtual ndarray<const Psana::Acqiris::TdcDataV1_Item, 1> data() const;
private:
  mutable hdf5pp::Group m_group;
  hsize_t m_idx;
  mutable ndarray<const Psana::Acqiris::TdcDataV1_Item, 1> m_ds_data;
  void read_ds_data() const;
};

boost::shared_ptr<PSEvt::Proxy<Psana::Acqiris::TdcDataV1> > make_TdcDataV1(int version, hdf5pp::Group group, hsize_t idx);

/// Store object as a single instance (scalar dataset) inside specified group.
void store(const Psana::Acqiris::TdcDataV1& obj, hdf5pp::Group group, int version = -1);
/// Create container (rank=1) datasets for storing objects of specified type.
void make_datasets(const Psana::Acqiris::TdcDataV1& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version = -1);
/// Add one more object to the containers created by previous method at the specified index,
/// negative index means append to the end of dataset. If pointer to object is zero then
/// datsets are extended with zero-filled of default-initialized data.
void store_at(const Psana::Acqiris::TdcDataV1* obj, hdf5pp::Group group, long index = -1, int version = -1);

} // namespace Acqiris
} // namespace psddl_hdf2psana
#endif // PSDDL_HDF2PSANA_ACQIRIS_DDL_H
