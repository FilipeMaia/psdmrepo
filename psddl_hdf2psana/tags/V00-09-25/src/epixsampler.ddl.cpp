
// *** Do not edit this file, it is auto-generated ***

#include "psddl_hdf2psana/epixsampler.ddl.h"
#include "hdf5pp/ArrayType.h"
#include "hdf5pp/CompoundType.h"
#include "hdf5pp/EnumType.h"
#include "hdf5pp/VlenType.h"
#include "hdf5pp/Utils.h"
#include "PSEvt/DataProxy.h"
#include "psddl_hdf2psana/Exceptions.h"
namespace psddl_hdf2psana {
namespace EpixSampler {

hdf5pp::Type ns_ConfigV1_v0_dataset_config_stored_type()
{
  typedef ns_ConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("version", offsetof(DsType, version), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("runTrigDelay", offsetof(DsType, runTrigDelay), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("daqTrigDelay", offsetof(DsType, daqTrigDelay), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("daqSetting", offsetof(DsType, daqSetting), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("adcClkHalfT", offsetof(DsType, adcClkHalfT), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("adcPipelineDelay", offsetof(DsType, adcPipelineDelay), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("digitalCardId0", offsetof(DsType, digitalCardId0), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("digitalCardId1", offsetof(DsType, digitalCardId1), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("analogCardId0", offsetof(DsType, analogCardId0), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("analogCardId1", offsetof(DsType, analogCardId1), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("numberOfChannels", offsetof(DsType, numberOfChannels), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("samplesPerChannel", offsetof(DsType, samplesPerChannel), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("baseClockFrequency", offsetof(DsType, baseClockFrequency), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("testPatternEnable", offsetof(DsType, testPatternEnable), hdf5pp::TypeTraits<uint8_t>::stored_type());
  return type;
}

hdf5pp::Type ns_ConfigV1_v0::dataset_config::stored_type()
{
  static hdf5pp::Type type = ns_ConfigV1_v0_dataset_config_stored_type();
  return type;
}

hdf5pp::Type ns_ConfigV1_v0_dataset_config_native_type()
{
  typedef ns_ConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("version", offsetof(DsType, version), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("runTrigDelay", offsetof(DsType, runTrigDelay), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("daqTrigDelay", offsetof(DsType, daqTrigDelay), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("daqSetting", offsetof(DsType, daqSetting), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("adcClkHalfT", offsetof(DsType, adcClkHalfT), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("adcPipelineDelay", offsetof(DsType, adcPipelineDelay), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("digitalCardId0", offsetof(DsType, digitalCardId0), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("digitalCardId1", offsetof(DsType, digitalCardId1), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("analogCardId0", offsetof(DsType, analogCardId0), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("analogCardId1", offsetof(DsType, analogCardId1), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("numberOfChannels", offsetof(DsType, numberOfChannels), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("samplesPerChannel", offsetof(DsType, samplesPerChannel), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("baseClockFrequency", offsetof(DsType, baseClockFrequency), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("testPatternEnable", offsetof(DsType, testPatternEnable), hdf5pp::TypeTraits<uint8_t>::native_type());
  return type;
}

hdf5pp::Type ns_ConfigV1_v0::dataset_config::native_type()
{
  static hdf5pp::Type type = ns_ConfigV1_v0_dataset_config_native_type();
  return type;
}

ns_ConfigV1_v0::dataset_config::dataset_config()
{
}

ns_ConfigV1_v0::dataset_config::dataset_config(const Psana::EpixSampler::ConfigV1& psanaobj)
  : version(psanaobj.version())
  , runTrigDelay(psanaobj.runTrigDelay())
  , daqTrigDelay(psanaobj.daqTrigDelay())
  , daqSetting(psanaobj.daqSetting())
  , adcClkHalfT(psanaobj.adcClkHalfT())
  , adcPipelineDelay(psanaobj.adcPipelineDelay())
  , digitalCardId0(psanaobj.digitalCardId0())
  , digitalCardId1(psanaobj.digitalCardId1())
  , analogCardId0(psanaobj.analogCardId0())
  , analogCardId1(psanaobj.analogCardId1())
  , numberOfChannels(psanaobj.numberOfChannels())
  , samplesPerChannel(psanaobj.samplesPerChannel())
  , baseClockFrequency(psanaobj.baseClockFrequency())
  , testPatternEnable(psanaobj.testPatternEnable())
{
}

ns_ConfigV1_v0::dataset_config::~dataset_config()
{
}
uint32_t ConfigV1_v0::version() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->version);
}
uint32_t ConfigV1_v0::runTrigDelay() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->runTrigDelay);
}
uint32_t ConfigV1_v0::daqTrigDelay() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->daqTrigDelay);
}
uint32_t ConfigV1_v0::daqSetting() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->daqSetting);
}
uint32_t ConfigV1_v0::adcClkHalfT() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->adcClkHalfT);
}
uint32_t ConfigV1_v0::adcPipelineDelay() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->adcPipelineDelay);
}
uint32_t ConfigV1_v0::digitalCardId0() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->digitalCardId0);
}
uint32_t ConfigV1_v0::digitalCardId1() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->digitalCardId1);
}
uint32_t ConfigV1_v0::analogCardId0() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->analogCardId0);
}
uint32_t ConfigV1_v0::analogCardId1() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->analogCardId1);
}
uint32_t ConfigV1_v0::numberOfChannels() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->numberOfChannels);
}
uint32_t ConfigV1_v0::samplesPerChannel() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->samplesPerChannel);
}
uint32_t ConfigV1_v0::baseClockFrequency() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->baseClockFrequency);
}
uint8_t ConfigV1_v0::testPatternEnable() const {
  if (not m_ds_config) read_ds_config();
  return uint8_t(m_ds_config->testPatternEnable);
}
double
ConfigV1_v0::sampleInterval_sec() const{ 

    double v=0;
    for (unsigned r=baseClockFrequency(); r!=0; r>>=4)
      v += 10*(r & 0xf);
    return double(adcClkHalfT())*2.e-3/v;
 
}
void ConfigV1_v0::read_ds_config() const {
  m_ds_config = hdf5pp::Utils::readGroup<EpixSampler::ns_ConfigV1_v0::dataset_config>(m_group, "config", m_idx);
}

void make_datasets_ConfigV1_v0(const Psana::EpixSampler::ConfigV1& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = EpixSampler::ns_ConfigV1_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_ConfigV1_v0(const Psana::EpixSampler::ConfigV1* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    EpixSampler::ns_ConfigV1_v0::dataset_config ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "config", index < 0 ? index : index + 1);
  }
}

boost::shared_ptr<PSEvt::Proxy<Psana::EpixSampler::ConfigV1> > make_ConfigV1(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::EpixSampler::ConfigV1> >(boost::make_shared<ConfigV1_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::EpixSampler::ConfigV1> >(boost::shared_ptr<Psana::EpixSampler::ConfigV1>());
  }
}

void make_datasets(const Psana::EpixSampler::ConfigV1& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_ConfigV1_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EpixSampler.ConfigV1", version);
  }
}

void store_ConfigV1(const Psana::EpixSampler::ConfigV1* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_ConfigV1_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EpixSampler.ConfigV1", version);
  }
}

void store(const Psana::EpixSampler::ConfigV1& obj, hdf5pp::Group group, int version) 
{
  store_ConfigV1(&obj, group, 0, version, false);
}

void store_at(const Psana::EpixSampler::ConfigV1* obj, hdf5pp::Group group, long index, int version)
{
  store_ConfigV1(obj, group, index, version, true);
}


hdf5pp::Type ns_ElementV1_v0_dataset_data_stored_type()
{
  typedef ns_ElementV1_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("vc", offsetof(DsType, vc), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("lane", offsetof(DsType, lane), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("acqCount", offsetof(DsType, acqCount), hdf5pp::TypeTraits<uint16_t>::stored_type());
  type.insert("frameNumber", offsetof(DsType, frameNumber), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("ticks", offsetof(DsType, ticks), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("fiducials", offsetof(DsType, fiducials), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("lastWord", offsetof(DsType, lastWord), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_ElementV1_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_ElementV1_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_ElementV1_v0_dataset_data_native_type()
{
  typedef ns_ElementV1_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("vc", offsetof(DsType, vc), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("lane", offsetof(DsType, lane), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("acqCount", offsetof(DsType, acqCount), hdf5pp::TypeTraits<uint16_t>::native_type());
  type.insert("frameNumber", offsetof(DsType, frameNumber), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("ticks", offsetof(DsType, ticks), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("fiducials", offsetof(DsType, fiducials), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("lastWord", offsetof(DsType, lastWord), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_ElementV1_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_ElementV1_v0_dataset_data_native_type();
  return type;
}

ns_ElementV1_v0::dataset_data::dataset_data()
{
}

ns_ElementV1_v0::dataset_data::dataset_data(const Psana::EpixSampler::ElementV1& psanaobj)
  : vc(psanaobj.vc())
  , lane(psanaobj.lane())
  , acqCount(psanaobj.acqCount())
  , frameNumber(psanaobj.frameNumber())
  , ticks(psanaobj.ticks())
  , fiducials(psanaobj.fiducials())
  , lastWord(psanaobj.lastWord())
{
}

ns_ElementV1_v0::dataset_data::~dataset_data()
{
}
template <typename Config>
uint8_t ElementV1_v0<Config>::vc() const {
  if (not m_ds_data) read_ds_data();
  return uint8_t(m_ds_data->vc);
}
template <typename Config>
uint8_t ElementV1_v0<Config>::lane() const {
  if (not m_ds_data) read_ds_data();
  return uint8_t(m_ds_data->lane);
}
template <typename Config>
uint16_t ElementV1_v0<Config>::acqCount() const {
  if (not m_ds_data) read_ds_data();
  return uint16_t(m_ds_data->acqCount);
}
template <typename Config>
uint32_t ElementV1_v0<Config>::frameNumber() const {
  if (not m_ds_data) read_ds_data();
  return uint32_t(m_ds_data->frameNumber);
}
template <typename Config>
uint32_t ElementV1_v0<Config>::ticks() const {
  if (not m_ds_data) read_ds_data();
  return uint32_t(m_ds_data->ticks);
}
template <typename Config>
uint32_t ElementV1_v0<Config>::fiducials() const {
  if (not m_ds_data) read_ds_data();
  return uint32_t(m_ds_data->fiducials);
}
template <typename Config>
ndarray<const uint16_t, 2> ElementV1_v0<Config>::frame() const {
  if (m_ds_frame.empty()) read_ds_frame();
  return m_ds_frame;
}
template <typename Config>
ndarray<const uint16_t, 1> ElementV1_v0<Config>::temperatures() const {
  if (m_ds_temperatures.empty()) read_ds_temperatures();
  return m_ds_temperatures;
}
template <typename Config>
uint32_t ElementV1_v0<Config>::lastWord() const {
  if (not m_ds_data) read_ds_data();
  return uint32_t(m_ds_data->lastWord);
}
template <typename Config>
void ElementV1_v0<Config>::read_ds_data() const {
  m_ds_data = hdf5pp::Utils::readGroup<EpixSampler::ns_ElementV1_v0::dataset_data>(m_group, "data", m_idx);
}
template <typename Config>
void ElementV1_v0<Config>::read_ds_temperatures() const {
  m_ds_temperatures = hdf5pp::Utils::readNdarray<uint16_t, 1>(m_group, "temperatures", m_idx);
}
template <typename Config>
void ElementV1_v0<Config>::read_ds_frame() const {
  m_ds_frame = hdf5pp::Utils::readNdarray<uint16_t, 2>(m_group, "frame", m_idx);
}
template class ElementV1_v0<Psana::EpixSampler::ConfigV1>;

void make_datasets_ElementV1_v0(const Psana::EpixSampler::ElementV1& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = EpixSampler::ns_ElementV1_v0::dataset_data::stored_type();
    hdf5pp::Utils::createDataset(group, "data", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.temperatures()) PsanaArray;
    const PsanaArray& psana_array = obj.temperatures();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<uint16_t>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "temperatures", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.frame()) PsanaArray;
    const PsanaArray& psana_array = obj.frame();
    hsize_t dims[2];
    std::copy(psana_array.shape(), psana_array.shape()+2, dims);
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<uint16_t>::stored_type(), 2, dims);
    hdf5pp::Utils::createDataset(group, "frame", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_ElementV1_v0(const Psana::EpixSampler::ElementV1* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    EpixSampler::ns_ElementV1_v0::dataset_data ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "data", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "data", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "data", index < 0 ? index : index + 1);
  }
  if (append) {
    if (obj) {
      hdf5pp::Utils::storeNDArrayAt(group, "temperatures", obj->temperatures(), index);
    } else {
      hdf5pp::Utils::resizeDataset(group, "temperatures", index < 0 ? index : index + 1);
    }
  } else {
    hdf5pp::Utils::storeNDArray(group, "temperatures", obj->temperatures());
  }

  if (append) {
    if (obj) {
      hdf5pp::Utils::storeNDArrayAt(group, "frame", obj->frame(), index);
    } else {
      hdf5pp::Utils::resizeDataset(group, "frame", index < 0 ? index : index + 1);
    }
  } else {
    hdf5pp::Utils::storeNDArray(group, "frame", obj->frame());
  }

}

boost::shared_ptr<PSEvt::Proxy<Psana::EpixSampler::ElementV1> > make_ElementV1(int version, hdf5pp::Group group, hsize_t idx, const boost::shared_ptr<Psana::EpixSampler::ConfigV1>& cfg) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::EpixSampler::ElementV1> >(boost::make_shared<ElementV1_v0<Psana::EpixSampler::ConfigV1> >(group, idx, cfg));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::EpixSampler::ElementV1> >(boost::shared_ptr<Psana::EpixSampler::ElementV1>());
  }
}

void make_datasets(const Psana::EpixSampler::ElementV1& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_ElementV1_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EpixSampler.ElementV1", version);
  }
}

void store_ElementV1(const Psana::EpixSampler::ElementV1* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_ElementV1_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "EpixSampler.ElementV1", version);
  }
}

void store(const Psana::EpixSampler::ElementV1& obj, hdf5pp::Group group, int version) 
{
  store_ElementV1(&obj, group, 0, version, false);
}

void store_at(const Psana::EpixSampler::ElementV1* obj, hdf5pp::Group group, long index, int version)
{
  store_ElementV1(obj, group, index, version, true);
}

} // namespace EpixSampler
} // namespace psddl_hdf2psana
