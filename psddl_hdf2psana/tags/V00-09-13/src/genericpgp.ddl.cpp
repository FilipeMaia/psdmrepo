
// *** Do not edit this file, it is auto-generated ***

#include "psddl_hdf2psana/genericpgp.ddl.h"
#include "hdf5pp/ArrayType.h"
#include "hdf5pp/CompoundType.h"
#include "hdf5pp/EnumType.h"
#include "hdf5pp/VlenType.h"
#include "hdf5pp/Utils.h"
#include "PSEvt/DataProxy.h"
#include "psddl_hdf2psana/Exceptions.h"
namespace psddl_hdf2psana {
namespace GenericPgp {

hdf5pp::Type ns_CDimension_v0_dataset_data_stored_type()
{
  typedef ns_CDimension_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("rows", offsetof(DsType, rows), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("columns", offsetof(DsType, columns), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_CDimension_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_CDimension_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_CDimension_v0_dataset_data_native_type()
{
  typedef ns_CDimension_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("rows", offsetof(DsType, rows), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("columns", offsetof(DsType, columns), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_CDimension_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_CDimension_v0_dataset_data_native_type();
  return type;
}

ns_CDimension_v0::dataset_data::dataset_data()
{
}

ns_CDimension_v0::dataset_data::dataset_data(const Psana::GenericPgp::CDimension& psanaobj)
  : rows(psanaobj.rows())
  , columns(psanaobj.columns())
{
}

ns_CDimension_v0::dataset_data::~dataset_data()
{
}
uint32_t CDimension_v0::rows() const {
  if (not m_ds_data) read_ds_data();
  return uint32_t(m_ds_data->rows);
}
uint32_t CDimension_v0::columns() const {
  if (not m_ds_data) read_ds_data();
  return uint32_t(m_ds_data->columns);
}
void CDimension_v0::read_ds_data() const {
  m_ds_data = hdf5pp::Utils::readGroup<GenericPgp::ns_CDimension_v0::dataset_data>(m_group, "data", m_idx);
}

void make_datasets_CDimension_v0(const Psana::GenericPgp::CDimension& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = GenericPgp::ns_CDimension_v0::dataset_data::stored_type();
    hdf5pp::Utils::createDataset(group, "data", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_CDimension_v0(const Psana::GenericPgp::CDimension* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    GenericPgp::ns_CDimension_v0::dataset_data ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "data", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "data", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "data", index < 0 ? index : index + 1);
  }
}


hdf5pp::Type ns_CRegister_v0_dataset_data_stored_type()
{
  typedef ns_CRegister_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  hdf5pp::EnumType<uint8_t> _enum_type_action = hdf5pp::EnumType<uint8_t>::enumType();
  _enum_type_action.insert("RegisterRead", Psana::GenericPgp::CRegister::RegisterRead);
  _enum_type_action.insert("RegisterWrite", Psana::GenericPgp::CRegister::RegisterWrite);
  _enum_type_action.insert("RegisterWriteA", Psana::GenericPgp::CRegister::RegisterWriteA);
  _enum_type_action.insert("RegisterVerify", Psana::GenericPgp::CRegister::RegisterVerify);
  _enum_type_action.insert("Spin", Psana::GenericPgp::CRegister::Spin);
  _enum_type_action.insert("Usleep", Psana::GenericPgp::CRegister::Usleep);
  _enum_type_action.insert("Flush", Psana::GenericPgp::CRegister::Flush);
  type.insert("action", offsetof(DsType, action), _enum_type_action);
  type.insert("datasize", offsetof(DsType, datasize), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("address", offsetof(DsType, address), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("offset", offsetof(DsType, offset), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("mask", offsetof(DsType, mask), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_CRegister_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_CRegister_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_CRegister_v0_dataset_data_native_type()
{
  typedef ns_CRegister_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  hdf5pp::EnumType<uint8_t> _enum_type_action = hdf5pp::EnumType<uint8_t>::enumType();
  _enum_type_action.insert("RegisterRead", Psana::GenericPgp::CRegister::RegisterRead);
  _enum_type_action.insert("RegisterWrite", Psana::GenericPgp::CRegister::RegisterWrite);
  _enum_type_action.insert("RegisterWriteA", Psana::GenericPgp::CRegister::RegisterWriteA);
  _enum_type_action.insert("RegisterVerify", Psana::GenericPgp::CRegister::RegisterVerify);
  _enum_type_action.insert("Spin", Psana::GenericPgp::CRegister::Spin);
  _enum_type_action.insert("Usleep", Psana::GenericPgp::CRegister::Usleep);
  _enum_type_action.insert("Flush", Psana::GenericPgp::CRegister::Flush);
  type.insert("action", offsetof(DsType, action), _enum_type_action);
  type.insert("datasize", offsetof(DsType, datasize), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("address", offsetof(DsType, address), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("offset", offsetof(DsType, offset), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("mask", offsetof(DsType, mask), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_CRegister_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_CRegister_v0_dataset_data_native_type();
  return type;
}

ns_CRegister_v0::dataset_data::dataset_data()
{
}

ns_CRegister_v0::dataset_data::dataset_data(const Psana::GenericPgp::CRegister& psanaobj)
  : action(psanaobj.action())
  , datasize(psanaobj.datasize())
  , address(psanaobj.address())
  , offset(psanaobj.offset())
  , mask(psanaobj.mask())
{
}

ns_CRegister_v0::dataset_data::~dataset_data()
{
}

hdf5pp::Type ns_CStream_v0_dataset_data_stored_type()
{
  typedef ns_CStream_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("pgp_channel", offsetof(DsType, pgp_channel), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("data_type", offsetof(DsType, data_type), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("config_type", offsetof(DsType, config_type), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("config_offset", offsetof(DsType, config_offset), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_CStream_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_CStream_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_CStream_v0_dataset_data_native_type()
{
  typedef ns_CStream_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("pgp_channel", offsetof(DsType, pgp_channel), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("data_type", offsetof(DsType, data_type), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("config_type", offsetof(DsType, config_type), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("config_offset", offsetof(DsType, config_offset), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_CStream_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_CStream_v0_dataset_data_native_type();
  return type;
}

ns_CStream_v0::dataset_data::dataset_data()
{
}

ns_CStream_v0::dataset_data::dataset_data(const Psana::GenericPgp::CStream& psanaobj)
  : pgp_channel(psanaobj.pgp_channel())
  , data_type(psanaobj.data_type())
  , config_type(psanaobj.config_type())
  , config_offset(psanaobj.config_offset())
{
}

ns_CStream_v0::dataset_data::~dataset_data()
{
}

hdf5pp::Type ns_ConfigV1_v0_dataset_config_stored_type()
{
  typedef ns_ConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("id", offsetof(DsType, id), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("number_of_registers", offsetof(DsType, number_of_registers), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("number_of_sequences", offsetof(DsType, number_of_sequences), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("number_of_streams", offsetof(DsType, number_of_streams), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("payload_size", offsetof(DsType, payload_size), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("numberOfRows", offsetof(DsType, numberOfRows), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("numberOfColumns", offsetof(DsType, numberOfColumns), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("lastRowExclusions", offsetof(DsType, lastRowExclusions), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("numberOfAsics", offsetof(DsType, numberOfAsics), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_ConfigV1_v0::dataset_config::stored_type()
{
  static hdf5pp::Type type = ns_ConfigV1_v0_dataset_config_stored_type();
  return type;
}

hdf5pp::Type ns_ConfigV1_v0_dataset_config_native_type()
{
  typedef ns_ConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("id", offsetof(DsType, id), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("number_of_registers", offsetof(DsType, number_of_registers), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("number_of_sequences", offsetof(DsType, number_of_sequences), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("number_of_streams", offsetof(DsType, number_of_streams), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("payload_size", offsetof(DsType, payload_size), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("numberOfRows", offsetof(DsType, numberOfRows), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("numberOfColumns", offsetof(DsType, numberOfColumns), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("lastRowExclusions", offsetof(DsType, lastRowExclusions), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("numberOfAsics", offsetof(DsType, numberOfAsics), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_ConfigV1_v0::dataset_config::native_type()
{
  static hdf5pp::Type type = ns_ConfigV1_v0_dataset_config_native_type();
  return type;
}

ns_ConfigV1_v0::dataset_config::dataset_config()
{
}

ns_ConfigV1_v0::dataset_config::dataset_config(const Psana::GenericPgp::ConfigV1& psanaobj)
  : id(psanaobj.id())
  , number_of_registers(psanaobj.number_of_registers())
  , number_of_sequences(psanaobj.number_of_sequences())
  , number_of_streams(psanaobj.number_of_streams())
  , payload_size(psanaobj.payload_size())
  , numberOfRows(psanaobj.numberOfRows())
  , numberOfColumns(psanaobj.numberOfColumns())
  , lastRowExclusions(psanaobj.lastRowExclusions())
  , numberOfAsics(psanaobj.numberOfAsics())
{
}

ns_ConfigV1_v0::dataset_config::~dataset_config()
{
}
uint32_t ConfigV1_v0::id() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->id);
}
const Psana::GenericPgp::CDimension& ConfigV1_v0::frame_dim() const {
  if (not m_ds_storage_frame_dim) {
    if (not m_ds_frame_dim) read_ds_frame_dim();
    m_ds_storage_frame_dim = boost::make_shared<GenericPgp::CDimension_v0>(m_ds_frame_dim);
  }
  return *m_ds_storage_frame_dim;
}
const Psana::GenericPgp::CDimension& ConfigV1_v0::aux_dim() const {
  if (not m_ds_storage_aux_dim) {
    if (not m_ds_aux_dim) read_ds_aux_dim();
    m_ds_storage_aux_dim = boost::make_shared<GenericPgp::CDimension_v0>(m_ds_aux_dim);
  }
  return *m_ds_storage_aux_dim;
}
const Psana::GenericPgp::CDimension& ConfigV1_v0::env_dim() const {
  if (not m_ds_storage_env_dim) {
    if (not m_ds_env_dim) read_ds_env_dim();
    m_ds_storage_env_dim = boost::make_shared<GenericPgp::CDimension_v0>(m_ds_env_dim);
  }
  return *m_ds_storage_env_dim;
}
uint32_t ConfigV1_v0::number_of_registers() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->number_of_registers);
}
uint32_t ConfigV1_v0::number_of_sequences() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->number_of_sequences);
}
uint32_t ConfigV1_v0::number_of_streams() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->number_of_streams);
}
uint32_t ConfigV1_v0::payload_size() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->payload_size);
}
ndarray<const uint32_t, 2> ConfigV1_v0::pixel_settings() const {
  if (m_ds_pixel_settings.empty()) read_ds_pixel_settings();
  return m_ds_pixel_settings;
}
ndarray<const uint32_t, 1> ConfigV1_v0::sequence_length() const {
  if (m_ds_sequence_length.empty()) read_ds_sequence_length();
  return m_ds_sequence_length;
}
ndarray<const Psana::GenericPgp::CRegister, 1> ConfigV1_v0::sequence() const {
  if (m_ds_sequence.empty()) read_ds_sequence();
  return m_ds_sequence;
}
ndarray<const Psana::GenericPgp::CStream, 1> ConfigV1_v0::stream() const {
  if (m_ds_stream.empty()) read_ds_stream();
  return m_ds_stream;
}
ndarray<const uint32_t, 1> ConfigV1_v0::payload() const {
  if (m_ds_payload.empty()) read_ds_payload();
  return m_ds_payload;
}
uint32_t ConfigV1_v0::numberOfRows() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->numberOfRows);
}
uint32_t ConfigV1_v0::numberOfColumns() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->numberOfColumns);
}
uint32_t ConfigV1_v0::lastRowExclusions() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->lastRowExclusions);
}
uint32_t ConfigV1_v0::numberOfAsics() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->numberOfAsics);
}
void ConfigV1_v0::read_ds_config() const {
  m_ds_config = hdf5pp::Utils::readGroup<GenericPgp::ns_ConfigV1_v0::dataset_config>(m_group, "config", m_idx);
}
void ConfigV1_v0::read_ds_frame_dim() const {
  m_ds_frame_dim = hdf5pp::Utils::readGroup<GenericPgp::ns_CDimension_v0::dataset_data>(m_group, "frame_dim", m_idx);
  m_ds_storage_frame_dim = boost::make_shared<CDimension_v0>(m_ds_frame_dim);
}
void ConfigV1_v0::read_ds_aux_dim() const {
  m_ds_aux_dim = hdf5pp::Utils::readGroup<GenericPgp::ns_CDimension_v0::dataset_data>(m_group, "aux_dim", m_idx);
  m_ds_storage_aux_dim = boost::make_shared<CDimension_v0>(m_ds_aux_dim);
}
void ConfigV1_v0::read_ds_env_dim() const {
  m_ds_env_dim = hdf5pp::Utils::readGroup<GenericPgp::ns_CDimension_v0::dataset_data>(m_group, "env_dim", m_idx);
  m_ds_storage_env_dim = boost::make_shared<CDimension_v0>(m_ds_env_dim);
}
void ConfigV1_v0::read_ds_pixel_settings() const {
  m_ds_pixel_settings = hdf5pp::Utils::readNdarray<uint32_t, 2>(m_group, "pixel_settings", m_idx);
}
void ConfigV1_v0::read_ds_sequence_length() const {
  m_ds_sequence_length = hdf5pp::Utils::readNdarray<uint32_t, 1>(m_group, "sequence_length", m_idx);
}
void ConfigV1_v0::read_ds_sequence() const {
  ndarray<GenericPgp::ns_CRegister_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<GenericPgp::ns_CRegister_v0::dataset_data, 1>(m_group, "sequence", m_idx);
  ndarray<Psana::GenericPgp::CRegister, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_sequence = tmp;
}
void ConfigV1_v0::read_ds_stream() const {
  ndarray<GenericPgp::ns_CStream_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<GenericPgp::ns_CStream_v0::dataset_data, 1>(m_group, "stream", m_idx);
  ndarray<Psana::GenericPgp::CStream, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_stream = tmp;
}
void ConfigV1_v0::read_ds_payload() const {
  m_ds_payload = hdf5pp::Utils::readNdarray<uint32_t, 1>(m_group, "payload", m_idx);
}

void make_datasets_ConfigV1_v0(const Psana::GenericPgp::ConfigV1& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = GenericPgp::ns_ConfigV1_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    hdf5pp::Type dstype = GenericPgp::ns_CDimension_v0::dataset_data::stored_type();
    hdf5pp::Utils::createDataset(group, "frame_dim", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    hdf5pp::Type dstype = GenericPgp::ns_CDimension_v0::dataset_data::stored_type();
    hdf5pp::Utils::createDataset(group, "aux_dim", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    hdf5pp::Type dstype = GenericPgp::ns_CDimension_v0::dataset_data::stored_type();
    hdf5pp::Utils::createDataset(group, "env_dim", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.pixel_settings()) PsanaArray;
    const PsanaArray& psana_array = obj.pixel_settings();
    hsize_t dims[2];
    std::copy(psana_array.shape(), psana_array.shape()+2, dims);
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<uint32_t>::stored_type(), 2, dims);
    hdf5pp::Utils::createDataset(group, "pixel_settings", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.sequence_length()) PsanaArray;
    const PsanaArray& psana_array = obj.sequence_length();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<uint32_t>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "sequence_length", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.sequence()) PsanaArray;
    const PsanaArray& psana_array = obj.sequence();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<GenericPgp::ns_CRegister_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "sequence", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.stream()) PsanaArray;
    const PsanaArray& psana_array = obj.stream();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<GenericPgp::ns_CStream_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "stream", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.payload()) PsanaArray;
    const PsanaArray& psana_array = obj.payload();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<uint32_t>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "payload", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_ConfigV1_v0(const Psana::GenericPgp::ConfigV1* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    GenericPgp::ns_ConfigV1_v0::dataset_config ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "config", index < 0 ? index : index + 1);
  }
  if (obj) {
    GenericPgp::ns_CDimension_v0::dataset_data ds_data(obj->frame_dim());
    if (append) {
      hdf5pp::Utils::storeAt(group, "frame_dim", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "frame_dim", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "frame_dim", index < 0 ? index : index + 1);
  }
  if (obj) {
    GenericPgp::ns_CDimension_v0::dataset_data ds_data(obj->aux_dim());
    if (append) {
      hdf5pp::Utils::storeAt(group, "aux_dim", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "aux_dim", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "aux_dim", index < 0 ? index : index + 1);
  }
  if (obj) {
    GenericPgp::ns_CDimension_v0::dataset_data ds_data(obj->env_dim());
    if (append) {
      hdf5pp::Utils::storeAt(group, "env_dim", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "env_dim", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "env_dim", index < 0 ? index : index + 1);
  }
  if (append) {
    if (obj) {
      hdf5pp::Utils::storeNDArrayAt(group, "pixel_settings", obj->pixel_settings(), index);
    } else {
      hdf5pp::Utils::resizeDataset(group, "pixel_settings", index < 0 ? index : index + 1);
    }
  } else {
    hdf5pp::Utils::storeNDArray(group, "pixel_settings", obj->pixel_settings());
  }

  if (append) {
    if (obj) {
      hdf5pp::Utils::storeNDArrayAt(group, "sequence_length", obj->sequence_length(), index);
    } else {
      hdf5pp::Utils::resizeDataset(group, "sequence_length", index < 0 ? index : index + 1);
    }
  } else {
    hdf5pp::Utils::storeNDArray(group, "sequence_length", obj->sequence_length());
  }

  if (obj) {
    typedef __typeof__(obj->sequence()) PsanaArray;
    typedef ndarray<GenericPgp::ns_CRegister_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->sequence();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = GenericPgp::ns_CRegister_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "sequence", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "sequence", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "sequence", index < 0 ? index : index + 1);
  }

  if (obj) {
    typedef __typeof__(obj->stream()) PsanaArray;
    typedef ndarray<GenericPgp::ns_CStream_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->stream();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = GenericPgp::ns_CStream_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "stream", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "stream", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "stream", index < 0 ? index : index + 1);
  }

  if (append) {
    if (obj) {
      hdf5pp::Utils::storeNDArrayAt(group, "payload", obj->payload(), index);
    } else {
      hdf5pp::Utils::resizeDataset(group, "payload", index < 0 ? index : index + 1);
    }
  } else {
    hdf5pp::Utils::storeNDArray(group, "payload", obj->payload());
  }

}

boost::shared_ptr<PSEvt::Proxy<Psana::GenericPgp::ConfigV1> > make_ConfigV1(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::GenericPgp::ConfigV1> >(boost::make_shared<ConfigV1_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::GenericPgp::ConfigV1> >(boost::shared_ptr<Psana::GenericPgp::ConfigV1>());
  }
}

void make_datasets(const Psana::GenericPgp::ConfigV1& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_ConfigV1_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "GenericPgp.ConfigV1", version);
  }
}

void store_ConfigV1(const Psana::GenericPgp::ConfigV1* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_ConfigV1_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "GenericPgp.ConfigV1", version);
  }
}

void store(const Psana::GenericPgp::ConfigV1& obj, hdf5pp::Group group, int version) 
{
  store_ConfigV1(&obj, group, 0, version, false);
}

void store_at(const Psana::GenericPgp::ConfigV1* obj, hdf5pp::Group group, long index, int version)
{
  store_ConfigV1(obj, group, index, version, true);
}

} // namespace GenericPgp
} // namespace psddl_hdf2psana
