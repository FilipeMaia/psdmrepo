
// *** Do not edit this file, it is auto-generated ***

#include "psddl_hdf2psana/usdusb.ddl.h"
#include "hdf5pp/CompoundType.h"
#include "hdf5pp/EnumType.h"
#include "hdf5pp/Utils.h"
#include "PSEvt/DataProxy.h"
namespace psddl_hdf2psana {
namespace UsdUsb {

hdf5pp::Type ns_ConfigV1_v0_dataset_config_stored_type()
{
  typedef ns_ConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("counting_mode", offsetof(DsType, counting_mode), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("quadrature_mode", offsetof(DsType, quadrature_mode), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_ConfigV1_v0::dataset_config::stored_type()
{
  static hdf5pp::Type type = ns_ConfigV1_v0_dataset_config_stored_type();
  return type;
}

hdf5pp::Type ns_ConfigV1_v0_dataset_config_native_type()
{
  typedef ns_ConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("counting_mode", offsetof(DsType, counting_mode), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("quadrature_mode", offsetof(DsType, quadrature_mode), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_ConfigV1_v0::dataset_config::native_type()
{
  static hdf5pp::Type type = ns_ConfigV1_v0_dataset_config_native_type();
  return type;
}
ns_ConfigV1_v0::dataset_config::dataset_config()
{
}
ns_ConfigV1_v0::dataset_config::~dataset_config()
{
}
ndarray<const uint32_t, 1> ConfigV1_v0::counting_mode() const {
  if (not m_ds_config.get()) read_ds_config();
  boost::shared_ptr<uint32_t> ptr(m_ds_config, m_ds_config->counting_mode);
  return make_ndarray(ptr, NCHANNELS);
}
ndarray<const uint32_t, 1> ConfigV1_v0::quadrature_mode() const {
  if (not m_ds_config.get()) read_ds_config();
  boost::shared_ptr<uint32_t> ptr(m_ds_config, m_ds_config->quadrature_mode);
  return make_ndarray(ptr, NCHANNELS);
}
void ConfigV1_v0::read_ds_config() const {
  m_ds_config = hdf5pp::Utils::readGroup<ns_ConfigV1_v0::dataset_config>(m_group, "config", m_idx);
}
boost::shared_ptr<PSEvt::Proxy<Psana::UsdUsb::ConfigV1> > make_ConfigV1(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::UsdUsb::ConfigV1> >(boost::make_shared<ConfigV1_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::UsdUsb::ConfigV1> >(boost::shared_ptr<Psana::UsdUsb::ConfigV1>());
  }
}

hdf5pp::Type ns_DataV1_v0_dataset_data_stored_type()
{
  typedef ns_DataV1_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("e_count", offsetof(DsType, e_count), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("analog_in", offsetof(DsType, analog_in), hdf5pp::TypeTraits<uint16_t>::stored_type());
  type.insert("timestamp", offsetof(DsType, timestamp), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("digital_in", offsetof(DsType, digital_in), hdf5pp::TypeTraits<uint8_t>::stored_type());
  return type;
}

hdf5pp::Type ns_DataV1_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_DataV1_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_DataV1_v0_dataset_data_native_type()
{
  typedef ns_DataV1_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("e_count", offsetof(DsType, e_count), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("analog_in", offsetof(DsType, analog_in), hdf5pp::TypeTraits<uint16_t>::native_type());
  type.insert("timestamp", offsetof(DsType, timestamp), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("digital_in", offsetof(DsType, digital_in), hdf5pp::TypeTraits<uint8_t>::native_type());
  return type;
}

hdf5pp::Type ns_DataV1_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_DataV1_v0_dataset_data_native_type();
  return type;
}
ns_DataV1_v0::dataset_data::dataset_data()
{
}
ns_DataV1_v0::dataset_data::~dataset_data()
{
}
uint8_t DataV1_v0::digital_in() const {
  if (not m_ds_data.get()) read_ds_data();
  return uint8_t(m_ds_data->digital_in);
}
uint32_t DataV1_v0::timestamp() const {
  if (not m_ds_data.get()) read_ds_data();
  return uint32_t(m_ds_data->timestamp);
}
ndarray<const uint32_t, 1> DataV1_v0::e_count() const {
  if (not m_ds_data.get()) read_ds_data();
  boost::shared_ptr<uint32_t> ptr(m_ds_data, m_ds_data->e_count);
  return make_ndarray(ptr, Encoder_Inputs);
}

ndarray<const uint16_t, 1> DataV1_v0::analog_in() const {
  if (not m_ds_data.get()) read_ds_data();
  boost::shared_ptr<uint16_t> ptr(m_ds_data, m_ds_data->analog_in);
  return make_ndarray(ptr, Analog_Inputs);
}
ndarray<const int32_t, 1>
DataV1_v0::encoder_count() const{ 
unsigned shape[1]={Encoder_Inputs};                 ndarray<int32_t,1> res(shape);                 for (unsigned i=0; i!=Encoder_Inputs; ++i) res[i]=int(this->e_count()[i] << 8)/256;                 return res; 
}
void DataV1_v0::read_ds_data() const {
  m_ds_data = hdf5pp::Utils::readGroup<ns_DataV1_v0::dataset_data>(m_group, "data", m_idx);
}
boost::shared_ptr<PSEvt::Proxy<Psana::UsdUsb::DataV1> > make_DataV1(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::UsdUsb::DataV1> >(boost::make_shared<DataV1_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::UsdUsb::DataV1> >(boost::shared_ptr<Psana::UsdUsb::DataV1>());
  }
}
} // namespace UsdUsb
} // namespace psddl_hdf2psana
