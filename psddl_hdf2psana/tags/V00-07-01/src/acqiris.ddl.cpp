
// *** Do not edit this file, it is auto-generated ***

#include "psddl_hdf2psana/acqiris.ddl.h"
#include "hdf5pp/ArrayType.h"
#include "hdf5pp/CompoundType.h"
#include "hdf5pp/EnumType.h"
#include "hdf5pp/VlenType.h"
#include "hdf5pp/Utils.h"
#include "PSEvt/DataProxy.h"
#include "psddl_hdf2psana/Exceptions.h"
#include "psddl_hdf2psana/acqiris.h"
#include "psddl_hdf2psana/acqiris.h"
#include "psddl_hdf2psana/acqiris.h"
#include "psddl_hdf2psana/acqiris.h"
#include "psddl_hdf2psana/acqiris.h"
#include "psddl_hdf2psana/acqiris.h"
#include "psddl_hdf2psana/acqiris.h"
namespace psddl_hdf2psana {
namespace Acqiris {

hdf5pp::Type ns_VertV1_v0_dataset_data_stored_type()
{
  typedef ns_VertV1_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("fullScale", offsetof(DsType, fullScale), hdf5pp::TypeTraits<double>::stored_type());
  type.insert("offset", offsetof(DsType, offset), hdf5pp::TypeTraits<double>::stored_type());
  type.insert("coupling", offsetof(DsType, coupling), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("bandwidth", offsetof(DsType, bandwidth), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_VertV1_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_VertV1_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_VertV1_v0_dataset_data_native_type()
{
  typedef ns_VertV1_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("fullScale", offsetof(DsType, fullScale), hdf5pp::TypeTraits<double>::native_type());
  type.insert("offset", offsetof(DsType, offset), hdf5pp::TypeTraits<double>::native_type());
  type.insert("coupling", offsetof(DsType, coupling), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("bandwidth", offsetof(DsType, bandwidth), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_VertV1_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_VertV1_v0_dataset_data_native_type();
  return type;
}

ns_VertV1_v0::dataset_data::dataset_data()
{
}

ns_VertV1_v0::dataset_data::dataset_data(const Psana::Acqiris::VertV1& psanaobj)
  : fullScale(psanaobj.fullScale())
  , offset(psanaobj.offset())
  , coupling(psanaobj.coupling())
  , bandwidth(psanaobj.bandwidth())
{
}

ns_VertV1_v0::dataset_data::~dataset_data()
{
}

hdf5pp::Type ns_HorizV1_v0_dataset_data_stored_type()
{
  typedef ns_HorizV1_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("sampInterval", offsetof(DsType, sampInterval), hdf5pp::TypeTraits<double>::stored_type());
  type.insert("delayTime", offsetof(DsType, delayTime), hdf5pp::TypeTraits<double>::stored_type());
  type.insert("nbrSamples", offsetof(DsType, nbrSamples), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("nbrSegments", offsetof(DsType, nbrSegments), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_HorizV1_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_HorizV1_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_HorizV1_v0_dataset_data_native_type()
{
  typedef ns_HorizV1_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("sampInterval", offsetof(DsType, sampInterval), hdf5pp::TypeTraits<double>::native_type());
  type.insert("delayTime", offsetof(DsType, delayTime), hdf5pp::TypeTraits<double>::native_type());
  type.insert("nbrSamples", offsetof(DsType, nbrSamples), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("nbrSegments", offsetof(DsType, nbrSegments), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_HorizV1_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_HorizV1_v0_dataset_data_native_type();
  return type;
}

ns_HorizV1_v0::dataset_data::dataset_data()
{
}

ns_HorizV1_v0::dataset_data::dataset_data(const Psana::Acqiris::HorizV1& psanaobj)
  : sampInterval(psanaobj.sampInterval())
  , delayTime(psanaobj.delayTime())
  , nbrSamples(psanaobj.nbrSamples())
  , nbrSegments(psanaobj.nbrSegments())
{
}

ns_HorizV1_v0::dataset_data::~dataset_data()
{
}

hdf5pp::Type ns_TrigV1_v0_dataset_data_stored_type()
{
  typedef ns_TrigV1_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("coupling", offsetof(DsType, coupling), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("input", offsetof(DsType, input), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("slope", offsetof(DsType, slope), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("level", offsetof(DsType, level), hdf5pp::TypeTraits<double>::stored_type());
  return type;
}

hdf5pp::Type ns_TrigV1_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_TrigV1_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_TrigV1_v0_dataset_data_native_type()
{
  typedef ns_TrigV1_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("coupling", offsetof(DsType, coupling), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("input", offsetof(DsType, input), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("slope", offsetof(DsType, slope), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("level", offsetof(DsType, level), hdf5pp::TypeTraits<double>::native_type());
  return type;
}

hdf5pp::Type ns_TrigV1_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_TrigV1_v0_dataset_data_native_type();
  return type;
}

ns_TrigV1_v0::dataset_data::dataset_data()
{
}

ns_TrigV1_v0::dataset_data::dataset_data(const Psana::Acqiris::TrigV1& psanaobj)
  : coupling(psanaobj.coupling())
  , input(psanaobj.input())
  , slope(psanaobj.slope())
  , level(psanaobj.level())
{
}

ns_TrigV1_v0::dataset_data::~dataset_data()
{
}

hdf5pp::Type ns_ConfigV1_v0_dataset_config_stored_type()
{
  typedef ns_ConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("nbrConvertersPerChannel", offsetof(DsType, nbrConvertersPerChannel), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("channelMask", offsetof(DsType, channelMask), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("nbrBanks", offsetof(DsType, nbrBanks), hdf5pp::TypeTraits<uint32_t>::stored_type());
  type.insert("nbrChannels", offsetof(DsType, nbrChannels), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_ConfigV1_v0::dataset_config::stored_type()
{
  static hdf5pp::Type type = ns_ConfigV1_v0_dataset_config_stored_type();
  return type;
}

hdf5pp::Type ns_ConfigV1_v0_dataset_config_native_type()
{
  typedef ns_ConfigV1_v0::dataset_config DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("nbrConvertersPerChannel", offsetof(DsType, nbrConvertersPerChannel), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("channelMask", offsetof(DsType, channelMask), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("nbrBanks", offsetof(DsType, nbrBanks), hdf5pp::TypeTraits<uint32_t>::native_type());
  type.insert("nbrChannels", offsetof(DsType, nbrChannels), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_ConfigV1_v0::dataset_config::native_type()
{
  static hdf5pp::Type type = ns_ConfigV1_v0_dataset_config_native_type();
  return type;
}

ns_ConfigV1_v0::dataset_config::dataset_config()
{
}

ns_ConfigV1_v0::dataset_config::dataset_config(const Psana::Acqiris::ConfigV1& psanaobj)
  : nbrConvertersPerChannel(psanaobj.nbrConvertersPerChannel())
  , channelMask(psanaobj.channelMask())
  , nbrBanks(psanaobj.nbrBanks())
  , nbrChannels(psanaobj.nbrChannels())
{
}

ns_ConfigV1_v0::dataset_config::~dataset_config()
{
}
uint32_t ConfigV1_v0::nbrConvertersPerChannel() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->nbrConvertersPerChannel);
}
uint32_t ConfigV1_v0::channelMask() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->channelMask);
}
uint32_t ConfigV1_v0::nbrBanks() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->nbrBanks);
}
const Psana::Acqiris::TrigV1& ConfigV1_v0::trig() const {
  if (not m_ds_trig) read_ds_trig();
  m_ds_storage_trig = Psana::Acqiris::TrigV1(*m_ds_trig);
  return m_ds_storage_trig;
}
const Psana::Acqiris::HorizV1& ConfigV1_v0::horiz() const {
  if (not m_ds_horiz) read_ds_horiz();
  m_ds_storage_horiz = Psana::Acqiris::HorizV1(*m_ds_horiz);
  return m_ds_storage_horiz;
}
ndarray<const Psana::Acqiris::VertV1, 1> ConfigV1_v0::vert() const {
  if (m_ds_vert.empty()) read_ds_vert();
  return m_ds_vert;
}
uint32_t ConfigV1_v0::nbrChannels() const {
  if (not m_ds_config) read_ds_config();
  return uint32_t(m_ds_config->nbrChannels);
}
void ConfigV1_v0::read_ds_config() const {
  m_ds_config = hdf5pp::Utils::readGroup<Acqiris::ns_ConfigV1_v0::dataset_config>(m_group, "config", m_idx);
}
void ConfigV1_v0::read_ds_horiz() const {
  m_ds_horiz = hdf5pp::Utils::readGroup<Acqiris::ns_HorizV1_v0::dataset_data>(m_group, "horiz", m_idx);
  m_ds_storage_horiz = *m_ds_horiz;
}
void ConfigV1_v0::read_ds_trig() const {
  m_ds_trig = hdf5pp::Utils::readGroup<Acqiris::ns_TrigV1_v0::dataset_data>(m_group, "trig", m_idx);
  m_ds_storage_trig = *m_ds_trig;
}
void ConfigV1_v0::read_ds_vert() const {
  ndarray<Acqiris::ns_VertV1_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<Acqiris::ns_VertV1_v0::dataset_data, 1>(m_group, "vert", m_idx);
  ndarray<Psana::Acqiris::VertV1, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_vert = tmp;
}

void make_datasets_ConfigV1_v0(const Psana::Acqiris::ConfigV1& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = Acqiris::ns_ConfigV1_v0::dataset_config::stored_type();
    hdf5pp::Utils::createDataset(group, "config", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    hdf5pp::Type dstype = Acqiris::ns_HorizV1_v0::dataset_data::stored_type();
    hdf5pp::Utils::createDataset(group, "horiz", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    hdf5pp::Type dstype = Acqiris::ns_TrigV1_v0::dataset_data::stored_type();
    hdf5pp::Utils::createDataset(group, "trig", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.vert()) PsanaArray;
    const PsanaArray& psana_array = obj.vert();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<Acqiris::ns_VertV1_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "vert", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_ConfigV1_v0(const Psana::Acqiris::ConfigV1* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    Acqiris::ns_ConfigV1_v0::dataset_config ds_data(*obj);
    if (append) {
      hdf5pp::Utils::storeAt(group, "config", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "config", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "config", index < 0 ? index : index + 1);
  }
  if (obj) {
    Acqiris::ns_HorizV1_v0::dataset_data ds_data(obj->horiz());
    if (append) {
      hdf5pp::Utils::storeAt(group, "horiz", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "horiz", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "horiz", index < 0 ? index : index + 1);
  }
  if (obj) {
    Acqiris::ns_TrigV1_v0::dataset_data ds_data(obj->trig());
    if (append) {
      hdf5pp::Utils::storeAt(group, "trig", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "trig", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "trig", index < 0 ? index : index + 1);
  }
  if (obj) {
    typedef __typeof__(obj->vert()) PsanaArray;
    typedef ndarray<Acqiris::ns_VertV1_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->vert();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = Acqiris::ns_VertV1_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "vert", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "vert", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "vert", index < 0 ? index : index + 1);
  }
}

boost::shared_ptr<PSEvt::Proxy<Psana::Acqiris::ConfigV1> > make_ConfigV1(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::Acqiris::ConfigV1> >(boost::make_shared<ConfigV1_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::Acqiris::ConfigV1> >(boost::shared_ptr<Psana::Acqiris::ConfigV1>());
  }
}

void make_datasets(const Psana::Acqiris::ConfigV1& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_ConfigV1_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Acqiris.ConfigV1", version);
  }
}

void store_ConfigV1(const Psana::Acqiris::ConfigV1* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_ConfigV1_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Acqiris.ConfigV1", version);
  }
}

void store(const Psana::Acqiris::ConfigV1& obj, hdf5pp::Group group, int version) 
{
  store_ConfigV1(&obj, group, 0, version, false);
}

void store_at(const Psana::Acqiris::ConfigV1* obj, hdf5pp::Group group, long index, int version)
{
  store_ConfigV1(obj, group, index, version, true);
}


hdf5pp::Type ns_TimestampV1_v0_dataset_data_stored_type()
{
  typedef ns_TimestampV1_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("pos", offsetof(DsType, pos), hdf5pp::TypeTraits<double>::stored_type());
  type.insert("value", offsetof(DsType, value), hdf5pp::TypeTraits<uint64_t>::stored_type());
  return type;
}

hdf5pp::Type ns_TimestampV1_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_TimestampV1_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_TimestampV1_v0_dataset_data_native_type()
{
  typedef ns_TimestampV1_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  type.insert("pos", offsetof(DsType, pos), hdf5pp::TypeTraits<double>::native_type());
  type.insert("value", offsetof(DsType, value), hdf5pp::TypeTraits<uint64_t>::native_type());
  return type;
}

hdf5pp::Type ns_TimestampV1_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_TimestampV1_v0_dataset_data_native_type();
  return type;
}

ns_TimestampV1_v0::dataset_data::dataset_data()
{
}

ns_TimestampV1_v0::dataset_data::dataset_data(const Psana::Acqiris::TimestampV1& psanaobj)
  : pos(psanaobj.pos())
  , value(psanaobj.value())
{
}

ns_TimestampV1_v0::dataset_data::~dataset_data()
{
}
boost::shared_ptr<PSEvt::Proxy<Psana::Acqiris::DataDescV1> > make_DataDescV1(int version, hdf5pp::Group group, hsize_t idx, const boost::shared_ptr<Psana::Acqiris::ConfigV1>& cfg) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::Acqiris::DataDescV1> >(boost::make_shared<DataDescV1_v0<Psana::Acqiris::ConfigV1> >(group, idx, cfg));
  case 1:
    return boost::make_shared<PSEvt::DataProxy<Psana::Acqiris::DataDescV1> >(boost::make_shared<DataDescV1_v1<Psana::Acqiris::ConfigV1> >(group, idx, cfg));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::Acqiris::DataDescV1> >(boost::shared_ptr<Psana::Acqiris::DataDescV1>());
  }
}

void make_datasets(const Psana::Acqiris::DataDescV1& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 1;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_DataDescV1_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  case 1:
    make_datasets_DataDescV1_v1(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Acqiris.DataDescV1", version);
  }
}

void store_DataDescV1(const Psana::Acqiris::DataDescV1* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 1;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_DataDescV1_v0(obj, group, index, append);
    break;
  case 1:
    store_DataDescV1_v1(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Acqiris.DataDescV1", version);
  }
}

void store(const Psana::Acqiris::DataDescV1& obj, hdf5pp::Group group, int version) 
{
  store_DataDescV1(&obj, group, 0, version, false);
}

void store_at(const Psana::Acqiris::DataDescV1* obj, hdf5pp::Group group, long index, int version)
{
  store_DataDescV1(obj, group, index, version, true);
}


hdf5pp::Type ns_TdcChannel_v0_dataset_data_stored_type()
{
  typedef ns_TdcChannel_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  hdf5pp::EnumType<uint32_t> _enum_type_channel = hdf5pp::EnumType<uint32_t>::enumType();
  _enum_type_channel.insert("Veto", Psana::Acqiris::TdcChannel::Veto);
  _enum_type_channel.insert("Common", Psana::Acqiris::TdcChannel::Common);
  _enum_type_channel.insert("Input1", Psana::Acqiris::TdcChannel::Input1);
  _enum_type_channel.insert("Input2", Psana::Acqiris::TdcChannel::Input2);
  _enum_type_channel.insert("Input3", Psana::Acqiris::TdcChannel::Input3);
  _enum_type_channel.insert("Input4", Psana::Acqiris::TdcChannel::Input4);
  _enum_type_channel.insert("Input5", Psana::Acqiris::TdcChannel::Input5);
  _enum_type_channel.insert("Input6", Psana::Acqiris::TdcChannel::Input6);
  type.insert("channel", offsetof(DsType, channel), _enum_type_channel);
  type.insert("_mode_int", offsetof(DsType, _mode_int), hdf5pp::TypeTraits<uint32_t>::stored_type());
  hdf5pp::EnumType<uint16_t> _enum_type_slope = hdf5pp::EnumType<uint16_t>::enumType();
  _enum_type_slope.insert("Positive", Psana::Acqiris::TdcChannel::Positive);
  _enum_type_slope.insert("Negative", Psana::Acqiris::TdcChannel::Negative);
  type.insert("slope", offsetof(DsType, slope), _enum_type_slope);
  hdf5pp::EnumType<uint16_t> _enum_type_mode = hdf5pp::EnumType<uint16_t>::enumType();
  _enum_type_mode.insert("Active", Psana::Acqiris::TdcChannel::Active);
  _enum_type_mode.insert("Inactive", Psana::Acqiris::TdcChannel::Inactive);
  type.insert("mode", offsetof(DsType, mode), _enum_type_mode);
  type.insert("level", offsetof(DsType, level), hdf5pp::TypeTraits<double>::stored_type());
  return type;
}

hdf5pp::Type ns_TdcChannel_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_TdcChannel_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_TdcChannel_v0_dataset_data_native_type()
{
  typedef ns_TdcChannel_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  hdf5pp::EnumType<uint32_t> _enum_type_channel = hdf5pp::EnumType<uint32_t>::enumType();
  _enum_type_channel.insert("Veto", Psana::Acqiris::TdcChannel::Veto);
  _enum_type_channel.insert("Common", Psana::Acqiris::TdcChannel::Common);
  _enum_type_channel.insert("Input1", Psana::Acqiris::TdcChannel::Input1);
  _enum_type_channel.insert("Input2", Psana::Acqiris::TdcChannel::Input2);
  _enum_type_channel.insert("Input3", Psana::Acqiris::TdcChannel::Input3);
  _enum_type_channel.insert("Input4", Psana::Acqiris::TdcChannel::Input4);
  _enum_type_channel.insert("Input5", Psana::Acqiris::TdcChannel::Input5);
  _enum_type_channel.insert("Input6", Psana::Acqiris::TdcChannel::Input6);
  type.insert("channel", offsetof(DsType, channel), _enum_type_channel);
  type.insert("_mode_int", offsetof(DsType, _mode_int), hdf5pp::TypeTraits<uint32_t>::native_type());
  hdf5pp::EnumType<uint16_t> _enum_type_slope = hdf5pp::EnumType<uint16_t>::enumType();
  _enum_type_slope.insert("Positive", Psana::Acqiris::TdcChannel::Positive);
  _enum_type_slope.insert("Negative", Psana::Acqiris::TdcChannel::Negative);
  type.insert("slope", offsetof(DsType, slope), _enum_type_slope);
  hdf5pp::EnumType<uint16_t> _enum_type_mode = hdf5pp::EnumType<uint16_t>::enumType();
  _enum_type_mode.insert("Active", Psana::Acqiris::TdcChannel::Active);
  _enum_type_mode.insert("Inactive", Psana::Acqiris::TdcChannel::Inactive);
  type.insert("mode", offsetof(DsType, mode), _enum_type_mode);
  type.insert("level", offsetof(DsType, level), hdf5pp::TypeTraits<double>::native_type());
  return type;
}

hdf5pp::Type ns_TdcChannel_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_TdcChannel_v0_dataset_data_native_type();
  return type;
}

ns_TdcChannel_v0::dataset_data::dataset_data()
{
}

ns_TdcChannel_v0::dataset_data::dataset_data(const Psana::Acqiris::TdcChannel& psanaobj)
  : channel(psanaobj.channel())
  , _mode_int(psanaobj._mode_int())
  , slope(psanaobj.slope())
  , mode(psanaobj.mode())
  , level(psanaobj.level())
{
}

ns_TdcChannel_v0::dataset_data::~dataset_data()
{
}

hdf5pp::Type ns_TdcAuxIO_v0_dataset_data_stored_type()
{
  typedef ns_TdcAuxIO_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  hdf5pp::EnumType<uint32_t> _enum_type_channel = hdf5pp::EnumType<uint32_t>::enumType();
  _enum_type_channel.insert("IOAux1", Psana::Acqiris::TdcAuxIO::IOAux1);
  _enum_type_channel.insert("IOAux2", Psana::Acqiris::TdcAuxIO::IOAux2);
  type.insert("channel", offsetof(DsType, channel), _enum_type_channel);
  hdf5pp::EnumType<uint32_t> _enum_type_mode = hdf5pp::EnumType<uint32_t>::enumType();
  _enum_type_mode.insert("BankSwitch", Psana::Acqiris::TdcAuxIO::BankSwitch);
  _enum_type_mode.insert("Marker", Psana::Acqiris::TdcAuxIO::Marker);
  _enum_type_mode.insert("OutputLo", Psana::Acqiris::TdcAuxIO::OutputLo);
  _enum_type_mode.insert("OutputHi", Psana::Acqiris::TdcAuxIO::OutputHi);
  type.insert("mode", offsetof(DsType, mode), _enum_type_mode);
  hdf5pp::EnumType<uint32_t> _enum_type_term = hdf5pp::EnumType<uint32_t>::enumType();
  _enum_type_term.insert("ZHigh", Psana::Acqiris::TdcAuxIO::ZHigh);
  _enum_type_term.insert("Z50", Psana::Acqiris::TdcAuxIO::Z50);
  type.insert("term", offsetof(DsType, term), _enum_type_term);
  return type;
}

hdf5pp::Type ns_TdcAuxIO_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_TdcAuxIO_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_TdcAuxIO_v0_dataset_data_native_type()
{
  typedef ns_TdcAuxIO_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  hdf5pp::EnumType<uint32_t> _enum_type_channel = hdf5pp::EnumType<uint32_t>::enumType();
  _enum_type_channel.insert("IOAux1", Psana::Acqiris::TdcAuxIO::IOAux1);
  _enum_type_channel.insert("IOAux2", Psana::Acqiris::TdcAuxIO::IOAux2);
  type.insert("channel", offsetof(DsType, channel), _enum_type_channel);
  hdf5pp::EnumType<uint32_t> _enum_type_mode = hdf5pp::EnumType<uint32_t>::enumType();
  _enum_type_mode.insert("BankSwitch", Psana::Acqiris::TdcAuxIO::BankSwitch);
  _enum_type_mode.insert("Marker", Psana::Acqiris::TdcAuxIO::Marker);
  _enum_type_mode.insert("OutputLo", Psana::Acqiris::TdcAuxIO::OutputLo);
  _enum_type_mode.insert("OutputHi", Psana::Acqiris::TdcAuxIO::OutputHi);
  type.insert("mode", offsetof(DsType, mode), _enum_type_mode);
  hdf5pp::EnumType<uint32_t> _enum_type_term = hdf5pp::EnumType<uint32_t>::enumType();
  _enum_type_term.insert("ZHigh", Psana::Acqiris::TdcAuxIO::ZHigh);
  _enum_type_term.insert("Z50", Psana::Acqiris::TdcAuxIO::Z50);
  type.insert("term", offsetof(DsType, term), _enum_type_term);
  return type;
}

hdf5pp::Type ns_TdcAuxIO_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_TdcAuxIO_v0_dataset_data_native_type();
  return type;
}

ns_TdcAuxIO_v0::dataset_data::dataset_data()
{
}

ns_TdcAuxIO_v0::dataset_data::dataset_data(const Psana::Acqiris::TdcAuxIO& psanaobj)
  : channel(psanaobj.channel())
  , mode(psanaobj.mode())
  , term(psanaobj.term())
{
}

ns_TdcAuxIO_v0::dataset_data::~dataset_data()
{
}

hdf5pp::Type ns_TdcVetoIO_v0_dataset_data_stored_type()
{
  typedef ns_TdcVetoIO_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  hdf5pp::EnumType<uint32_t> _enum_type_channel = hdf5pp::EnumType<uint32_t>::enumType();
  _enum_type_channel.insert("ChVeto", Psana::Acqiris::TdcVetoIO::ChVeto);
  type.insert("channel", offsetof(DsType, channel), _enum_type_channel);
  hdf5pp::EnumType<uint32_t> _enum_type_mode = hdf5pp::EnumType<uint32_t>::enumType();
  _enum_type_mode.insert("Veto", Psana::Acqiris::TdcVetoIO::Veto);
  _enum_type_mode.insert("SwitchVeto", Psana::Acqiris::TdcVetoIO::SwitchVeto);
  _enum_type_mode.insert("InvertedVeto", Psana::Acqiris::TdcVetoIO::InvertedVeto);
  _enum_type_mode.insert("InvertedSwitchVeto", Psana::Acqiris::TdcVetoIO::InvertedSwitchVeto);
  type.insert("mode", offsetof(DsType, mode), _enum_type_mode);
  hdf5pp::EnumType<uint32_t> _enum_type_term = hdf5pp::EnumType<uint32_t>::enumType();
  _enum_type_term.insert("ZHigh", Psana::Acqiris::TdcVetoIO::ZHigh);
  _enum_type_term.insert("Z50", Psana::Acqiris::TdcVetoIO::Z50);
  type.insert("term", offsetof(DsType, term), _enum_type_term);
  return type;
}

hdf5pp::Type ns_TdcVetoIO_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_TdcVetoIO_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_TdcVetoIO_v0_dataset_data_native_type()
{
  typedef ns_TdcVetoIO_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  hdf5pp::EnumType<uint32_t> _enum_type_channel = hdf5pp::EnumType<uint32_t>::enumType();
  _enum_type_channel.insert("ChVeto", Psana::Acqiris::TdcVetoIO::ChVeto);
  type.insert("channel", offsetof(DsType, channel), _enum_type_channel);
  hdf5pp::EnumType<uint32_t> _enum_type_mode = hdf5pp::EnumType<uint32_t>::enumType();
  _enum_type_mode.insert("Veto", Psana::Acqiris::TdcVetoIO::Veto);
  _enum_type_mode.insert("SwitchVeto", Psana::Acqiris::TdcVetoIO::SwitchVeto);
  _enum_type_mode.insert("InvertedVeto", Psana::Acqiris::TdcVetoIO::InvertedVeto);
  _enum_type_mode.insert("InvertedSwitchVeto", Psana::Acqiris::TdcVetoIO::InvertedSwitchVeto);
  type.insert("mode", offsetof(DsType, mode), _enum_type_mode);
  hdf5pp::EnumType<uint32_t> _enum_type_term = hdf5pp::EnumType<uint32_t>::enumType();
  _enum_type_term.insert("ZHigh", Psana::Acqiris::TdcVetoIO::ZHigh);
  _enum_type_term.insert("Z50", Psana::Acqiris::TdcVetoIO::Z50);
  type.insert("term", offsetof(DsType, term), _enum_type_term);
  return type;
}

hdf5pp::Type ns_TdcVetoIO_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_TdcVetoIO_v0_dataset_data_native_type();
  return type;
}

ns_TdcVetoIO_v0::dataset_data::dataset_data()
{
}

ns_TdcVetoIO_v0::dataset_data::dataset_data(const Psana::Acqiris::TdcVetoIO& psanaobj)
  : channel(psanaobj.channel())
  , mode(psanaobj.mode())
  , term(psanaobj.term())
{
}

ns_TdcVetoIO_v0::dataset_data::~dataset_data()
{
}
ndarray<const Psana::Acqiris::TdcChannel, 1> TdcConfigV1_v0::channels() const {
  if (m_ds_channel.empty()) read_ds_channel();
  return m_ds_channel;
}
ndarray<const Psana::Acqiris::TdcAuxIO, 1> TdcConfigV1_v0::auxio() const {
  if (m_ds_auxio.empty()) read_ds_auxio();
  return m_ds_auxio;
}
const Psana::Acqiris::TdcVetoIO& TdcConfigV1_v0::veto() const {
  if (not m_ds_veto) read_ds_veto();
  m_ds_storage_veto = Psana::Acqiris::TdcVetoIO(*m_ds_veto);
  return m_ds_storage_veto;
}
void TdcConfigV1_v0::read_ds_veto() const {
  m_ds_veto = hdf5pp::Utils::readGroup<Acqiris::ns_TdcVetoIO_v0::dataset_data>(m_group, "veto", m_idx);
  m_ds_storage_veto = *m_ds_veto;
}
void TdcConfigV1_v0::read_ds_channel() const {
  ndarray<Acqiris::ns_TdcChannel_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<Acqiris::ns_TdcChannel_v0::dataset_data, 1>(m_group, "channel", m_idx);
  ndarray<Psana::Acqiris::TdcChannel, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_channel = tmp;
}
void TdcConfigV1_v0::read_ds_auxio() const {
  ndarray<Acqiris::ns_TdcAuxIO_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<Acqiris::ns_TdcAuxIO_v0::dataset_data, 1>(m_group, "auxio", m_idx);
  ndarray<Psana::Acqiris::TdcAuxIO, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_auxio = tmp;
}

void make_datasets_TdcConfigV1_v0(const Psana::Acqiris::TdcConfigV1& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    hdf5pp::Type dstype = Acqiris::ns_TdcVetoIO_v0::dataset_data::stored_type();
    hdf5pp::Utils::createDataset(group, "veto", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.channels()) PsanaArray;
    const PsanaArray& psana_array = obj.channels();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<Acqiris::ns_TdcChannel_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "channel", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
  {
    typedef __typeof__(obj.auxio()) PsanaArray;
    const PsanaArray& psana_array = obj.auxio();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<Acqiris::ns_TdcAuxIO_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "auxio", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_TdcConfigV1_v0(const Psana::Acqiris::TdcConfigV1* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    Acqiris::ns_TdcVetoIO_v0::dataset_data ds_data(obj->veto());
    if (append) {
      hdf5pp::Utils::storeAt(group, "veto", ds_data, index);
    } else {
      hdf5pp::Utils::storeScalar(group, "veto", ds_data);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "veto", index < 0 ? index : index + 1);
  }
  if (obj) {
    typedef __typeof__(obj->channels()) PsanaArray;
    typedef ndarray<Acqiris::ns_TdcChannel_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->channels();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = Acqiris::ns_TdcChannel_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "channel", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "channel", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "channel", index < 0 ? index : index + 1);
  }
  if (obj) {
    typedef __typeof__(obj->auxio()) PsanaArray;
    typedef ndarray<Acqiris::ns_TdcAuxIO_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->auxio();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = Acqiris::ns_TdcAuxIO_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "auxio", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "auxio", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "auxio", index < 0 ? index : index + 1);
  }
}

boost::shared_ptr<PSEvt::Proxy<Psana::Acqiris::TdcConfigV1> > make_TdcConfigV1(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::Acqiris::TdcConfigV1> >(boost::make_shared<TdcConfigV1_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::Acqiris::TdcConfigV1> >(boost::shared_ptr<Psana::Acqiris::TdcConfigV1>());
  }
}

void make_datasets(const Psana::Acqiris::TdcConfigV1& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_TdcConfigV1_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Acqiris.TdcConfigV1", version);
  }
}

void store_TdcConfigV1(const Psana::Acqiris::TdcConfigV1* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_TdcConfigV1_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Acqiris.TdcConfigV1", version);
  }
}

void store(const Psana::Acqiris::TdcConfigV1& obj, hdf5pp::Group group, int version) 
{
  store_TdcConfigV1(&obj, group, 0, version, false);
}

void store_at(const Psana::Acqiris::TdcConfigV1* obj, hdf5pp::Group group, long index, int version)
{
  store_TdcConfigV1(obj, group, index, version, true);
}


hdf5pp::Type ns_TdcDataV1_Item_v0_dataset_data_stored_type()
{
  typedef ns_TdcDataV1_Item_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  hdf5pp::EnumType<int32_t> _enum_type_source = hdf5pp::EnumType<int32_t>::enumType();
  _enum_type_source.insert("Comm", Psana::Acqiris::TdcDataV1_Item::Comm);
  _enum_type_source.insert("Chan1", Psana::Acqiris::TdcDataV1_Item::Chan1);
  _enum_type_source.insert("Chan2", Psana::Acqiris::TdcDataV1_Item::Chan2);
  _enum_type_source.insert("Chan3", Psana::Acqiris::TdcDataV1_Item::Chan3);
  _enum_type_source.insert("Chan4", Psana::Acqiris::TdcDataV1_Item::Chan4);
  _enum_type_source.insert("Chan5", Psana::Acqiris::TdcDataV1_Item::Chan5);
  _enum_type_source.insert("Chan6", Psana::Acqiris::TdcDataV1_Item::Chan6);
  _enum_type_source.insert("AuxIO", Psana::Acqiris::TdcDataV1_Item::AuxIO);
  type.insert("source", offsetof(DsType, source), _enum_type_source);
  type.insert("overflow", offsetof(DsType, overflow), hdf5pp::TypeTraits<uint8_t>::stored_type());
  type.insert("value", offsetof(DsType, value), hdf5pp::TypeTraits<uint32_t>::stored_type());
  return type;
}

hdf5pp::Type ns_TdcDataV1_Item_v0::dataset_data::stored_type()
{
  static hdf5pp::Type type = ns_TdcDataV1_Item_v0_dataset_data_stored_type();
  return type;
}

hdf5pp::Type ns_TdcDataV1_Item_v0_dataset_data_native_type()
{
  typedef ns_TdcDataV1_Item_v0::dataset_data DsType;
  hdf5pp::CompoundType type = hdf5pp::CompoundType::compoundType<DsType>();
  hdf5pp::EnumType<int32_t> _enum_type_source = hdf5pp::EnumType<int32_t>::enumType();
  _enum_type_source.insert("Comm", Psana::Acqiris::TdcDataV1_Item::Comm);
  _enum_type_source.insert("Chan1", Psana::Acqiris::TdcDataV1_Item::Chan1);
  _enum_type_source.insert("Chan2", Psana::Acqiris::TdcDataV1_Item::Chan2);
  _enum_type_source.insert("Chan3", Psana::Acqiris::TdcDataV1_Item::Chan3);
  _enum_type_source.insert("Chan4", Psana::Acqiris::TdcDataV1_Item::Chan4);
  _enum_type_source.insert("Chan5", Psana::Acqiris::TdcDataV1_Item::Chan5);
  _enum_type_source.insert("Chan6", Psana::Acqiris::TdcDataV1_Item::Chan6);
  _enum_type_source.insert("AuxIO", Psana::Acqiris::TdcDataV1_Item::AuxIO);
  type.insert("source", offsetof(DsType, source), _enum_type_source);
  type.insert("overflow", offsetof(DsType, overflow), hdf5pp::TypeTraits<uint8_t>::native_type());
  type.insert("value", offsetof(DsType, value), hdf5pp::TypeTraits<uint32_t>::native_type());
  return type;
}

hdf5pp::Type ns_TdcDataV1_Item_v0::dataset_data::native_type()
{
  static hdf5pp::Type type = ns_TdcDataV1_Item_v0_dataset_data_native_type();
  return type;
}

ns_TdcDataV1_Item_v0::dataset_data::dataset_data()
{
}

ns_TdcDataV1_Item_v0::dataset_data::dataset_data(const Psana::Acqiris::TdcDataV1_Item& psanaobj)
  : source(psanaobj.source())
  , overflow(psanaobj.bf_ofv_())
  , value(psanaobj.bf_val_())
{
}

ns_TdcDataV1_Item_v0::dataset_data::~dataset_data()
{
}
ndarray<const Psana::Acqiris::TdcDataV1_Item, 1> TdcDataV1_v0::data() const {
  if (m_ds_data.empty()) read_ds_data();
  return m_ds_data;
}
void TdcDataV1_v0::read_ds_data() const {
  ndarray<Acqiris::ns_TdcDataV1_Item_v0::dataset_data, 1> arr = hdf5pp::Utils::readNdarray<Acqiris::ns_TdcDataV1_Item_v0::dataset_data, 1>(m_group, "data", m_idx);
  ndarray<Psana::Acqiris::TdcDataV1_Item, 1> tmp(arr.shape());
  std::copy(arr.begin(), arr.end(), tmp.begin());
  m_ds_data = tmp;
}

void make_datasets_TdcDataV1_v0(const Psana::Acqiris::TdcDataV1& obj, 
      hdf5pp::Group group, const ChunkPolicy& chunkPolicy, int deflate, bool shuffle)
{
  {
    typedef __typeof__(obj.data()) PsanaArray;
    const PsanaArray& psana_array = obj.data();
    hdf5pp::Type dstype = hdf5pp::ArrayType::arrayType(hdf5pp::TypeTraits<Acqiris::ns_TdcDataV1_Item_v0::dataset_data>::stored_type(), psana_array.shape()[0]);
    hdf5pp::Utils::createDataset(group, "data", dstype, chunkPolicy.chunkSize(dstype), chunkPolicy.chunkCacheSize(dstype), deflate, shuffle);    
  }
}

void store_TdcDataV1_v0(const Psana::Acqiris::TdcDataV1* obj, hdf5pp::Group group, long index, bool append)
{
  if (obj) {
    typedef __typeof__(obj->data()) PsanaArray;
    typedef ndarray<Acqiris::ns_TdcDataV1_Item_v0::dataset_data, 1> HdfArray;
    PsanaArray psana_array = obj->data();
    HdfArray hdf_array(psana_array.shape());
    HdfArray::iterator out = hdf_array.begin();
    for (PsanaArray::iterator it = psana_array.begin(); it != psana_array.end(); ++ it, ++ out) {
      *out = Acqiris::ns_TdcDataV1_Item_v0::dataset_data(*it);
    }
    if (append) {
      hdf5pp::Utils::storeNDArrayAt(group, "data", hdf_array, index);
    } else {
      hdf5pp::Utils::storeNDArray(group, "data", hdf_array);
    }
  } else if (append) {
    hdf5pp::Utils::resizeDataset(group, "data", index < 0 ? index : index + 1);
  }
}

boost::shared_ptr<PSEvt::Proxy<Psana::Acqiris::TdcDataV1> > make_TdcDataV1(int version, hdf5pp::Group group, hsize_t idx) {
  switch (version) {
  case 0:
    return boost::make_shared<PSEvt::DataProxy<Psana::Acqiris::TdcDataV1> >(boost::make_shared<TdcDataV1_v0>(group, idx));
  default:
    return boost::make_shared<PSEvt::DataProxy<Psana::Acqiris::TdcDataV1> >(boost::shared_ptr<Psana::Acqiris::TdcDataV1>());
  }
}

void make_datasets(const Psana::Acqiris::TdcDataV1& obj, hdf5pp::Group group, const ChunkPolicy& chunkPolicy,
                   int deflate, bool shuffle, int version)
{
  if (version < 0) version = 0;
  group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    make_datasets_TdcDataV1_v0(obj, group, chunkPolicy, deflate, shuffle);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Acqiris.TdcDataV1", version);
  }
}

void store_TdcDataV1(const Psana::Acqiris::TdcDataV1* obj, hdf5pp::Group group, long index, int version, bool append)
{
  if (version < 0) version = 0;
  if (not append) group.createAttr<uint32_t>("_schemaVersion").store(version);
  switch (version) {
  case 0:
    store_TdcDataV1_v0(obj, group, index, append);
    break;
  default:
    throw ExceptionSchemaVersion(ERR_LOC, "Acqiris.TdcDataV1", version);
  }
}

void store(const Psana::Acqiris::TdcDataV1& obj, hdf5pp::Group group, int version) 
{
  store_TdcDataV1(&obj, group, 0, version, false);
}

void store_at(const Psana::Acqiris::TdcDataV1* obj, hdf5pp::Group group, long index, int version)
{
  store_TdcDataV1(obj, group, index, version, true);
}

} // namespace Acqiris
} // namespace psddl_hdf2psana
