#!/usr/bin/python2.4
#--------------------------------------------------------------------------
# File and Version Information:
#  $Id$
#
# Description:
#  Script pyxtcreader...
#
#------------------------------------------------------------------------

"""Analysis job.

This software was developed for the LUSI project.  If you use all or 
part of it, please give an appropriate acknowledgement.

@see RelatedModule

@version $Id$ 

@author Andrei Salnikov
"""

#------------------------------
#  Module's version from CVS --
#------------------------------
__version__ = "$Revision$"
# $Source$

#--------------------------------
#  Imports of standard modules --
#--------------------------------
import sys
import os
import logging
from optparse import OptionParser

#-----------------------------
# Imports for other modules --
#-----------------------------
from pdsdata import xtc, io, event
from pdsdata.histo import HistoMgr

#---------------------
# Local definitions --
#---------------------

def _my_import(name):
    """ Helper function to import and instantiate user analysis class """

    # import module
    try :
        mod = __import__(name)
    except ImportError, e :
        logging.exception("Cannot import module %s: %s", name, str(e) )
        return None

    # locate sub-module
    components = name.split('.')
    for comp in components[1:]:
        mod = getattr(mod, comp)
    
    # must define class with the same name
    classname = components[-1]
    userClass = getattr(mod, classname, None)
    if not userClass :
        logging.error("User module %s does not define class %s", name, classname )
        return None
    
    # instantiate it
    try:
        userana = userClass()
    except Exception, e :
        logging.exception("Failure while instantiating class %s: %s", classname, str(e) )
        return None

    # some weird cases are possible, just make sure that callable
    # returns an object which has a list of attributes that we need
    if not userana :
        logging.error("Failure while calling %s(): None returned", classname, str(e) )
        return None

    for method in ['beginjob', 'beginrun', 'event', 'endrun', 'endjob' ] :
        if not hasattr(userana, method) :
            logging.error("User analysis class %s does not define method %s", classname, method )
            return None

    # looks OK so far
    return userana

#---------------------------------
#  Application class definition --
#---------------------------------

def main( argv ) :

    parser = OptionParser(usage="%prog [options] [xtc-files ...]")
    parser.set_defaults( verbose = 0, 
                         file_list = None, 
                         num_events = 0,
                         job_name = None,
                         module = [] )
    
    parser.add_option( '-v', "--verbose", action="count", help="increase verbosity" )
    parser.add_option( '-l', "--file-list", metavar="FILE",
                       help="file with a list of file names in it" )
    parser.add_option( '-n', "--num-events", metavar="NUMBER", type="int",
                       help="maximum number of events to process" )
    parser.add_option( '-j', "--job-name", metavar="STRING", 
                       help="job name, default is deduced from file name(s)" )
    parser.add_option( '-m', "--module", metavar="NAME", action="append",
                       help="user module name, multiple modules allowed, default is myana" )

    (options, args) = parser.parse_args()
    
    # set logging level
    log_levels = { 0: logging.WARNING, 1: logging.INFO, 2: logging.DEBUG }
    level = log_levels.get ( options.verbose, logging.DEBUG )
    logging.basicConfig( level=level )

    # get file names
    if not args and not options.file_list :
        parser.error("at least one file name or a file list required")
    if args and options.file_list :
        parser.error("file list cannot be used with the file names")
    if options.file_list :
        # read file names from file
        names = file(options.file_list).readlines()
        names = [ n.strip() for n in names ]
        names = [ n for n in names if n ]
    else :
        names = args

    # get job name
    if options.job_name :
        jobname = options.job_name
    else :
        if options.file_list :
            jobname = os.path.basename(options.file_list)
            jobname = os.path.splitext(jobname)[0]
        else :
            jobname = os.path.basename(names[0])
            jobname = os.path.splitext(jobname)[0]

    # group files by run numebr
    runfiles = {}
    for n in names : 
        xname = io.XtcFileName(n)
        runfiles.setdefault(xname.run(), []).append(n)

    # create environment
    env = event.Env(jobname)

    # instantiate histo manager
    hmgr = HistoMgr( file=jobname+".root" )

    # import user module
    modules = options.module
    if not modules : modules = ['myana']
    userObjects = map( _my_import, modules )
    if None in userObjects : return 2

    jobbegun = False
    runbegun = False
    nevent = 0
    ndamage = 0
    damagemask = 0

    # scan all runs
    runs = runfiles.keys()
    runs.sort()
    for run in runs :
        
        names = runfiles[run]
        
        logging.info("Processing run number %s" % run)
        logging.info("File list: %s" % names)
        
        # read datagrams one by one
        for dg in io.XtcMergeIterator( names ) :
    
            damage = dg.xtc.damage.value()
            svc = dg.seq.service()
    
            if damage :
                ndamage += 1
                damagemask |= damage
    
            if not damage or svc == xtc.TransitionId.Configure:
                
                evt = event.Event(dg)
                
                # update environment
                env.update ( evt )
        
                # pass it all to user
                if svc == xtc.TransitionId.Configure :
                    if not jobbegun:
                        for userana in userObjects : userana.beginjob( evt, env )
                        jobbegun = True
                    else :
                        if runbegun : 
                            for userana in userObjects : userana.endrun()
                        for userana in userObjects : userana.beginrun( evt, env )
                        runbegun = True
                elif svc == xtc.TransitionId.L1Accept :
                    for userana in userObjects : userana.event( evt, env )
    
            if svc == xtc.TransitionId.L1Accept :
                nevent += 1
    
            #print "Processed %d events, %d damaged, with damage mask %#x" % (nevent, ndamage, damagemask)
            
            if options.num_events and nevent >= options.num_events : break
            
        if options.num_events and nevent >= options.num_events :
            logging.info("event limit reached (%d), terminating", nevent)
            break

    # finish
    if runbegun : 
        for userana in userObjects : userana.endrun( env )
    for userana in userObjects : userana.endjob( env )
    
    # close histo files
    hmgr.close()

    logging.info("Processed %d events, %d damaged, with damage mask %#x", nevent, ndamage, damagemask)
    
#
#  run application when imported as a main module
#
if __name__ == "__main__" :
    sys.exit( main(sys.argv) )
