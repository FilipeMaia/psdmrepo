#ifndef TRANSLATOR_EPICS_DDL_H
#define TRANSLATOR_EPICS_DDL_H

/* ****************************
** Do not edit this file.  It is auto generated. **

The code is generated from psddl/src/DdlHdf5Translator.py 
  and the template in      psddl/data/templates/hdf5Translator.tmpl?XXX

We use the DDL description of the Epics Pv to 'unroll' the 14 epicsPv
types that we will write into simple 'flat' structures that make it easier
to generate the hdf5 types.  Flat except for stamp, so as not to deviate from
the previous schema, we do not unroll the stamp field into seconds past the epoch
and nanoseconds. These 14 types are EpicsPvCtrl* and EpicsPvTime*
where * is one of String, Short, Float, Enum, Char, Long or Double.

The DDL defines these classes via a C++ class hierarchy, and there are some
compound objects that make up some of the attributes.  For example 

EpicsPvTimeDouble  -> EpicsPvTimeHeader -> EpicsPvHeader

moreover, classes can have compound types, for instance EpicsPvTimeHeader includes an
instance of epicsTimeStamp as an attribute.

For each of the 14 classes, we define a flat structure (except for stamp) that we can fill for Hdf5
translation, a function to produce the hdf5 type, and a function to fill the structure from
the appropriate Psana object that we will obtain from the epics store.

A difference between entries stored in the hdf5 datasets and the epics pv's from xtc, is the following.
EpicsPvTimeLong has an attribute NumElements() which says how many longs are stored (back to back, 
in an array) in the data() field.  If there are 3 longs in a particular epics pv, lets say the
pv name is "LASERTIMING", then for one psana epics pv of "LASERTIMING", we will store 3 entries 
in the "LASERTIMING" dataset of the Hdf5 file.  Each entry has one long in it.

 */

#include <string.h>

#include "hdf5/hdf5.h"
#include "psddl_psana/epics.ddl.h"

namespace Translator {

namespace Unroll {

struct epicsTimeStamp {
  uint32_t secPastEpoch;
  uint32_t nsec;
  epicsTimeStamp & operator=(const Psana::Epics::epicsTimeStamp & rhs) {
    secPastEpoch = rhs.sec();
    nsec = rhs.nsec();
    return *this;
 };
};

struct EpicsPvCtrlString {
  typedef Psana::Epics::EpicsPvCtrlString PsanaSrc;
  int16_t iPvId;
  int16_t iDbrType;
  int16_t iNumElements;
  char sPvName[Psana::Epics::iMaxPvNameLength];
  int16_t status;
  int16_t severity;
 
  char value[Psana::Epics:: MAX_STRING_SIZE];
};

struct EpicsPvCtrlShort {
  typedef Psana::Epics::EpicsPvCtrlShort PsanaSrc;
  int16_t iPvId;
  int16_t iDbrType;
  int16_t iNumElements;
  char sPvName[Psana::Epics::iMaxPvNameLength];
  int16_t status;
  int16_t severity;
  char units[Psana::Epics::MAX_UNITS_SIZE];
  int16_t upper_disp_limit;
  int16_t lower_disp_limit;
  int16_t upper_alarm_limit;
  int16_t upper_warning_limit;
  int16_t lower_warning_limit;
  int16_t lower_alarm_limit;
  int16_t upper_ctrl_limit;
  int16_t lower_ctrl_limit;
 
  int16_t value;
};

struct EpicsPvCtrlFloat {
  typedef Psana::Epics::EpicsPvCtrlFloat PsanaSrc;
  int16_t iPvId;
  int16_t iDbrType;
  int16_t iNumElements;
  char sPvName[Psana::Epics::iMaxPvNameLength];
  int16_t status;
  int16_t severity;
  int16_t precision;
  char units[Psana::Epics::MAX_UNITS_SIZE];
  float upper_disp_limit;
  float lower_disp_limit;
  float upper_alarm_limit;
  float upper_warning_limit;
  float lower_warning_limit;
  float lower_alarm_limit;
  float upper_ctrl_limit;
  float lower_ctrl_limit;
 
  float value;
};

struct EpicsPvCtrlEnum {
  typedef Psana::Epics::EpicsPvCtrlEnum PsanaSrc;
  int16_t iPvId;
  int16_t iDbrType;
  int16_t iNumElements;
  char sPvName[Psana::Epics::iMaxPvNameLength];
  int16_t status;
  int16_t severity;
  int16_t no_str;
  char strs[Psana::Epics::MAX_ENUM_STATES][Psana::Epics::MAX_ENUM_STRING_SIZE];
 
  uint16_t value;
};

struct EpicsPvCtrlChar {
  typedef Psana::Epics::EpicsPvCtrlChar PsanaSrc;
  int16_t iPvId;
  int16_t iDbrType;
  int16_t iNumElements;
  char sPvName[Psana::Epics::iMaxPvNameLength];
  int16_t status;
  int16_t severity;
  char units[Psana::Epics::MAX_UNITS_SIZE];
  uint8_t upper_disp_limit;
  uint8_t lower_disp_limit;
  uint8_t upper_alarm_limit;
  uint8_t upper_warning_limit;
  uint8_t lower_warning_limit;
  uint8_t lower_alarm_limit;
  uint8_t upper_ctrl_limit;
  uint8_t lower_ctrl_limit;
 
  uint8_t value;
};

struct EpicsPvCtrlLong {
  typedef Psana::Epics::EpicsPvCtrlLong PsanaSrc;
  int16_t iPvId;
  int16_t iDbrType;
  int16_t iNumElements;
  char sPvName[Psana::Epics::iMaxPvNameLength];
  int16_t status;
  int16_t severity;
  char units[Psana::Epics::MAX_UNITS_SIZE];
  int32_t upper_disp_limit;
  int32_t lower_disp_limit;
  int32_t upper_alarm_limit;
  int32_t upper_warning_limit;
  int32_t lower_warning_limit;
  int32_t lower_alarm_limit;
  int32_t upper_ctrl_limit;
  int32_t lower_ctrl_limit;
 
  int32_t value;
};

struct EpicsPvCtrlDouble {
  typedef Psana::Epics::EpicsPvCtrlDouble PsanaSrc;
  int16_t iPvId;
  int16_t iDbrType;
  int16_t iNumElements;
  char sPvName[Psana::Epics::iMaxPvNameLength];
  int16_t status;
  int16_t severity;
  int16_t precision;
  char units[Psana::Epics::MAX_UNITS_SIZE];
  double upper_disp_limit;
  double lower_disp_limit;
  double upper_alarm_limit;
  double upper_warning_limit;
  double lower_warning_limit;
  double lower_alarm_limit;
  double upper_ctrl_limit;
  double lower_ctrl_limit;
 
  double value;
};

struct EpicsPvTimeString {
  typedef Psana::Epics::EpicsPvTimeString PsanaSrc;
  int16_t iPvId;
  int16_t iDbrType;
  int16_t iNumElements;
  int16_t status;
  int16_t severity;
  epicsTimeStamp stamp;
 
  char value[Psana::Epics:: MAX_STRING_SIZE];
};

struct EpicsPvTimeShort {
  typedef Psana::Epics::EpicsPvTimeShort PsanaSrc;
  int16_t iPvId;
  int16_t iDbrType;
  int16_t iNumElements;
  int16_t status;
  int16_t severity;
  epicsTimeStamp stamp;
 
  int16_t value;
};

struct EpicsPvTimeFloat {
  typedef Psana::Epics::EpicsPvTimeFloat PsanaSrc;
  int16_t iPvId;
  int16_t iDbrType;
  int16_t iNumElements;
  int16_t status;
  int16_t severity;
  epicsTimeStamp stamp;
 
  float value;
};

struct EpicsPvTimeEnum {
  typedef Psana::Epics::EpicsPvTimeEnum PsanaSrc;
  int16_t iPvId;
  int16_t iDbrType;
  int16_t iNumElements;
  int16_t status;
  int16_t severity;
  epicsTimeStamp stamp;
 
  uint16_t value;
};

struct EpicsPvTimeChar {
  typedef Psana::Epics::EpicsPvTimeChar PsanaSrc;
  int16_t iPvId;
  int16_t iDbrType;
  int16_t iNumElements;
  int16_t status;
  int16_t severity;
  epicsTimeStamp stamp;
 
  uint8_t value;
};

struct EpicsPvTimeLong {
  typedef Psana::Epics::EpicsPvTimeLong PsanaSrc;
  int16_t iPvId;
  int16_t iDbrType;
  int16_t iNumElements;
  int16_t status;
  int16_t severity;
  epicsTimeStamp stamp;
 
  int32_t value;
};

struct EpicsPvTimeDouble {
  typedef Psana::Epics::EpicsPvTimeDouble PsanaSrc;
  int16_t iPvId;
  int16_t iDbrType;
  int16_t iNumElements;
  int16_t status;
  int16_t severity;
  epicsTimeStamp stamp;
 
  double value;
};

} // namespace Unroll

void copyToUnrolled(const Psana::Epics::EpicsPvCtrlString &source, const int16_t element, Unroll::EpicsPvCtrlString &dest);
void copyToUnrolled(const Psana::Epics::EpicsPvCtrlShort &source, const int16_t element, Unroll::EpicsPvCtrlShort &dest);
void copyToUnrolled(const Psana::Epics::EpicsPvCtrlFloat &source, const int16_t element, Unroll::EpicsPvCtrlFloat &dest);
void copyToUnrolled(const Psana::Epics::EpicsPvCtrlEnum &source, const int16_t element, Unroll::EpicsPvCtrlEnum &dest);
void copyToUnrolled(const Psana::Epics::EpicsPvCtrlChar &source, const int16_t element, Unroll::EpicsPvCtrlChar &dest);
void copyToUnrolled(const Psana::Epics::EpicsPvCtrlLong &source, const int16_t element, Unroll::EpicsPvCtrlLong &dest);
void copyToUnrolled(const Psana::Epics::EpicsPvCtrlDouble &source, const int16_t element, Unroll::EpicsPvCtrlDouble &dest);
void copyToUnrolled(const Psana::Epics::EpicsPvTimeString &source, const int16_t element, Unroll::EpicsPvTimeString &dest);
void copyToUnrolled(const Psana::Epics::EpicsPvTimeShort &source, const int16_t element, Unroll::EpicsPvTimeShort &dest);
void copyToUnrolled(const Psana::Epics::EpicsPvTimeFloat &source, const int16_t element, Unroll::EpicsPvTimeFloat &dest);
void copyToUnrolled(const Psana::Epics::EpicsPvTimeEnum &source, const int16_t element, Unroll::EpicsPvTimeEnum &dest);
void copyToUnrolled(const Psana::Epics::EpicsPvTimeChar &source, const int16_t element, Unroll::EpicsPvTimeChar &dest);
void copyToUnrolled(const Psana::Epics::EpicsPvTimeLong &source, const int16_t element, Unroll::EpicsPvTimeLong &dest);
void copyToUnrolled(const Psana::Epics::EpicsPvTimeDouble &source, const int16_t element, Unroll::EpicsPvTimeDouble &dest);
 

template <class U>
void copyValueFldToUnrolled(const typename U::PsanaSrc &psanaVar, int16_t el, U & unrollBuffer) {
  unrollBuffer.value = psanaVar.value(el);
}

template <>
void copyValueFldToUnrolled < Unroll::EpicsPvTimeString >
       (const Unroll::EpicsPvTimeString::PsanaSrc &psanaVar, int16_t el, 
        Unroll::EpicsPvTimeString & unrollBuffer);

template <>
void copyValueFldToUnrolled < Unroll::EpicsPvCtrlString >
       (const Unroll::EpicsPvCtrlString::PsanaSrc &psanaVar, int16_t el, 
        Unroll::EpicsPvCtrlString & unrollBuffer);

template <>
void copyValueFldToUnrolled < Unroll::EpicsPvCtrlEnum >
       (const Unroll::EpicsPvCtrlEnum::PsanaSrc &psanaVar, int16_t el, 
        Unroll::EpicsPvCtrlEnum & unrollBuffer);

hid_t createH5TypeId_epicsTimeStamp();

hid_t createH5TypeId_EpicsPvCtrlString(hid_t pvNameType, hid_t stringType);
hid_t createH5TypeId_EpicsPvCtrlShort(hid_t pvNameType, hid_t unitsType);
hid_t createH5TypeId_EpicsPvCtrlFloat(hid_t pvNameType, hid_t unitsType);
hid_t createH5TypeId_EpicsPvCtrlEnum(hid_t pvNameType, hid_t strsArrayType, int numberOfStrings);
hid_t createH5TypeId_EpicsPvCtrlChar(hid_t pvNameType, hid_t unitsType);
hid_t createH5TypeId_EpicsPvCtrlLong(hid_t pvNameType, hid_t unitsType);
hid_t createH5TypeId_EpicsPvCtrlDouble(hid_t pvNameType, hid_t unitsType);
hid_t createH5TypeId_EpicsPvTimeString(hid_t stringType, hid_t stampType);
hid_t createH5TypeId_EpicsPvTimeShort(hid_t stampType);
hid_t createH5TypeId_EpicsPvTimeFloat(hid_t stampType);
hid_t createH5TypeId_EpicsPvTimeEnum(hid_t stampType);
hid_t createH5TypeId_EpicsPvTimeChar(hid_t stampType);
hid_t createH5TypeId_EpicsPvTimeLong(hid_t stampType);
hid_t createH5TypeId_EpicsPvTimeDouble(hid_t stampType);
 
template <class U>
int getNumberStringsForCtrlEnum(boost::shared_ptr<typename U::PsanaSrc> ptr) { return -1; }

template <>
int getNumberStringsForCtrlEnum<Unroll::EpicsPvCtrlEnum>(boost::shared_ptr<Unroll::EpicsPvCtrlEnum::PsanaSrc> ptr);


} // namespace Translator

#endif
