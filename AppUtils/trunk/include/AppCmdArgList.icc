//--------------------------------------------------------------------------
// File and Version Information:
// 	$Id$
//
// Description:
//	Implementation of methods for a Templated class.
//
// Environment:
//	Software developed for the BaBar Detector at the SLAC B-Factory.
//
// Author List:
//	Andy Salnikov		originator
//
// Copyright Information:
//	Copyright (C) 2003	SLAC
//
//------------------------------------------------------------------------
#include "Lusi/Lusi.h"

//-----------------------
// This Class's Header --
//-----------------------
#include "AppUtils/AppCmdArgList.h"

//-------------
// C Headers --
//-------------
extern "C" {
}

//---------------
// C++ Headers --
//---------------

//-------------------------------
// Collaborating Class Headers --
//-------------------------------
#include "AppUtils/AppCmdTypeTraits.h"

//-----------------------------------------------------------------------
// Local Macros, Typedefs, Structures, Unions and Forward Declarations --
//-----------------------------------------------------------------------


//		----------------------------------------
// 		-- Public Function Member Definitions --
//		----------------------------------------

namespace AppUtils {

/**
 *  Make a required positional argument
 */
template <typename Type>
AppCmdArgList<Type>::AppCmdArgList ( const std::string& name, const std::string& descr )
  : AppCmdArgBase()
  , _name(name)
  , _descr(descr)
  , _required(true)
  , _defValue()
  , _value()
  , _changed(false)
{
}

/**
 *  Make an optional positional argument
 */
template <typename Type>
AppCmdArgList<Type>::AppCmdArgList ( const std::string& name, const std::string& descr, const container& val )
  : AppCmdArgBase()
  , _name(name)
  , _descr(descr)
  , _required(false)
  , _defValue(val)
  , _value(val)
  , _changed(false)
{
}

// Destructor
template <typename Type>
AppCmdArgList<Type>::~AppCmdArgList( )
{
}

/**
 *  Is it required?
 */
template <typename Type>
bool
AppCmdArgList<Type>::isRequired() const
{
  return _required ;
}

/**
 *  Get the name of the paramater
 */
template <typename Type>
const std::string&
AppCmdArgList<Type>::name() const
{
  return _name ;
}

/**
 *  Get one-line description
 */
template <typename Type>
const std::string&
AppCmdArgList<Type>::description() const
{
  return _descr ;
}

/**
 *  How many words from command line could this argument take?
 */
template <typename Type>
size_t
AppCmdArgList<Type>::maxWords () const
{
  return ULONG_MAX ;
}

/**
 *  Set the value of the argument.
 *
 *  @return The number of consumed words. If it is negative then error has occured.
 */
template <typename Type>
int
AppCmdArgList<Type>::setValue ( StringList::const_iterator begin,
		                StringList::const_iterator end )
{
  // sequence must be non-empty
  assert ( begin != end ) ;

  container localCont ;

  for ( ; begin != end ; ++ begin ) {
    std::pair<Type,bool> res = AppCmdTypeTraits<Type>::fromString ( *begin ) ;
    if ( res.second ) {
      localCont.push_back ( res.first ) ;
    } else {
      return -1 ;
    }
  }

  _value = localCont ;
  _changed = true ;

  return _value.size() ;
}

/**
 *  True if the value of the option was changed from command line. Only
 *  makes sense for "optionsl arguments", for required this will always
 *  return true.
 */
template <typename Type>
bool
AppCmdArgList<Type>::valueChanged () const
{
  return _changed ;
}

/**
 *  Return iterator to the begin/end of sequence
 */
template <typename Type>
typename AppCmdArgList<Type>::const_iterator
AppCmdArgList<Type>::begin() const
{
  return _value.begin() ;
}

template <typename Type>
typename AppCmdArgList<Type>::const_iterator
AppCmdArgList<Type>::end() const
{
  return _value.end() ;
}

/**
 *  Clear the collected values
 */
template <typename Type>
void
AppCmdArgList<Type>::clear()
{
  _value.clear() ;
}

/**
 *  reset option to its default value
 */
template <typename Type>
void
AppCmdArgList<Type>::reset()
{
  _value = _defValue ;
  _changed = false ;
}

} // namespace AppUtils
