#ifndef PSDDLPDS_IPIMB_DDL_H
#define PSDDLPDS_IPIMB_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include "pdsdata/xtc/TypeId.hh"

#include <vector>

#include <cstddef>

namespace PsddlPds {
namespace Ipimb {

/** @class ConfigV1

  
*/

#pragma pack(push,4)

class ConfigV1 {
public:
  enum {
    Version = 1 /**< XTC type version number */
  };
  enum {
    TypeId = Pds::TypeId::Id_IpimbConfig /**< XTC type ID value (from Pds::TypeId class) */
  };
  uint64_t triggerCounter() const {return _triggerCounter;}
  uint64_t serialID() const {return _serialID;}
  uint16_t chargeAmpRange() const {return _chargeAmpRange;}
  uint16_t calibrationRange() const {return _calibrationRange;}
  uint32_t resetLength() const {return _resetLength;}
  uint32_t resetDelay() const {return _resetDelay;}
  float chargeAmpRefVoltage() const {return _chargeAmpRefVoltage;}
  float calibrationVoltage() const {return _calibrationVoltage;}
  float diodeBias() const {return _diodeBias;}
  uint16_t status() const {return _status;}
  uint16_t errors() const {return _errors;}
  uint16_t calStrobeLength() const {return _calStrobeLength;}
  uint32_t trigDelay() const {return _trigDelay;}
  static uint32_t _sizeof()  {return 52;}
private:
  uint64_t	_triggerCounter;
  uint64_t	_serialID;
  uint16_t	_chargeAmpRange;
  uint16_t	_calibrationRange;
  uint32_t	_resetLength;
  uint32_t	_resetDelay;
  float	_chargeAmpRefVoltage;
  float	_calibrationVoltage;
  float	_diodeBias;
  uint16_t	_status;
  uint16_t	_errors;
  uint16_t	_calStrobeLength;
  uint16_t	_pad0;
  uint32_t	_trigDelay;
};
#pragma pack(pop)

/** @class ConfigV2

  
*/

#pragma pack(push,4)

class ConfigV2 {
public:
  enum {
    Version = 2 /**< XTC type version number */
  };
  enum {
    TypeId = Pds::TypeId::Id_IpimbConfig /**< XTC type ID value (from Pds::TypeId class) */
  };
  uint64_t triggerCounter() const {return _triggerCounter;}
  uint64_t serialID() const {return _serialID;}
  uint16_t chargeAmpRange() const {return _chargeAmpRange;}
  uint16_t calibrationRange() const {return _calibrationRange;}
  uint32_t resetLength() const {return _resetLength;}
  uint32_t resetDelay() const {return _resetDelay;}
  float chargeAmpRefVoltage() const {return _chargeAmpRefVoltage;}
  float calibrationVoltage() const {return _calibrationVoltage;}
  float diodeBias() const {return _diodeBias;}
  uint16_t status() const {return _status;}
  uint16_t errors() const {return _errors;}
  uint16_t calStrobeLength() const {return _calStrobeLength;}
  uint32_t trigDelay() const {return _trigDelay;}
  uint32_t trigPsDelay() const {return _trigPsDelay;}
  uint32_t adcDelay() const {return _adcDelay;}
  static uint32_t _sizeof()  {return 60;}
private:
  uint64_t	_triggerCounter;
  uint64_t	_serialID;
  uint16_t	_chargeAmpRange;
  uint16_t	_calibrationRange;
  uint32_t	_resetLength;
  uint32_t	_resetDelay;
  float	_chargeAmpRefVoltage;
  float	_calibrationVoltage;
  float	_diodeBias;
  uint16_t	_status;
  uint16_t	_errors;
  uint16_t	_calStrobeLength;
  uint16_t	_pad0;
  uint32_t	_trigDelay;
  uint32_t	_trigPsDelay;
  uint32_t	_adcDelay;
};
#pragma pack(pop)

/** @class DataV1

  
*/

#pragma pack(push,4)

class DataV1 {
public:
  enum {
    Version = 1 /**< XTC type version number */
  };
  enum {
    TypeId = Pds::TypeId::Id_IpimbData /**< XTC type ID value (from Pds::TypeId class) */
  };
  uint64_t triggerCounter() const {return _triggerCounter;}
  uint16_t config0() const {return _config0;}
  uint16_t config1() const {return _config1;}
  uint16_t config2() const {return _config2;}
  /** Raw counts value returned from channel 0. */
  uint16_t channel0() const {return _channel0;}
  /** Raw counts value returned from channel 1. */
  uint16_t channel1() const {return _channel1;}
  /** Raw counts value returned from channel 2. */
  uint16_t channel2() const {return _channel2;}
  /** Raw counts value returned from channel 3. */
  uint16_t channel3() const {return _channel3;}
  uint16_t checksum() const {return _checksum;}
  /** Value of of channel0() converted to Volts. */
  float channel0Volts() const;
  /** Value of of channel1() converted to Volts. */
  float channel1Volts() const;
  /** Value of of channel2() converted to Volts. */
  float channel2Volts() const;
  /** Value of of channel3() converted to Volts. */
  float channel3Volts() const;
  static uint32_t _sizeof()  {return 24;}
private:
  uint64_t	_triggerCounter;
  uint16_t	_config0;
  uint16_t	_config1;
  uint16_t	_config2;
  uint16_t	_channel0;	/**< Raw counts value returned from channel 0. */
  uint16_t	_channel1;	/**< Raw counts value returned from channel 1. */
  uint16_t	_channel2;	/**< Raw counts value returned from channel 2. */
  uint16_t	_channel3;	/**< Raw counts value returned from channel 3. */
  uint16_t	_checksum;
};
#pragma pack(pop)

/** @class DataV2

  
*/

#pragma pack(push,4)

class DataV2 {
public:
  enum {
    Version = 2 /**< XTC type version number */
  };
  enum {
    TypeId = Pds::TypeId::Id_IpimbData /**< XTC type ID value (from Pds::TypeId class) */
  };
  enum {
    ipimbAdcRange = 5 /**<  */
  };
  enum {
    ipimbAdcSteps = 65536 /**<  */
  };
  uint64_t triggerCounter() const {return _triggerCounter;}
  uint16_t config0() const {return _config0;}
  uint16_t config1() const {return _config1;}
  uint16_t config2() const {return _config2;}
  /** Raw counts value returned from channel 0. */
  uint16_t channel0() const {return _channel0;}
  /** Raw counts value returned from channel 1. */
  uint16_t channel1() const {return _channel1;}
  /** Raw counts value returned from channel 2. */
  uint16_t channel2() const {return _channel2;}
  /** Raw counts value returned from channel 3. */
  uint16_t channel3() const {return _channel3;}
  /** Raw counts value returned from channel 0. */
  uint16_t channel0ps() const {return _channel0ps;}
  /** Raw counts value returned from channel 1. */
  uint16_t channel1ps() const {return _channel1ps;}
  /** Raw counts value returned from channel 2. */
  uint16_t channel2ps() const {return _channel2ps;}
  /** Raw counts value returned from channel 3. */
  uint16_t channel3ps() const {return _channel3ps;}
  uint16_t checksum() const {return _checksum;}
  /** Value of of channel0() converted to Volts. */
  float channel0Volts() const;
  /** Value of of channel1() converted to Volts. */
  float channel1Volts() const;
  /** Value of of channel2() converted to Volts. */
  float channel2Volts() const;
  /** Value of of channel3() converted to Volts. */
  float channel3Volts() const;
  /** Value of of channel0ps() converted to Volts. */
  float channel0psVolts() const;
  /** Value of of channel1ps() converted to Volts. */
  float channel1psVolts() const;
  /** Value of of channel2ps() converted to Volts. */
  float channel2psVolts() const;
  /** Value of of channel3ps() converted to Volts. */
  float channel3psVolts() const;
  static uint32_t _sizeof()  {return 32;}
private:
  uint64_t	_triggerCounter;
  uint16_t	_config0;
  uint16_t	_config1;
  uint16_t	_config2;
  uint16_t	_channel0;	/**< Raw counts value returned from channel 0. */
  uint16_t	_channel1;	/**< Raw counts value returned from channel 1. */
  uint16_t	_channel2;	/**< Raw counts value returned from channel 2. */
  uint16_t	_channel3;	/**< Raw counts value returned from channel 3. */
  uint16_t	_channel0ps;	/**< Raw counts value returned from channel 0. */
  uint16_t	_channel1ps;	/**< Raw counts value returned from channel 1. */
  uint16_t	_channel2ps;	/**< Raw counts value returned from channel 2. */
  uint16_t	_channel3ps;	/**< Raw counts value returned from channel 3. */
  uint16_t	_checksum;
};
#pragma pack(pop)
} // namespace Ipimb
} // namespace PsddlPds
#endif // PSDDLPDS_IPIMB_DDL_H
