#ifndef PSDDLPDS_ACQIRIS_DDL_H
#define PSDDLPDS_ACQIRIS_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include "pdsdata/xtc/TypeId.hh"

#include <vector>

#include <cstddef>

namespace PsddlPds {
namespace Acqiris {

/** Class: VertV1
  Pds.Acqiris class VertV1
*/

#pragma pack(push,4)

class VertV1 {
public:
  enum {Version = 1};
  enum Coupling {
    GND,
    DC,
    AC,
    DC50ohm,
    AC50ohm,
  };
  enum Bandwidth {
    None,
    MHz25,
    MHz700,
    MHz200,
    MHz20,
    MHz35,
  };
  VertV1()
  {
  }
  VertV1(double arg__fullScale, double arg__offset, uint32_t arg__coupling, uint32_t arg__bandwidth)
    : _fullScale(arg__fullScale), _offset(arg__offset), _coupling(arg__coupling), _bandwidth(arg__bandwidth)
  {
  }
  double fullScale() const {return _fullScale;}
  double offset() const {return _offset;}
  uint32_t coupling() const {return _coupling;}
  uint32_t bandwidth() const {return _bandwidth;}
  double slope() const;
  static uint32_t _sizeof()  {return 24;}
private:
  double	_fullScale;
  double	_offset;
  uint32_t	_coupling;
  uint32_t	_bandwidth;
};
#pragma pack(pop)

/** Class: HorizV1
  Pds.Acqiris class HorizV1
*/

#pragma pack(push,4)

class HorizV1 {
public:
  enum {Version = 1};
  HorizV1()
  {
  }
  HorizV1(double arg__sampInterval, double arg__delayTime, uint32_t arg__nbrSamples, uint32_t arg__nbrSegments)
    : _sampInterval(arg__sampInterval), _delayTime(arg__delayTime), _nbrSamples(arg__nbrSamples), _nbrSegments(arg__nbrSegments)
  {
  }
  double sampInterval() const {return _sampInterval;}
  double delayTime() const {return _delayTime;}
  uint32_t nbrSamples() const {return _nbrSamples;}
  uint32_t nbrSegments() const {return _nbrSegments;}
  static uint32_t _sizeof()  {return 24;}
private:
  double	_sampInterval;
  double	_delayTime;
  uint32_t	_nbrSamples;
  uint32_t	_nbrSegments;
};
#pragma pack(pop)

/** Class: TrigV1
  Pds.Acqiris class TrigV1
*/

#pragma pack(push,4)

class TrigV1 {
public:
  enum {Version = 1};
  enum Source {
    Internal = 1,
    External = -1,
  };
  enum Coupling {
    DC = 0,
    AC = 1,
    HFreject = 2,
    DC50ohm = 3,
    AC50ohm = 4,
  };
  enum Slope {
    Positive,
    Negative,
    OutOfWindow,
    IntoWindow,
    HFDivide,
    SpikeStretcher,
  };
  TrigV1()
  {
  }
  TrigV1(uint32_t arg__coupling, uint32_t arg__input, uint32_t arg__slope, double arg__level)
    : _coupling(arg__coupling), _input(arg__input), _slope(arg__slope), _level(arg__level)
  {
  }
  uint32_t coupling() const {return _coupling;}
  uint32_t input() const {return _input;}
  uint32_t slope() const {return _slope;}
  double level() const {return _level;}
  static uint32_t _sizeof()  {return 20;}
private:
  uint32_t	_coupling;
  uint32_t	_input;
  uint32_t	_slope;
  double	_level;
};
#pragma pack(pop)

/** Class: ConfigV1
  Pds.Acqiris class ConfigV1
*/

#pragma pack(push,4)

class ConfigV1 {
public:
  enum {Version = 1};
  enum {TypeId = Pds::TypeId::Id_AcqConfig};
  enum {MaxChan = 20};
  uint32_t nbrConvertersPerChannel() const {return _nbrConvertersPerChannel;}
  uint32_t channelMask() const {return _channelMask;}
  uint32_t nbrBanks() const {return _nbrBanks;}
  const Acqiris::TrigV1& trig() const {return _trig;}
  const Acqiris::HorizV1& horiz() const {return _horiz;}
  const Acqiris::VertV1& vert(uint32_t i0) const {return _vert[i0];}
  uint32_t nbrChannels() const;
  static uint32_t _sizeof()  {return ((12+(Acqiris::TrigV1::_sizeof()))+(Acqiris::HorizV1::_sizeof()))+(Acqiris::VertV1::_sizeof()*(MaxChan));}
  std::vector<int> _vert_shape() const;
private:
  uint32_t	_nbrConvertersPerChannel;
  uint32_t	_channelMask;
  uint32_t	_nbrBanks;
  Acqiris::TrigV1	_trig;
  Acqiris::HorizV1	_horiz;
  Acqiris::VertV1	_vert[MaxChan];
};
#pragma pack(pop)

/** Class: TimestampV1
  Pds.Acqiris class "TimestampV1"
*/

#pragma pack(push,4)

class TimestampV1 {
public:
  enum {Version = 1};
  TimestampV1()
  {
  }
  TimestampV1(double arg__horPos, uint32_t arg__timeStampLo, uint32_t arg__timeStampHi)
    : _horPos(arg__horPos), _timeStampLo(arg__timeStampLo), _timeStampHi(arg__timeStampHi)
  {
  }
  double pos() const {return _horPos;}
  uint32_t timeStampLo() const {return _timeStampLo;}
  uint32_t timeStampHi() const {return _timeStampHi;}
  uint64_t value() const;
  static uint32_t _sizeof()  {return 16;}
private:
  double	_horPos;
  uint32_t	_timeStampLo;
  uint32_t	_timeStampHi;
};
#pragma pack(pop)

/** Class: DataDescV1Elem
  Pds.Acqiris class DataDescV1Elem
*/

class ConfigV1;
#pragma pack(push,4)

class DataDescV1Elem {
public:
  enum {Version = 1};
  enum {NumberOfBits = 10};
  enum {BitShift = 6};
  enum {_extra = 32*sizeof(short)};
  uint32_t nbrSamplesInSeg() const {return _returnedSamplesPerSeg;}
  uint32_t indexFirstPoint() const {return _indexFirstPoint;}
  uint32_t nbrSegments() const {return _returnedSegments;}
  const Acqiris::TimestampV1& _timestamp(uint32_t i0) const {
    ptrdiff_t offset=64;
    const Acqiris::TimestampV1* memptr = (const Acqiris::TimestampV1*)(((const char*)this)+offset);
    size_t memsize = memptr->_sizeof();
    return *(const Acqiris::TimestampV1*)((const char*)memptr + (i0)*memsize);
  }
  const int16_t* _waveform(const Acqiris::ConfigV1& cfg) const {
    ptrdiff_t offset=64+(16*(cfg.horiz().nbrSegments()));
    return (const int16_t*)(((const char*)this)+offset);
  }
  static uint32_t _sizeof(const Acqiris::ConfigV1& cfg)  {return ((64+(Acqiris::TimestampV1::_sizeof()*(cfg.horiz().nbrSegments())))+(2*(cfg.horiz().nbrSegments())*(cfg.horiz().nbrSamples())))+(1*(_extra));}
  std::vector<int> _timestamps_shape(const Acqiris::ConfigV1& cfg) const;
  std::vector<int> _waveforms_shape(const Acqiris::ConfigV1& cfg) const;
  std::vector<int> _extraSpace_shape() const;
private:
  uint32_t	_returnedSamplesPerSeg;
  uint32_t	_indexFirstPoint;
  double	_sampTime;
  double	_vGain;
  double	_vOffset;
  uint32_t	_returnedSegments;
  uint32_t	_nbrAvgWforms;
  uint32_t	_actualTriggersInAcqLo;
  uint32_t	_actualTriggersInAcqHi;
  uint32_t	_actualDataSize;
  uint32_t	_reserved2;
  double	_reserved3;
  //Acqiris::TimestampV1	_timestamps[cfg.horiz().nbrSegments()];
  //int16_t	_waveforms[cfg.horiz().nbrSegments()][cfg.horiz().nbrSamples()];
  //int8_t	_extraSpace[_extra];
};
#pragma pack(pop)

/** Class: DataDescV1
  Pds.Acqiris class DataDescV1
*/

class ConfigV1;
#pragma pack(push,4)

class DataDescV1 {
public:
  enum {Version = 1};
  enum {TypeId = Pds::TypeId::Id_AcqWaveform};
  const Acqiris::DataDescV1Elem& data(const Acqiris::ConfigV1& cfg, uint32_t i0) const {
    ptrdiff_t offset=0;
    const Acqiris::DataDescV1Elem* memptr = (const Acqiris::DataDescV1Elem*)(((const char*)this)+offset);
    size_t memsize = memptr->_sizeof(cfg);
    return *(const Acqiris::DataDescV1Elem*)((const char*)memptr + (i0)*memsize);
  }
  static uint32_t _sizeof(const Acqiris::ConfigV1& cfg)  {return 0+(Acqiris::DataDescV1Elem::_sizeof(cfg)*(cfg.nbrChannels()));}
  std::vector<int> _data_shape(const Acqiris::ConfigV1& cfg) const;
private:
  //Acqiris::DataDescV1Elem	_data[cfg.nbrChannels()];
};
#pragma pack(pop)

/** Class: TdcChannel
  Pds.Acqiris class "TdcChannel"
*/

#pragma pack(push,4)

class TdcChannel {
public:
  enum Channel {
    Veto = -2,
    Common = -1,
    Input1 = 1,
    Input2 = 2,
    Input3 = 3,
    Input4 = 4,
    Input5 = 5,
    Input6 = 6,
  };
  enum Mode {
    Active = 0,
    Inactive = 1,
  };
  enum Slope {
    Positive,
    Negative,
  };
  TdcChannel()
  {
  }
  TdcChannel(uint32_t arg__channel, uint32_t arg__mode, double arg__level)
    : _channel(arg__channel), _mode(arg__mode), _level(arg__level)
  {
  }
  uint32_t _channel_int() const {return _channel;}
  uint32_t _mode_int() const {return _mode;}
  Acqiris::TdcChannel::Slope slope() const {return Slope(this->_mode & 0x1);}
  Acqiris::TdcChannel::Mode mode() const {return Mode((this->_mode>>31) & 0x1);}
  double level() const {return _level;}
  Acqiris::TdcChannel::Channel channel() const {return Channel(this->_channel);}
  static uint32_t _sizeof()  {return 16;}
private:
  uint32_t	_channel;
  uint32_t	_mode;
  double	_level;
};
#pragma pack(pop)

/** Class: TdcAuxIO
  Pds.Acqiris class "TdcAuxIO"
*/

#pragma pack(push,4)

class TdcAuxIO {
public:
  enum Channel {
    IOAux1 = 1,
    IOAux2 = 2,
  };
  enum Mode {
    BankSwitch = 1,
    Marker = 2,
    OutputLo = 32,
    OutputHi = 33,
  };
  enum Termination {
    ZHigh = 0,
    Z50 = 1,
  };
  TdcAuxIO()
  {
  }
  TdcAuxIO(uint32_t arg__channel, uint32_t arg__signal, uint32_t arg__qualifier)
    : _channel(arg__channel), _signal(arg__signal), _qualifier(arg__qualifier)
  {
  }
  uint32_t channel_int() const {return _channel;}
  uint32_t signal_int() const {return _signal;}
  uint32_t qualifier_int() const {return _qualifier;}
  Acqiris::TdcAuxIO::Channel channel() const {return Channel(this->_channel);}
  Acqiris::TdcAuxIO::Mode mode() const {return Mode(this->_signal);}
  Acqiris::TdcAuxIO::Termination term() const {return Termination(this->_qualifier);}
  static uint32_t _sizeof()  {return 12;}
private:
  uint32_t	_channel;
  uint32_t	_signal;
  uint32_t	_qualifier;
};
#pragma pack(pop)

/** Class: TdcVetoIO
  Pds.Acqiris class "TdcVetoIO"
*/

#pragma pack(push,4)

class TdcVetoIO {
public:
  enum Channel {
    ChVeto = 13,
  };
  enum Mode {
    Veto = 1,
    SwitchVeto = 2,
    InvertedVeto = 3,
    InvertedSwitchVeto = 4,
  };
  enum Termination {
    ZHigh = 0,
    Z50 = 1,
  };
  TdcVetoIO()
  {
  }
  TdcVetoIO(uint32_t mode, uint32_t term)
    : _channel(ChVeto), _signal(mode), _qualifier(term)
  {
  }
  uint32_t signal_int() const {return _signal;}
  uint32_t qualifier_int() const {return _qualifier;}
  Acqiris::TdcVetoIO::Channel channel() const {return Channel(this->_channel);}
  Acqiris::TdcVetoIO::Mode mode() const {return Mode(this->_signal);}
  Acqiris::TdcVetoIO::Termination term() const {return Termination(this->_qualifier);}
  static uint32_t _sizeof()  {return 12;}
private:
  uint32_t	_channel;
  uint32_t	_signal;
  uint32_t	_qualifier;
};
#pragma pack(pop)

/** Class: TdcConfigV1
  Pds.Acqiris class TdcConfigV1
*/

#pragma pack(push,4)

class TdcConfigV1 {
public:
  enum {Version = 1};
  enum {TypeId = Pds::TypeId::Id_AcqTdcConfig};
  enum {NChannels = 8};
  enum {NAuxIO = 2};
  const Acqiris::TdcChannel& channels(uint32_t i0) const {return _channel[i0];}
  const Acqiris::TdcAuxIO& auxio(uint32_t i0) const {return _auxIO[i0];}
  const Acqiris::TdcVetoIO& veto() const {return _veto;}
  static uint32_t _sizeof()  {return ((0+(Acqiris::TdcChannel::_sizeof()*(NChannels)))+(Acqiris::TdcAuxIO::_sizeof()*(NAuxIO)))+(Acqiris::TdcVetoIO::_sizeof());}
  std::vector<int> _channel_shape() const;
  std::vector<int> _auxIO_shape() const;
private:
  Acqiris::TdcChannel	_channel[NChannels];
  Acqiris::TdcAuxIO	_auxIO[NAuxIO];
  Acqiris::TdcVetoIO	_veto;
};
#pragma pack(pop)

/** Class: TdcDataV1_Item
  Pds.Acqiris class TdcDataV1
*/


class TdcDataV1_Item {
public:
  enum Source {
    Comm,
    Chan1,
    Chan2,
    Chan3,
    Chan4,
    Chan5,
    Chan6,
    AuxIO,
  };
  TdcDataV1_Item()
  {
  }
  TdcDataV1_Item(uint32_t arg__value)
    : _value(arg__value)
  {
  }
  uint32_t value() const {return _value;}
protected:
  uint32_t bf_val_() const {return uint32_t(this->_value & 0xfffffff);}
public:
  Acqiris::TdcDataV1_Item::Source source() const {return Source((this->_value>>28) & 0x7);}
protected:
  uint8_t bf_ofv_() const {return uint8_t((this->_value>>31) & 0x1);}
public:
  static uint32_t _sizeof()  {return 4;}
private:
  uint32_t	_value;
};

/** Class: TdcDataV1Common
  Pds.Acqiris class TdcDataV1::Common
*/


class TdcDataV1Common: public TdcDataV1_Item {
public:
  uint32_t nhits() const;
  uint8_t overflow() const;
  static uint32_t _sizeof()  {return Acqiris::TdcDataV1_Item::_sizeof();}
};

/** Class: TdcDataV1Channel
  Pds.Acqiris class TdcDataV1::Channel
*/


class TdcDataV1Channel: public TdcDataV1_Item {
public:
  uint32_t ticks() const;
  uint8_t overflow() const;
  double time() const;
  static uint32_t _sizeof()  {return Acqiris::TdcDataV1_Item::_sizeof();}
};

/** Class: TdcDataV1Marker
  Pds.Acqiris class TdcDataV1::Marker
*/


class TdcDataV1Marker: public TdcDataV1_Item {
public:
  enum Type {
    AuxIOSwitch = 0,
    EventCntSwitch = 1,
    MemFullSwitch = 2,
    AuxIOMarker = 16,
  };
  Acqiris::TdcDataV1Marker::Type type() const;
  static uint32_t _sizeof()  {return Acqiris::TdcDataV1_Item::_sizeof();}
};

/** Class: TdcDataV1
  Pds.Acqiris class TdcDataV1
*/


class TdcDataV1 {
public:
  enum {Version = 1};
  enum {TypeId = Pds::TypeId::Id_AcqTdcData};
  const Acqiris::TdcDataV1_Item& data(uint32_t i0) const {
    ptrdiff_t offset=0;
    const Acqiris::TdcDataV1_Item* memptr = (const Acqiris::TdcDataV1_Item*)(((const char*)this)+offset);
    size_t memsize = memptr->_sizeof();
    return *(const Acqiris::TdcDataV1_Item*)((const char*)memptr + (i0)*memsize);
  }
  static uint32_t _sizeof()  {return ~uint32_t(0);}
  std::vector<int> _data_shape() const;
private:
  //Acqiris::TdcDataV1_Item	_data[None];
};
} // namespace Acqiris
} // namespace PsddlPds
#endif // PSDDLPDS_ACQIRIS_DDL_H
