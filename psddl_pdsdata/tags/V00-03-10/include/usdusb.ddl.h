#ifndef PSDDLPDS_USDUSB_DDL_H
#define PSDDLPDS_USDUSB_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <cstddef>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
namespace PsddlPds {
namespace UsdUsb {

/** @class ConfigV1

  
*/


class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_UsdUsbConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { NCHANNELS = 4 };
  enum Count_Mode {
    WRAP_FULL,
    LIMIT,
    HALT,
    WRAP_PRESET,
  };
  enum Quad_Mode {
    CLOCK_DIR,
    X1,
    X2,
    X4,
  };
  ndarray<uint32_t, 1> counting_mode() const { return make_ndarray(&_count_mode[0], NCHANNELS); }
  ndarray<uint32_t, 1> quadrature_mode() const { return make_ndarray(&_quad_mode[0], NCHANNELS); }
  static uint32_t _sizeof()  { return (0+(4*(NCHANNELS)))+(4*(NCHANNELS)); }
private:
  uint32_t	_count_mode[NCHANNELS];
  uint32_t	_quad_mode[NCHANNELS];
};

/** @class DataV1

  
*/


class DataV1 {
public:
  enum { TypeId = Pds::TypeId::Id_UsdUsbData /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { Encoder_Inputs = 4 };
  enum { Analog_Inputs = 4 };
  enum { Digital_Inputs = 4 };
  uint8_t digital_in() const { return _din; }
  uint32_t timestamp() const { return _timestamp; }
  /** Lower 24 bits of encoder_count as signed integer value. */
  int32_t value(uint32_t i) const;
  static uint32_t _sizeof()  { return ((((((0+(1*(6)))+1)+1)+4)+(4*(Encoder_Inputs)))+(1*(4)))+(2*(Analog_Inputs)); }
private:
  uint8_t	_header[6];
  uint8_t	_din;
  uint8_t	_estop;
  uint32_t	_timestamp;
  uint32_t	_count[Encoder_Inputs];
  uint8_t	_status[4];
  uint16_t	_ain[Analog_Inputs];
};
} // namespace UsdUsb
} // namespace PsddlPds
#endif // PSDDLPDS_USDUSB_DDL_H
