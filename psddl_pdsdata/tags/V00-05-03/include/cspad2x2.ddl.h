#ifndef PSDDLPDS_CSPAD2X2_DDL_H
#define PSDDLPDS_CSPAD2X2_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
namespace PsddlPds {
namespace CsPad2x2 {
  enum {
    QuadsPerSensor = 1 /**< Defines number of quadrants in a CsPad2x2 device. */
  };
  enum {
    ASICsPerQuad = 4 /**< Total number of ASICs in one quadrant. */
  };
  enum {
    RowsPerBank = 26 /**< Number of rows per readout bank? */
  };
  enum {
    FullBanksPerASIC = 7 /**< Number of full readout banks per one ASIC? */
  };
  enum {
    BanksPerASIC = 8 /**< Number of readout banks per one ASIC? */
  };
  enum {
    ColumnsPerASIC = 185 /**< Number of columns readout by single ASIC. */
  };
  enum {
    MaxRowsPerASIC = 194 /**< Maximum number of rows readout by single ASIC. */
  };
  enum {
    PotsPerQuad = 80 /**< Number of POTs? per single quadrant. */
  };
  enum {
    TwoByTwosPerQuad = 1 /**< Total number of 2x2s in single quadrant. */
  };
  enum {
    SectorsPerQuad = 2 /**< Total number of sectors (2x1) per single quadrant. */
  };

  /** Enum specifying different running modes. */
  enum RunModes {
    NoRunning,
    RunButDrop,
    RunAndSendToRCE,
    RunAndSendTriggeredByTTL,
    ExternalTriggerSendToRCE,
    ExternalTriggerDrop,
    NumberOfRunModes,
  };

  /** Enum specifying different data collection modes. */
  enum DataModes {
    normal = 0,
    shiftTest = 1,
    testData = 2,
    reserved = 3,
  };

/** @class CsPad2x2DigitalPotsCfg

  Class defining configuration for CsPad POTs?
*/


class CsPad2x2DigitalPotsCfg {
public:
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint8_t, 1> pots(const boost::shared_ptr<T>& owner) const { 
    const uint8_t* data = &_pots[0];
    return make_ndarray(boost::shared_ptr<const uint8_t>(owner, data), PotsPerQuad);
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint8_t, 1> pots() const { return make_ndarray(&_pots[0], PotsPerQuad); }
  static uint32_t _sizeof() { return ((((0+(1*(PotsPerQuad)))+1)-1)/1)*1; }
private:
  uint8_t	_pots[PotsPerQuad];
};

/** @class CsPad2x2ReadOnlyCfg

  Class defining read-only configuration.
*/


class CsPad2x2ReadOnlyCfg {
public:
  CsPad2x2ReadOnlyCfg()
  {
  }
  CsPad2x2ReadOnlyCfg(uint32_t arg__shiftTest, uint32_t arg__version)
    : _shiftTest(arg__shiftTest), _version(arg__version)
  {
  }
  uint32_t shiftTest() const { return _shiftTest; }
  uint32_t version() const { return _version; }
  static uint32_t _sizeof() { return 8; }
private:
  uint32_t	_shiftTest;
  uint32_t	_version;
};

/** @class ProtectionSystemThreshold

  
*/


class ProtectionSystemThreshold {
public:
  ProtectionSystemThreshold()
  {
  }
  ProtectionSystemThreshold(uint32_t arg__adcThreshold, uint32_t arg__pixelCountThreshold)
    : _adcThreshold(arg__adcThreshold), _pixelCountThreshold(arg__pixelCountThreshold)
  {
  }
  uint32_t adcThreshold() const { return _adcThreshold; }
  uint32_t pixelCountThreshold() const { return _pixelCountThreshold; }
  static uint32_t _sizeof() { return 8; }
private:
  uint32_t	_adcThreshold;
  uint32_t	_pixelCountThreshold;
};

/** @class CsPad2x2GainMapCfg

  Class defining ASIC gain map.
*/


class CsPad2x2GainMapCfg {
public:
  /** Array with the gain map for single ASIC.

    Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 2> gainMap(const boost::shared_ptr<T>& owner) const { 
    const uint16_t* data = &_gainMap[0][0];
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), ColumnsPerASIC, MaxRowsPerASIC);
  }
  /** Array with the gain map for single ASIC.

    Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 2> gainMap() const { return make_ndarray(&_gainMap[0][0], ColumnsPerASIC, MaxRowsPerASIC); }
  static uint32_t _sizeof() { return ((((0+(2*(ColumnsPerASIC)*(MaxRowsPerASIC)))+2)-1)/2)*2; }
private:
  uint16_t	_gainMap[ColumnsPerASIC][MaxRowsPerASIC];	/**< Array with the gain map for single ASIC. */
};

/** @class ConfigV1QuadReg

  Configuration data for single "quadrant" which for 2x2 means a single 2x2.
*/


class ConfigV1QuadReg {
public:
  uint32_t shiftSelect() const { return _shiftSelect; }
  uint32_t edgeSelect() const { return _edgeSelect; }
  uint32_t readClkSet() const { return _readClkSet; }
  uint32_t readClkHold() const { return _readClkHold; }
  uint32_t dataMode() const { return _dataMode; }
  uint32_t prstSel() const { return _prstSel; }
  uint32_t acqDelay() const { return _acqDelay; }
  uint32_t intTime() const { return _intTime; }
  uint32_t digDelay() const { return _digDelay; }
  uint32_t ampIdle() const { return _ampIdle; }
  uint32_t injTotal() const { return _injTotal; }
  uint32_t rowColShiftPer() const { return _rowColShiftPer; }
  uint32_t ampReset() const { return _ampReset; }
  uint32_t digCount() const { return _digCount; }
  uint32_t digPeriod() const { return _digPeriod; }
  uint32_t PeltierEnable() const { return _PeltierEnable; }
  uint32_t kpConstant() const { return _kpConstant; }
  uint32_t kiConstant() const { return _kiConstant; }
  uint32_t kdConstant() const { return _kdConstant; }
  uint32_t humidThold() const { return _humidThold; }
  uint32_t setPoint() const { return _setPoint; }
  /** read-only configuration */
  const CsPad2x2::CsPad2x2ReadOnlyCfg& ro() const { return _readOnly; }
  const CsPad2x2::CsPad2x2DigitalPotsCfg& dp() const { return _digitalPots; }
  /** Gain map. */
  const CsPad2x2::CsPad2x2GainMapCfg& gm() const { return _gainMap; }
  static uint32_t _sizeof() { return ((((((84+(CsPad2x2::CsPad2x2ReadOnlyCfg::_sizeof()))+(CsPad2x2::CsPad2x2DigitalPotsCfg::_sizeof()))+(CsPad2x2::CsPad2x2GainMapCfg::_sizeof()))+4)-1)/4)*4; }
private:
  uint32_t	_shiftSelect;
  uint32_t	_edgeSelect;
  uint32_t	_readClkSet;
  uint32_t	_readClkHold;
  uint32_t	_dataMode;
  uint32_t	_prstSel;
  uint32_t	_acqDelay;
  uint32_t	_intTime;
  uint32_t	_digDelay;
  uint32_t	_ampIdle;
  uint32_t	_injTotal;
  uint32_t	_rowColShiftPer;
  uint32_t	_ampReset;
  uint32_t	_digCount;
  uint32_t	_digPeriod;
  uint32_t	_PeltierEnable;
  uint32_t	_kpConstant;
  uint32_t	_kiConstant;
  uint32_t	_kdConstant;
  uint32_t	_humidThold;
  uint32_t	_setPoint;
  CsPad2x2::CsPad2x2ReadOnlyCfg	_readOnly;	/**< read-only configuration */
  CsPad2x2::CsPad2x2DigitalPotsCfg	_digitalPots;
  CsPad2x2::CsPad2x2GainMapCfg	_gainMap;	/**< Gain map. */
};

/** @class ConfigV1

  Configuration data for 2x2 CsPad device.
*/


class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_Cspad2x2Config /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  uint32_t concentratorVersion() const { return _concentratorVersion; }
  const CsPad2x2::ProtectionSystemThreshold& protectionThreshold() const { return _protectionThreshold; }
  uint32_t protectionEnable() const { return _protectionEnable; }
  uint32_t inactiveRunMode() const { return _inactiveRunMode; }
  uint32_t activeRunMode() const { return _activeRunMode; }
  uint32_t tdi() const { return _testDataIndex; }
  uint32_t payloadSize() const { return _payloadPerQuad; }
  uint32_t badAsicMask() const { return _badAsicMask; }
  uint32_t asicMask() const { return _AsicMask; }
  uint32_t roiMask() const { return _roiMask; }
  const CsPad2x2::ConfigV1QuadReg& quad() const { return _quad; }
  uint32_t numAsicsRead() const;
  /** Number of ASICs in given quadrant */
  uint32_t numAsicsStored() const;
  static uint32_t _sizeof() { return (((((((((((((4+(CsPad2x2::ProtectionSystemThreshold::_sizeof()))+4)+4)+4)+4)+4)+4)+4)+4)+(CsPad2x2::ConfigV1QuadReg::_sizeof()))+4)-1)/4)*4; }
private:
  uint32_t	_concentratorVersion;
  CsPad2x2::ProtectionSystemThreshold	_protectionThreshold;
  uint32_t	_protectionEnable;
  uint32_t	_inactiveRunMode;
  uint32_t	_activeRunMode;
  uint32_t	_testDataIndex;
  uint32_t	_payloadPerQuad;
  uint32_t	_badAsicMask;
  uint32_t	_AsicMask;
  uint32_t	_roiMask;
  CsPad2x2::ConfigV1QuadReg	_quad;
};

/** @class ConfigV2QuadReg

  Configuration data for single "quadrant" which for 2x2 means a single 2x2.
*/


class ConfigV2QuadReg {
public:
  uint32_t shiftSelect() const { return _shiftSelect; }
  uint32_t edgeSelect() const { return _edgeSelect; }
  uint32_t readClkSet() const { return _readClkSet; }
  uint32_t readClkHold() const { return _readClkHold; }
  uint32_t dataMode() const { return _dataMode; }
  uint32_t prstSel() const { return _prstSel; }
  uint32_t acqDelay() const { return _acqDelay; }
  uint32_t intTime() const { return _intTime; }
  uint32_t digDelay() const { return _digDelay; }
  uint32_t ampIdle() const { return _ampIdle; }
  uint32_t injTotal() const { return _injTotal; }
  uint32_t rowColShiftPer() const { return _rowColShiftPer; }
  uint32_t ampReset() const { return _ampReset; }
  uint32_t digCount() const { return _digCount; }
  uint32_t digPeriod() const { return _digPeriod; }
  uint32_t PeltierEnable() const { return _PeltierEnable; }
  uint32_t kpConstant() const { return _kpConstant; }
  uint32_t kiConstant() const { return _kiConstant; }
  uint32_t kdConstant() const { return _kdConstant; }
  uint32_t humidThold() const { return _humidThold; }
  uint32_t setPoint() const { return _setPoint; }
  /** bias tuning is used, but not written;
            2 bits per nibble, C2,C1,I5,I2;
            bit order rc00rc00rc00rc */
  uint32_t biasTuning() const { return _biasTuning; }
  /** pMOS and nMOS Displacement and Main;
            used but not written and not in GUI yet;
            hard-wired to zero in GUI;
            2 bits per nibble, bit order pd00pm00nd00nm */
  uint32_t pdpmndnmBalance() const { return _pdpmndnmBalance; }
  /** read-only configuration */
  const CsPad2x2::CsPad2x2ReadOnlyCfg& ro() const { return _readOnly; }
  const CsPad2x2::CsPad2x2DigitalPotsCfg& dp() const { return _digitalPots; }
  /** Gain map. */
  const CsPad2x2::CsPad2x2GainMapCfg& gm() const { return _gainMap; }
  static uint32_t _sizeof() { return ((((((92+(CsPad2x2::CsPad2x2ReadOnlyCfg::_sizeof()))+(CsPad2x2::CsPad2x2DigitalPotsCfg::_sizeof()))+(CsPad2x2::CsPad2x2GainMapCfg::_sizeof()))+4)-1)/4)*4; }
private:
  uint32_t	_shiftSelect;
  uint32_t	_edgeSelect;
  uint32_t	_readClkSet;
  uint32_t	_readClkHold;
  uint32_t	_dataMode;
  uint32_t	_prstSel;
  uint32_t	_acqDelay;
  uint32_t	_intTime;
  uint32_t	_digDelay;
  uint32_t	_ampIdle;
  uint32_t	_injTotal;
  uint32_t	_rowColShiftPer;
  uint32_t	_ampReset;
  uint32_t	_digCount;
  uint32_t	_digPeriod;
  uint32_t	_PeltierEnable;
  uint32_t	_kpConstant;
  uint32_t	_kiConstant;
  uint32_t	_kdConstant;
  uint32_t	_humidThold;
  uint32_t	_setPoint;
  uint32_t	_biasTuning;	/**< bias tuning is used, but not written;
            2 bits per nibble, C2,C1,I5,I2;
            bit order rc00rc00rc00rc */
  uint32_t	_pdpmndnmBalance;	/**< pMOS and nMOS Displacement and Main;
            used but not written and not in GUI yet;
            hard-wired to zero in GUI;
            2 bits per nibble, bit order pd00pm00nd00nm */
  CsPad2x2::CsPad2x2ReadOnlyCfg	_readOnly;	/**< read-only configuration */
  CsPad2x2::CsPad2x2DigitalPotsCfg	_digitalPots;
  CsPad2x2::CsPad2x2GainMapCfg	_gainMap;	/**< Gain map. */
};

/** @class ConfigV2

  Configuration data for 2x2 CsPad device.
*/


class ConfigV2 {
public:
  enum { TypeId = Pds::TypeId::Id_Cspad2x2Config /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  uint32_t concentratorVersion() const { return _concentratorVersion; }
  const CsPad2x2::ProtectionSystemThreshold& protectionThreshold() const { return _protectionThreshold; }
  uint32_t protectionEnable() const { return _protectionEnable; }
  uint32_t inactiveRunMode() const { return _inactiveRunMode; }
  uint32_t activeRunMode() const { return _activeRunMode; }
  uint32_t runTriggerDelay() const { return _runTriggerDelay; }
  uint32_t tdi() const { return _testDataIndex; }
  uint32_t payloadSize() const { return _payloadPerQuad; }
  uint32_t badAsicMask() const { return _badAsicMask; }
  uint32_t asicMask() const { return _AsicMask; }
  uint32_t roiMask() const { return _roiMask; }
  const CsPad2x2::ConfigV2QuadReg& quad() const { return _quad; }
  uint32_t numAsicsRead() const;
  /** Number of ASICs in given quadrant */
  uint32_t numAsicsStored() const;
  static uint32_t _sizeof() { return ((((((((((((((4+(CsPad2x2::ProtectionSystemThreshold::_sizeof()))+4)+4)+4)+4)+4)+4)+4)+4)+4)+(CsPad2x2::ConfigV2QuadReg::_sizeof()))+4)-1)/4)*4; }
private:
  uint32_t	_concentratorVersion;
  CsPad2x2::ProtectionSystemThreshold	_protectionThreshold;
  uint32_t	_protectionEnable;
  uint32_t	_inactiveRunMode;
  uint32_t	_activeRunMode;
  uint32_t	_runTriggerDelay;
  uint32_t	_testDataIndex;
  uint32_t	_payloadPerQuad;
  uint32_t	_badAsicMask;
  uint32_t	_AsicMask;
  uint32_t	_roiMask;
  CsPad2x2::ConfigV2QuadReg	_quad;
};

/** @class ElementV1

  CsPad data from single 2x2 element.
*/


class ElementV1 {
public:
  enum { TypeId = Pds::TypeId::Id_Cspad2x2Element /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { Nsbtemp = 4 /**< Number of the elements in _sbtemp array. */ };
  /** Virtual channel number. */
  uint32_t virtual_channel() const { return uint32_t(this->_word0 & 0x3); }
  /** Lane number. */
  uint32_t lane() const { return uint32_t((this->_word0>>6) & 0x3); }
  uint32_t tid() const { return uint32_t((this->_word0>>8) & 0xffffff); }
  uint32_t acq_count() const { return uint32_t(this->_word1 & 0xffff); }
  uint32_t op_code() const { return uint32_t((this->_word1>>16) & 0xff); }
  /** Quadrant number. */
  uint32_t quad() const { return uint32_t((this->_word1>>24) & 0x3); }
  uint32_t seq_count() const { return _seq_count; }
  uint32_t ticks() const { return _ticks; }
  uint32_t fiducials() const { return _fiducials; }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const uint16_t, 1> sb_temp(const boost::shared_ptr<T>& owner) const { 
    const uint16_t* data = &_sbtemp[0];
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), Nsbtemp);
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const uint16_t, 1> sb_temp() const { return make_ndarray(&_sbtemp[0], Nsbtemp); }
  uint32_t frame_type() const { return _frame_type; }
  /**     Note: this overloaded method accepts shared pointer argument which must point to an object containing
    this instance, the returned ndarray object can be used even after this instance disappears. */
  template <typename T>
  ndarray<const int16_t, 3> data(const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32;
    const int16_t* data = (const int16_t*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const int16_t>(owner, data), ColumnsPerASIC,  MaxRowsPerASIC*2,  2);
  }
  /**     Note: this method returns ndarray instance which does not control lifetime
    of the data, do not use returned ndarray after this instance disappears. */
  ndarray<const int16_t, 3> data() const { ptrdiff_t offset=32;
  const int16_t* data = (const int16_t*)(((char*)this)+offset);
  return make_ndarray(data, ColumnsPerASIC,  MaxRowsPerASIC*2,  2); }
  /** Common mode value for a given section, section number can be 0 or 1.
                Will return 0 for data read from XTC, may be non-zero after calibration. */
  float common_mode(uint32_t section) const;
  static uint32_t _sizeof() { return ((((((20+(2*(Nsbtemp)))+4)+(2*(ColumnsPerASIC)*( MaxRowsPerASIC*2)*( 2)))+4)-1)/4)*4; }
private:
  uint32_t	_word0;
  uint32_t	_word1;
  uint32_t	_seq_count;
  uint32_t	_ticks;
  uint32_t	_fiducials;
  uint16_t	_sbtemp[Nsbtemp];
  uint32_t	_frame_type;
  //int16_t	_data[ColumnsPerASIC][ MaxRowsPerASIC*2][ 2];
};
} // namespace CsPad2x2
} // namespace PsddlPds
#endif // PSDDLPDS_CSPAD2X2_DDL_H
