#ifndef PSDDLPDS_IMP_DDL_H
#define PSDDLPDS_IMP_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
namespace PsddlPds {
namespace Imp {

/** @class ConfigV1

  
*/

#pragma pack(push,4)

class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_ImpConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum Registers {
    Range,
    Cal_range,
    Reset,
    Bias_data,
    Cal_data,
    BiasDac_data,
    Cal_strobe,
    NumberOfSamples,
    TrigDelay,
    Adc_delay,
    NumberOfRegisters,
  };
  uint32_t range() const { return _range; }
  uint32_t calRange() const { return _calRange; }
  uint32_t reset() const { return _reset; }
  uint32_t biasData() const { return _biasData; }
  uint32_t calData() const { return _calData; }
  uint32_t biasDacData() const { return _biasDacData; }
  uint32_t calStrobe() const { return _calStrobe; }
  uint32_t numberOfSamples() const { return _numberOfSamples; }
  uint32_t trigDelay() const { return _trigDelay; }
  uint32_t adcDelay() const { return _adcDelay; }
  static uint32_t _sizeof() { return 40; }
private:
  uint32_t	_range;
  uint32_t	_calRange;
  uint32_t	_reset;
  uint32_t	_biasData;
  uint32_t	_calData;
  uint32_t	_biasDacData;
  uint32_t	_calStrobe;
  uint32_t	_numberOfSamples;
  uint32_t	_trigDelay;
  uint32_t	_adcDelay;
};
std::ostream& operator<<(std::ostream& str, Imp::ConfigV1::Registers enval);
#pragma pack(pop)

/** @class Sample

  
*/


class Sample {
public:
  enum { channelsPerDevice = 4 };
  Sample()
  {
  }
  Sample(const uint16_t* arg__channels)
  {
    std::copy(arg__channels, arg__channels+(4), _channels);
  }
  template <typename T>
  ndarray<const uint16_t, 1> channels(const boost::shared_ptr<T>& owner) const { 
    const uint16_t* data = &_channels[0];
    return make_ndarray(boost::shared_ptr<const uint16_t>(owner, data), 4);
   }
  ndarray<const uint16_t, 1> channels() const { return make_ndarray(&_channels[0], 4); }
  static uint32_t _sizeof() { return ((((0+(2*(4)))+2)-1)/2)*2; }
private:
  uint16_t	_channels[4];
};

/** @class LaneStatus

  
*/


class LaneStatus {
public:
  LaneStatus()
  {
  }
  LaneStatus(uint8_t arg__usLinkErrCount, uint8_t arg__usLinkDownCount, uint8_t arg__usCellErrCount, uint8_t arg__usRxCount, uint8_t arg__usLocLinked, uint8_t arg__usRemLinked, uint16_t arg__zeros, uint8_t arg__powersOkay)
    : _value(((arg__usLinkErrCount) & 0xf)|(((arg__usLinkDownCount) & 0xf)<<4)|(((arg__usCellErrCount) & 0xf)<<8)|(((arg__usRxCount) & 0xf)<<12)|(((arg__usLocLinked) & 0x1)<<16)|(((arg__usRemLinked) & 0x1)<<17)|(((arg__zeros) & 0x3ff)<<18)|(((arg__powersOkay) & 0xf)<<28))
  {
  }
  uint8_t linkErrCount() const { return uint8_t(this->_value & 0xf); }
  uint8_t linkDownCount() const { return uint8_t((this->_value>>4) & 0xf); }
  uint8_t cellErrCount() const { return uint8_t((this->_value>>8) & 0xf); }
  uint8_t rxCount() const { return uint8_t((this->_value>>12) & 0xf); }
  uint8_t locLinked() const { return uint8_t((this->_value>>16) & 0x1); }
  uint8_t remLinked() const { return uint8_t((this->_value>>17) & 0x1); }
  uint16_t zeros() const { return uint16_t((this->_value>>18) & 0x3ff); }
  uint8_t powersOkay() const { return uint8_t((this->_value>>28) & 0xf); }
  static uint32_t _sizeof() { return 4; }
private:
  uint32_t	_value;
};

/** @class ElementV1

  
*/

class ConfigV1;
#pragma pack(push,2)

class ElementV1 {
public:
  enum { TypeId = Pds::TypeId::Id_ImpData /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  uint8_t vc() const { return uint8_t(this->_first & 0x3); }
  uint8_t lane() const { return uint8_t((this->_first>>6) & 0x3); }
  uint32_t frameNumber() const { return _frameNumber; }
  uint32_t range() const { return _range; }
  const Imp::LaneStatus& laneStatus() const { return _laneStatus; }
  template <typename T>
  ndarray<const Imp::Sample, 1> samples(const Imp::ConfigV1& cfg, const boost::shared_ptr<T>& owner) const { 
    ptrdiff_t offset=32;
    const Imp::Sample* data = (const Imp::Sample*)(((char*)this)+offset);
    return make_ndarray(boost::shared_ptr<const Imp::Sample>(owner, data), cfg.numberOfSamples());
   }
  ndarray<const Imp::Sample, 1> samples(const Imp::ConfigV1& cfg) const { ptrdiff_t offset=32;
  const Imp::Sample* data = (const Imp::Sample*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numberOfSamples()); }
  static uint32_t _sizeof(const Imp::ConfigV1& cfg) { return ((((((24+(Imp::LaneStatus::_sizeof()))+4)+(Imp::Sample::_sizeof()*(cfg.numberOfSamples())))+2)-1)/2)*2; }
private:
  uint32_t	_first;
  uint32_t	_second;
  uint32_t	_frameNumber;
  uint32_t	_ticks;
  uint32_t	_fiducials;
  uint32_t	_range;
  Imp::LaneStatus	_laneStatus;
  uint32_t	_z;
  //Imp::Sample	_samples[cfg.numberOfSamples()];
};
#pragma pack(pop)
} // namespace Imp
} // namespace PsddlPds
#endif // PSDDLPDS_IMP_DDL_H
