#ifndef PSDDLPDS_ENCODER_DDL_H
#define PSDDLPDS_ENCODER_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include "pdsdata/xtc/TypeId.hh"

#include <vector>

#include <cstddef>

namespace PsddlPds {
namespace Encoder {

/** @class ConfigV1

  
*/


class ConfigV1 {
public:
  enum {
    Version = 1 /**< XTC type version number */
  };
  enum {
    TypeId = Pds::TypeId::Id_EncoderConfig /**< XTC type ID value (from Pds::TypeId class) */
  };
  enum count_mode_type {
    WRAP_FULL,
    LIMIT,
    HALT,
    WRAP_PRESET,
    COUNT_END,
  };
  enum quad_mode {
    CLOCK_DIR,
    X1,
    X2,
    X4,
    QUAD_END,
  };
  uint32_t chan_num() const {return _chan_num;}
  uint32_t count_mode() const {return _count_mode;}
  uint32_t quadrature_mode() const {return _quadrature_mode;}
  uint32_t input_num() const {return _input_num;}
  uint32_t input_rising() const {return _input_rising;}
  uint32_t ticks_per_sec() const {return _ticks_per_sec;}
  static uint32_t _sizeof()  {return 24;}
private:
  uint32_t	_chan_num;
  uint32_t	_count_mode;
  uint32_t	_quadrature_mode;
  uint32_t	_input_num;
  uint32_t	_input_rising;
  uint32_t	_ticks_per_sec;
};

/** @class DataV1

  
*/


class DataV1 {
public:
  enum {
    Version = 1 /**< XTC type version number */
  };
  enum {
    TypeId = Pds::TypeId::Id_EncoderData /**< XTC type ID value (from Pds::TypeId class) */
  };
  uint32_t timestamp() const {return _33mhz_timestamp;}
  uint32_t encoder_count() const {return _encoder_count;}
  static uint32_t _sizeof()  {return 8;}
private:
  uint32_t	_33mhz_timestamp;
  uint32_t	_encoder_count;
};

/** @class DataV2

  
*/


class DataV2 {
public:
  enum {
    Version = 2 /**< XTC type version number */
  };
  enum {
    TypeId = Pds::TypeId::Id_EncoderData /**< XTC type ID value (from Pds::TypeId class) */
  };
  enum {
    NEncoders = 3 /**< Number of encoders. */
  };
  uint32_t timestamp() const {return _33mhz_timestamp;}
  const uint32_t* encoder_count() const {return &_encoder_count[0];}
  static uint32_t _sizeof()  {return 4+(4*(NEncoders));}
  /** Method which returns the shape (dimensions) of the data returned by encoder_count() method. */
  std::vector<int> encoder_count_shape() const;
private:
  uint32_t	_33mhz_timestamp;
  uint32_t	_encoder_count[NEncoders];
};
} // namespace Encoder
} // namespace PsddlPds
#endif // PSDDLPDS_ENCODER_DDL_H
