
// *** Do not edit this file, it is auto-generated ***

#include "psddl_pdsdata/camera.ddl.h"

#include <iostream>
namespace PsddlPds {
namespace Camera {
FrameFexConfigV1::FrameFexConfigV1(Camera::FrameFexConfigV1::Forwarding arg__forwarding, uint32_t arg__forward_prescale, Camera::FrameFexConfigV1::Processing arg__processing, const Camera::FrameCoord& arg__roiBegin, const Camera::FrameCoord& arg__roiEnd, uint32_t arg__threshold, uint32_t arg__masked_pixel_count, const Camera::FrameCoord* arg__masked_pixel_coordinates)
    : _forwarding(arg__forwarding), _forward_prescale(arg__forward_prescale), _processing(arg__processing), _roiBegin(arg__roiBegin), _roiEnd(arg__roiEnd), _threshold(arg__threshold), _masked_pixel_count(arg__masked_pixel_count)
{
  if (arg__masked_pixel_coordinates and (this->number_of_masked_pixels())) {
    ptrdiff_t offset = 28;
    Camera::FrameCoord* data = reinterpret_cast<Camera::FrameCoord*>(((char*)this)+offset);
    std::copy(arg__masked_pixel_coordinates, arg__masked_pixel_coordinates+(this->number_of_masked_pixels()), data);
  }
}
std::ostream& operator<<(std::ostream& str, Camera::FrameFexConfigV1::Forwarding enval) {
  const char* val;
  switch (enval) {
  case Camera::FrameFexConfigV1::NoFrame:
    val = "NoFrame";
    break;
  case Camera::FrameFexConfigV1::FullFrame:
    val = "FullFrame";
    break;
  case Camera::FrameFexConfigV1::RegionOfInterest:
    val = "RegionOfInterest";
    break;
  default:
    return str << "Forwarding(" << int(enval) << ")";
  }
  return str << val;
}
std::ostream& operator<<(std::ostream& str, Camera::FrameFexConfigV1::Processing enval) {
  const char* val;
  switch (enval) {
  case Camera::FrameFexConfigV1::NoProcessing:
    val = "NoProcessing";
    break;
  case Camera::FrameFexConfigV1::GssFullFrame:
    val = "GssFullFrame";
    break;
  case Camera::FrameFexConfigV1::GssRegionOfInterest:
    val = "GssRegionOfInterest";
    break;
  case Camera::FrameFexConfigV1::GssThreshold:
    val = "GssThreshold";
    break;
  default:
    return str << "Processing(" << int(enval) << ")";
  }
  return str << val;
}
FrameV1::FrameV1(uint32_t arg__width, uint32_t arg__height, uint32_t arg__depth, uint32_t arg__offset, const uint8_t* arg__pixel_data)
    : _width(arg__width), _height(arg__height), _depth(arg__depth), _offset(arg__offset)
{
  if (arg__pixel_data and (this->_width*this->_height*((this->_depth+7)/8))) {
    ptrdiff_t offset = 16;
    uint8_t* data = reinterpret_cast<uint8_t*>(((char*)this)+offset);
    std::copy(arg__pixel_data, arg__pixel_data+(this->_width*this->_height*((this->_depth+7)/8)), data);
  }
}
ndarray<const uint8_t, 2>
FrameV1::data8() const {
  if (this->depth() > 8) return ndarray<const uint8_t, 2>(); return make_ndarray(_int_pixel_data().data(), height(), width());
}
ndarray<const uint16_t, 2>
FrameV1::data16() const {
  if (this->depth() <= 8) return ndarray<const uint16_t, 2>(); return make_ndarray((const uint16_t*)_int_pixel_data().data(), height(), width());
}
TwoDGaussianV1::TwoDGaussianV1()
{
}
TwoDGaussianV1::TwoDGaussianV1(uint64_t arg__integral, double arg__xmean, double arg__ymean, double arg__major_axis_width, double arg__minor_axis_width, double arg__major_axis_tilt)
    : _integral(arg__integral), _xmean(arg__xmean), _ymean(arg__ymean), _major_axis_width(arg__major_axis_width), _minor_axis_width(arg__minor_axis_width), _major_axis_tilt(arg__major_axis_tilt)
{
}
} // namespace Camera
} // namespace PsddlPds
