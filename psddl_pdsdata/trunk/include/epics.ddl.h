#ifndef PSDDLPDS_EPICS_DDL_H
#define PSDDLPDS_EPICS_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <cstddef>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
namespace PsddlPds {
namespace Epics {
  enum {
    iXtcVersion = 1 /**<  */
  };
  enum {
    iMaxPvNameLength = 64 /**< Maximum size of PV name string. */
  };
  enum {
    MAX_STRING_SIZE = 40 /**< Maximum length of strings in EPICS. */
  };
  enum {
    MAX_UNITS_SIZE = 8 /**< Maximum lenght of units strings. */
  };
  enum {
    MAX_ENUM_STRING_SIZE = 26 /**< Maximum length of strings specifying ENUMs. */
  };
  enum {
    MAX_ENUM_STATES = 16 /**< Maximum number of different ENUM constants. */
  };

  /** Enum specifying type of DBR structures. */
  enum DbrTypes {
    DBR_STRING = 0,
    DBR_SHORT = 1,
    DBR_FLOAT = 2,
    DBR_ENUM = 3,
    DBR_CHAR = 4,
    DBR_LONG = 5,
    DBR_DOUBLE = 6,
    DBR_STS_STRING = 7,
    DBR_STS_SHORT = 8,
    DBR_STS_FLOAT = 9,
    DBR_STS_ENUM = 10,
    DBR_STS_CHAR = 11,
    DBR_STS_LONG = 12,
    DBR_STS_DOUBLE = 13,
    DBR_TIME_STRING = 14,
    DBR_TIME_INT = 15,
    DBR_TIME_SHORT = 15,
    DBR_TIME_FLOAT = 16,
    DBR_TIME_ENUM = 17,
    DBR_TIME_CHAR = 18,
    DBR_TIME_LONG = 19,
    DBR_TIME_DOUBLE = 20,
    DBR_GR_STRING = 21,
    DBR_GR_SHORT = 22,
    DBR_GR_FLOAT = 23,
    DBR_GR_ENUM = 24,
    DBR_GR_CHAR = 25,
    DBR_GR_LONG = 26,
    DBR_GR_DOUBLE = 27,
    DBR_CTRL_STRING = 28,
    DBR_CTRL_SHORT = 29,
    DBR_CTRL_FLOAT = 30,
    DBR_CTRL_ENUM = 31,
    DBR_CTRL_CHAR = 32,
    DBR_CTRL_LONG = 33,
    DBR_CTRL_DOUBLE = 34,
  };

/** @class epicsTimeStamp

  EPICS timestamp type, includes seconds and nanoseconds.
           EPICS epoch corresponds to 1990-01-01 00:00:00Z.
*/


class epicsTimeStamp {
public:
  epicsTimeStamp()
  {
  }
  epicsTimeStamp(uint32_t arg__secPastEpoch, uint32_t arg__nsec)
    : _secPastEpoch(arg__secPastEpoch), _nsec(arg__nsec)
  {
  }
  /** Seconds since Jan 1, 1990 00:00 UTC */
  uint32_t sec() const { return _secPastEpoch; }
  /** Nanoseconds within second. */
  uint32_t nsec() const { return _nsec; }
  static uint32_t _sizeof()  { return 8; }
private:
  uint32_t	_secPastEpoch;	/**< Seconds since Jan 1, 1990 00:00 UTC */
  uint32_t	_nsec;	/**< Nanoseconds within second. */
};

/** @class dbr_time_string

  
*/


class dbr_time_string {
public:
  enum { DBR_TYPE_ID = DBR_TIME_STRING };
  dbr_time_string(int16_t status, int16_t severity, const Epics::epicsTimeStamp& stamp)
    : _status(status), _severity(severity), _stamp(stamp)
  {
  }
  int16_t status() const { return _status; }
  int16_t severity() const { return _severity; }
  const Epics::epicsTimeStamp& stamp() const { return _stamp; }
  static uint32_t _sizeof()  { return 4+(Epics::epicsTimeStamp::_sizeof()); }
private:
  int16_t	_status;
  int16_t	_severity;
  Epics::epicsTimeStamp	_stamp;
};

/** @class dbr_time_short

  
*/


class dbr_time_short {
public:
  enum { DBR_TYPE_ID = DBR_TIME_SHORT };
  dbr_time_short(int16_t status, int16_t severity, const Epics::epicsTimeStamp& stamp)
    : _status(status), _severity(severity), _stamp(stamp), RISC_pad(0)
  {
  }
  int16_t status() const { return _status; }
  int16_t severity() const { return _severity; }
  const Epics::epicsTimeStamp& stamp() const { return _stamp; }
  static uint32_t _sizeof()  { return (4+(Epics::epicsTimeStamp::_sizeof()))+2; }
private:
  int16_t	_status;
  int16_t	_severity;
  Epics::epicsTimeStamp	_stamp;
  int16_t	RISC_pad;
};

/** @class dbr_time_float

  
*/


class dbr_time_float {
public:
  enum { DBR_TYPE_ID = DBR_TIME_FLOAT };
  dbr_time_float(int16_t status, int16_t severity, const Epics::epicsTimeStamp& stamp)
    : _status(status), _severity(severity), _stamp(stamp)
  {
  }
  int16_t status() const { return _status; }
  int16_t severity() const { return _severity; }
  const Epics::epicsTimeStamp& stamp() const { return _stamp; }
  static uint32_t _sizeof()  { return 4+(Epics::epicsTimeStamp::_sizeof()); }
private:
  int16_t	_status;
  int16_t	_severity;
  Epics::epicsTimeStamp	_stamp;
};

/** @class dbr_time_enum

  
*/


class dbr_time_enum {
public:
  enum { DBR_TYPE_ID = DBR_TIME_ENUM };
  dbr_time_enum(int16_t status, int16_t severity, const Epics::epicsTimeStamp& stamp)
    : _status(status), _severity(severity), _stamp(stamp), RISC_pad(0)
  {
  }
  int16_t status() const { return _status; }
  int16_t severity() const { return _severity; }
  const Epics::epicsTimeStamp& stamp() const { return _stamp; }
  static uint32_t _sizeof()  { return (4+(Epics::epicsTimeStamp::_sizeof()))+2; }
private:
  int16_t	_status;
  int16_t	_severity;
  Epics::epicsTimeStamp	_stamp;
  int16_t	RISC_pad;
};

/** @class dbr_time_char

  
*/


class dbr_time_char {
public:
  enum { DBR_TYPE_ID = DBR_TIME_CHAR };
  dbr_time_char(int16_t status, int16_t severity, const Epics::epicsTimeStamp& stamp)
    : _status(status), _severity(severity), _stamp(stamp), RISC_pad1(0)
  {
  }
  int16_t status() const { return _status; }
  int16_t severity() const { return _severity; }
  const Epics::epicsTimeStamp& stamp() const { return _stamp; }
  static uint32_t _sizeof()  { return ((4+(Epics::epicsTimeStamp::_sizeof()))+2)+1; }
private:
  int16_t	_status;
  int16_t	_severity;
  Epics::epicsTimeStamp	_stamp;
  int16_t	RISC_pad0;
  uint8_t	RISC_pad1;
};

/** @class dbr_time_long

  
*/


class dbr_time_long {
public:
  enum { DBR_TYPE_ID = DBR_TIME_LONG };
  dbr_time_long(int16_t status, int16_t severity, const Epics::epicsTimeStamp& stamp)
    : _status(status), _severity(severity), _stamp(stamp)
  {
  }
  int16_t status() const { return _status; }
  int16_t severity() const { return _severity; }
  const Epics::epicsTimeStamp& stamp() const { return _stamp; }
  static uint32_t _sizeof()  { return 4+(Epics::epicsTimeStamp::_sizeof()); }
private:
  int16_t	_status;
  int16_t	_severity;
  Epics::epicsTimeStamp	_stamp;
};

/** @class dbr_time_double

  
*/


class dbr_time_double {
public:
  enum { DBR_TYPE_ID = DBR_TIME_DOUBLE };
  dbr_time_double(int16_t status, int16_t severity, const Epics::epicsTimeStamp& stamp)
    : _status(status), _severity(severity), _stamp(stamp), RISC_pad(0)
  {
  }
  int16_t status() const { return _status; }
  int16_t severity() const { return _severity; }
  const Epics::epicsTimeStamp& stamp() const { return _stamp; }
  static uint32_t _sizeof()  { return (4+(Epics::epicsTimeStamp::_sizeof()))+4; }
private:
  int16_t	_status;
  int16_t	_severity;
  Epics::epicsTimeStamp	_stamp;
  int32_t	RISC_pad;
};

/** @class dbr_sts_string

  
*/


class dbr_sts_string {
public:
  enum { DBR_TYPE_ID = DBR_CTRL_STRING };
  dbr_sts_string(int16_t status, int16_t severity)
    : _status(status), _severity(severity)
  {
  }
  int16_t status() const { return _status; }
  int16_t severity() const { return _severity; }
  static uint32_t _sizeof()  { return 4; }
private:
  int16_t	_status;
  int16_t	_severity;
};

/** @class dbr_ctrl_short

  
*/


class dbr_ctrl_short {
public:
  enum { DBR_TYPE_ID = DBR_CTRL_SHORT };
  dbr_ctrl_short(int16_t status, int16_t severity, const char* units, int16_t upper_disp_limit, int16_t lower_disp_limit, int16_t upper_alarm_limit, int16_t upper_warning_limit, int16_t lower_warning_limit, int16_t lower_alarm_limit, int16_t upper_ctrl_limit, int16_t lower_ctrl_limit)
    : _status(status), _severity(severity), _upper_disp_limit(upper_disp_limit), _lower_disp_limit(lower_disp_limit), _upper_alarm_limit(upper_alarm_limit), _upper_warning_limit(upper_warning_limit), _lower_warning_limit(lower_warning_limit), _lower_alarm_limit(lower_alarm_limit), _upper_ctrl_limit(upper_ctrl_limit), _lower_ctrl_limit(lower_ctrl_limit)
  {
    std::copy(units, units+(8), _units);
  }
  int16_t status() const { return _status; }
  int16_t severity() const { return _severity; }
  const char* units() const { return _units; }
  int16_t upper_disp_limit() const { return _upper_disp_limit; }
  int16_t lower_disp_limit() const { return _lower_disp_limit; }
  int16_t upper_alarm_limit() const { return _upper_alarm_limit; }
  int16_t upper_warning_limit() const { return _upper_warning_limit; }
  int16_t lower_warning_limit() const { return _lower_warning_limit; }
  int16_t lower_alarm_limit() const { return _lower_alarm_limit; }
  int16_t upper_ctrl_limit() const { return _upper_ctrl_limit; }
  int16_t lower_ctrl_limit() const { return _lower_ctrl_limit; }
  static uint32_t _sizeof()  { return ((((((((4+(1*(MAX_UNITS_SIZE)))+2)+2)+2)+2)+2)+2)+2)+2; }
  /** Method which returns the shape (dimensions) of the data returned by units() method. */
  std::vector<int> units_shape() const;
private:
  int16_t	_status;
  int16_t	_severity;
  char	_units[MAX_UNITS_SIZE];
  int16_t	_upper_disp_limit;
  int16_t	_lower_disp_limit;
  int16_t	_upper_alarm_limit;
  int16_t	_upper_warning_limit;
  int16_t	_lower_warning_limit;
  int16_t	_lower_alarm_limit;
  int16_t	_upper_ctrl_limit;
  int16_t	_lower_ctrl_limit;
};

/** @class dbr_ctrl_float

  
*/


class dbr_ctrl_float {
public:
  enum { DBR_TYPE_ID = DBR_CTRL_FLOAT };
  dbr_ctrl_float(int16_t status, int16_t severity, int16_t precision, const char* units, float upper_disp_limit, float lower_disp_limit, float upper_alarm_limit, float upper_warning_limit, float lower_warning_limit, float lower_alarm_limit, float upper_ctrl_limit, float lower_ctrl_limit)
    : _status(status), _severity(severity), _precision(precision), RISC_pad(0), _upper_disp_limit(upper_disp_limit), _lower_disp_limit(lower_disp_limit), _upper_alarm_limit(upper_alarm_limit), _upper_warning_limit(upper_warning_limit), _lower_warning_limit(lower_warning_limit), _lower_alarm_limit(lower_alarm_limit), _upper_ctrl_limit(upper_ctrl_limit), _lower_ctrl_limit(lower_ctrl_limit)
  {
    std::copy(units, units+(8), _units);
  }
  int16_t status() const { return _status; }
  int16_t severity() const { return _severity; }
  int16_t precision() const { return _precision; }
  const char* units() const { return _units; }
  float upper_disp_limit() const { return _upper_disp_limit; }
  float lower_disp_limit() const { return _lower_disp_limit; }
  float upper_alarm_limit() const { return _upper_alarm_limit; }
  float upper_warning_limit() const { return _upper_warning_limit; }
  float lower_warning_limit() const { return _lower_warning_limit; }
  float lower_alarm_limit() const { return _lower_alarm_limit; }
  float upper_ctrl_limit() const { return _upper_ctrl_limit; }
  float lower_ctrl_limit() const { return _lower_ctrl_limit; }
  static uint32_t _sizeof()  { return ((((((((8+(1*(MAX_UNITS_SIZE)))+4)+4)+4)+4)+4)+4)+4)+4; }
  /** Method which returns the shape (dimensions) of the data returned by units() method. */
  std::vector<int> units_shape() const;
private:
  int16_t	_status;
  int16_t	_severity;
  int16_t	_precision;
  int16_t	RISC_pad;
  char	_units[MAX_UNITS_SIZE];
  float	_upper_disp_limit;
  float	_lower_disp_limit;
  float	_upper_alarm_limit;
  float	_upper_warning_limit;
  float	_lower_warning_limit;
  float	_lower_alarm_limit;
  float	_upper_ctrl_limit;
  float	_lower_ctrl_limit;
};

/** @class dbr_ctrl_enum

  
*/


class dbr_ctrl_enum {
public:
  enum { DBR_TYPE_ID = DBR_CTRL_ENUM };
  dbr_ctrl_enum(int16_t status, int16_t severity, int16_t no_str, const char* strings)
    : _status(status), _severity(severity), _no_str(no_str)
  {
    std::copy(strings, strings+(416), _strs[0]);
  }
  int16_t status() const { return _status; }
  int16_t severity() const { return _severity; }
  int16_t no_str() const { return _no_str; }
  const char* strings(uint32_t i0) const { return _strs[i0]; }
  static uint32_t _sizeof()  { return 6+(1*(MAX_ENUM_STATES)*(MAX_ENUM_STRING_SIZE)); }
  /** Method which returns the shape (dimensions) of the data returned by strings() method. */
  std::vector<int> strings_shape() const;
private:
  int16_t	_status;
  int16_t	_severity;
  int16_t	_no_str;
  char	_strs[MAX_ENUM_STATES][MAX_ENUM_STRING_SIZE];
};

/** @class dbr_ctrl_char

  
*/


class dbr_ctrl_char {
public:
  enum { DBR_TYPE_ID = DBR_CTRL_CHAR };
  dbr_ctrl_char(int16_t status, int16_t severity, const char* units, uint8_t upper_disp_limit, uint8_t lower_disp_limit, uint8_t upper_alarm_limit, uint8_t upper_warning_limit, uint8_t lower_warning_limit, uint8_t lower_alarm_limit, uint8_t upper_ctrl_limit, uint8_t lower_ctrl_limit)
    : _status(status), _severity(severity), _upper_disp_limit(upper_disp_limit), _lower_disp_limit(lower_disp_limit), _upper_alarm_limit(upper_alarm_limit), _upper_warning_limit(upper_warning_limit), _lower_warning_limit(lower_warning_limit), _lower_alarm_limit(lower_alarm_limit), _upper_ctrl_limit(upper_ctrl_limit), _lower_ctrl_limit(lower_ctrl_limit), RISC_pad(0)
  {
    std::copy(units, units+(8), _units);
  }
  int16_t status() const { return _status; }
  int16_t severity() const { return _severity; }
  const char* units() const { return _units; }
  uint8_t upper_disp_limit() const { return _upper_disp_limit; }
  uint8_t lower_disp_limit() const { return _lower_disp_limit; }
  uint8_t upper_alarm_limit() const { return _upper_alarm_limit; }
  uint8_t upper_warning_limit() const { return _upper_warning_limit; }
  uint8_t lower_warning_limit() const { return _lower_warning_limit; }
  uint8_t lower_alarm_limit() const { return _lower_alarm_limit; }
  uint8_t upper_ctrl_limit() const { return _upper_ctrl_limit; }
  uint8_t lower_ctrl_limit() const { return _lower_ctrl_limit; }
  static uint32_t _sizeof()  { return (((((((((4+(1*(MAX_UNITS_SIZE)))+1)+1)+1)+1)+1)+1)+1)+1)+1; }
  /** Method which returns the shape (dimensions) of the data returned by units() method. */
  std::vector<int> units_shape() const;
private:
  int16_t	_status;
  int16_t	_severity;
  char	_units[MAX_UNITS_SIZE];
  uint8_t	_upper_disp_limit;
  uint8_t	_lower_disp_limit;
  uint8_t	_upper_alarm_limit;
  uint8_t	_upper_warning_limit;
  uint8_t	_lower_warning_limit;
  uint8_t	_lower_alarm_limit;
  uint8_t	_upper_ctrl_limit;
  uint8_t	_lower_ctrl_limit;
  uint8_t	RISC_pad;
};

/** @class dbr_ctrl_long

  
*/


class dbr_ctrl_long {
public:
  enum { DBR_TYPE_ID = DBR_CTRL_LONG };
  dbr_ctrl_long(int16_t status, int16_t severity, const char* units, int32_t upper_disp_limit, int32_t lower_disp_limit, int32_t upper_alarm_limit, int32_t upper_warning_limit, int32_t lower_warning_limit, int32_t lower_alarm_limit, int32_t upper_ctrl_limit, int32_t lower_ctrl_limit)
    : _status(status), _severity(severity), _upper_disp_limit(upper_disp_limit), _lower_disp_limit(lower_disp_limit), _upper_alarm_limit(upper_alarm_limit), _upper_warning_limit(upper_warning_limit), _lower_warning_limit(lower_warning_limit), _lower_alarm_limit(lower_alarm_limit), _upper_ctrl_limit(upper_ctrl_limit), _lower_ctrl_limit(lower_ctrl_limit)
  {
    std::copy(units, units+(8), _units);
  }
  int16_t status() const { return _status; }
  int16_t severity() const { return _severity; }
  const char* units() const { return _units; }
  int32_t upper_disp_limit() const { return _upper_disp_limit; }
  int32_t lower_disp_limit() const { return _lower_disp_limit; }
  int32_t upper_alarm_limit() const { return _upper_alarm_limit; }
  int32_t upper_warning_limit() const { return _upper_warning_limit; }
  int32_t lower_warning_limit() const { return _lower_warning_limit; }
  int32_t lower_alarm_limit() const { return _lower_alarm_limit; }
  int32_t upper_ctrl_limit() const { return _upper_ctrl_limit; }
  int32_t lower_ctrl_limit() const { return _lower_ctrl_limit; }
  static uint32_t _sizeof()  { return ((((((((4+(1*(MAX_UNITS_SIZE)))+4)+4)+4)+4)+4)+4)+4)+4; }
  /** Method which returns the shape (dimensions) of the data returned by units() method. */
  std::vector<int> units_shape() const;
private:
  int16_t	_status;
  int16_t	_severity;
  char	_units[MAX_UNITS_SIZE];
  int32_t	_upper_disp_limit;
  int32_t	_lower_disp_limit;
  int32_t	_upper_alarm_limit;
  int32_t	_upper_warning_limit;
  int32_t	_lower_warning_limit;
  int32_t	_lower_alarm_limit;
  int32_t	_upper_ctrl_limit;
  int32_t	_lower_ctrl_limit;
};

/** @class dbr_ctrl_double

  
*/


class dbr_ctrl_double {
public:
  enum { DBR_TYPE_ID = DBR_CTRL_DOUBLE };
  dbr_ctrl_double(int16_t status, int16_t severity, int16_t precision, const char* units, double upper_disp_limit, double lower_disp_limit, double upper_alarm_limit, double upper_warning_limit, double lower_warning_limit, double lower_alarm_limit, double upper_ctrl_limit, double lower_ctrl_limit)
    : _status(status), _severity(severity), _precision(precision), RISC_pad0(0), _upper_disp_limit(upper_disp_limit), _lower_disp_limit(lower_disp_limit), _upper_alarm_limit(upper_alarm_limit), _upper_warning_limit(upper_warning_limit), _lower_warning_limit(lower_warning_limit), _lower_alarm_limit(lower_alarm_limit), _upper_ctrl_limit(upper_ctrl_limit), _lower_ctrl_limit(lower_ctrl_limit)
  {
    std::copy(units, units+(8), _units);
  }
  int16_t status() const { return _status; }
  int16_t severity() const { return _severity; }
  int16_t precision() const { return _precision; }
  const char* units() const { return _units; }
  double upper_disp_limit() const { return _upper_disp_limit; }
  double lower_disp_limit() const { return _lower_disp_limit; }
  double upper_alarm_limit() const { return _upper_alarm_limit; }
  double upper_warning_limit() const { return _upper_warning_limit; }
  double lower_warning_limit() const { return _lower_warning_limit; }
  double lower_alarm_limit() const { return _lower_alarm_limit; }
  double upper_ctrl_limit() const { return _upper_ctrl_limit; }
  double lower_ctrl_limit() const { return _lower_ctrl_limit; }
  static uint32_t _sizeof()  { return ((((((((8+(1*(MAX_UNITS_SIZE)))+8)+8)+8)+8)+8)+8)+8)+8; }
  /** Method which returns the shape (dimensions) of the data returned by units() method. */
  std::vector<int> units_shape() const;
private:
  int16_t	_status;
  int16_t	_severity;
  int16_t	_precision;
  int16_t	RISC_pad0;
  char	_units[MAX_UNITS_SIZE];
  double	_upper_disp_limit;
  double	_lower_disp_limit;
  double	_upper_alarm_limit;
  double	_upper_warning_limit;
  double	_lower_warning_limit;
  double	_lower_alarm_limit;
  double	_upper_ctrl_limit;
  double	_lower_ctrl_limit;
};

/** @class EpicsPvHeader

  Base class for EPICS data types stored in XTC files.
*/


class EpicsPvHeader {
public:
  /** PV ID number assigned by DAQ. */
  int16_t pvId() const { return _iPvId; }
  /** DBR structure type. */
  int16_t dbrType() const { return _iDbrType; }
  /** Number of elements in EPICS DBR structure */
  int16_t numElements() const { return _iNumElements; }
  /** Dumps the content of PV to standard output. */
  void print() const;
  /** Returns 1 if PV is one of CTRL types, 0 otherwise. */
  uint8_t isCtrl() const;
  /** Returns 1 if PV is one of TIME types, 0 otherwise. */
  uint8_t isTime() const;
  /** Returns status value for the PV. */
  uint16_t status() const;
  /** Returns severity value for the PV. */
  uint16_t severity() const;
  static uint32_t _sizeof()  { return 6; }
private:
  int16_t	_iPvId;	/**< PV ID number assigned by DAQ. */
  int16_t	_iDbrType;	/**< DBR structure type. */
  int16_t	_iNumElements;	/**< Number of elements in EPICS DBR structure */
};

/** @class EpicsPvCtrlHeader

  Base class for all CTRL-type PV values.
*/


class EpicsPvCtrlHeader: public EpicsPvHeader {
public:
  /** PV name. */
  const char* pvName() const { return _sPvName; }
  static uint32_t _sizeof()  { return (Epics::EpicsPvHeader::_sizeof())+(1*(iMaxPvNameLength)); }
  /** Method which returns the shape (dimensions) of the data returned by pvName() method. */
  std::vector<int> pvName_shape() const;
private:
  char	_sPvName[iMaxPvNameLength];	/**< PV name. */
};

/** @class EpicsPvTimeHeader

  Base class for all TIME-type PV values.
*/


class EpicsPvTimeHeader: public EpicsPvHeader {
public:
  /** EPICS timestamp value. */
  Epics::epicsTimeStamp stamp() const;
  static uint32_t _sizeof()  { return Epics::EpicsPvHeader::_sizeof(); }
};

/** @class EpicsPvCtrlString

  
*/


class EpicsPvCtrlString: public EpicsPvCtrlHeader {
public:
  const Epics::dbr_sts_string& dbr() const { return _dbr; }
  const char* data(uint32_t i0) const { typedef char atype[ MAX_STRING_SIZE];
  ptrdiff_t offset=74;
  const atype* pchar = (const atype*)(((const char*)this)+offset);
  return pchar[i0]; }
  const char* value(uint32_t i) const;
  uint32_t _sizeof() const { return ((Epics::EpicsPvCtrlHeader::_sizeof())+(Epics::dbr_sts_string::_sizeof()))+(1*(this->numElements())*( MAX_STRING_SIZE)); }
  /** Method which returns the shape (dimensions) of the data returned by data() method. */
  std::vector<int> data_shape() const;
private:
  Epics::dbr_sts_string	_dbr;
  //char	_data[this->numElements()][ MAX_STRING_SIZE];
};

/** @class EpicsPvCtrlShort

  
*/


class EpicsPvCtrlShort: public EpicsPvCtrlHeader {
public:
  const Epics::dbr_ctrl_short& dbr() const { return _dbr; }
  ndarray<int16_t, 1> data() const { ptrdiff_t offset=98;
  int16_t* data = (int16_t*)(((const char*)this)+offset);
  return make_ndarray(data, this->numElements()); }
  int16_t value(uint32_t i) const;
  uint32_t _sizeof() const { return ((Epics::EpicsPvCtrlHeader::_sizeof())+(Epics::dbr_ctrl_short::_sizeof()))+(2*(this->numElements())); }
private:
  Epics::dbr_ctrl_short	_dbr;
  //int16_t	_data[this->numElements()];
};

/** @class EpicsPvCtrlFloat

  
*/


class EpicsPvCtrlFloat: public EpicsPvCtrlHeader {
public:
  const Epics::dbr_ctrl_float& dbr() const { return _dbr; }
  ndarray<float, 1> data() const { ptrdiff_t offset=120;
  float* data = (float*)(((const char*)this)+offset);
  return make_ndarray(data, this->numElements()); }
  float value(uint32_t i) const;
  uint32_t _sizeof() const { return (((Epics::EpicsPvCtrlHeader::_sizeof())+2)+(Epics::dbr_ctrl_float::_sizeof()))+(4*(this->numElements())); }
private:
  int16_t	pad0;
  Epics::dbr_ctrl_float	_dbr;
  //float	_data[this->numElements()];
};

/** @class EpicsPvCtrlEnum

  
*/


class EpicsPvCtrlEnum: public EpicsPvCtrlHeader {
public:
  const Epics::dbr_ctrl_enum& dbr() const { return _dbr; }
  ndarray<uint16_t, 1> data() const { ptrdiff_t offset=492;
  uint16_t* data = (uint16_t*)(((const char*)this)+offset);
  return make_ndarray(data, this->numElements()); }
  uint16_t value(uint32_t i) const;
  uint32_t _sizeof() const { return ((Epics::EpicsPvCtrlHeader::_sizeof())+(Epics::dbr_ctrl_enum::_sizeof()))+(2*(this->numElements())); }
private:
  Epics::dbr_ctrl_enum	_dbr;
  //uint16_t	_data[this->numElements()];
};

/** @class EpicsPvCtrlChar

  
*/


class EpicsPvCtrlChar: public EpicsPvCtrlHeader {
public:
  const Epics::dbr_ctrl_char& dbr() const { return _dbr; }
  ndarray<uint8_t, 1> data() const { ptrdiff_t offset=91;
  uint8_t* data = (uint8_t*)(((const char*)this)+offset);
  return make_ndarray(data, this->numElements()); }
  uint8_t value(uint32_t i) const;
  uint32_t _sizeof() const { return ((Epics::EpicsPvCtrlHeader::_sizeof())+(Epics::dbr_ctrl_char::_sizeof()))+(1*(this->numElements())); }
private:
  Epics::dbr_ctrl_char	_dbr;
  //uint8_t	_data[this->numElements()];
};

/** @class EpicsPvCtrlLong

  
*/


class EpicsPvCtrlLong: public EpicsPvCtrlHeader {
public:
  const Epics::dbr_ctrl_long& dbr() const { return _dbr; }
  ndarray<int32_t, 1> data() const { ptrdiff_t offset=116;
  int32_t* data = (int32_t*)(((const char*)this)+offset);
  return make_ndarray(data, this->numElements()); }
  int32_t value(uint32_t i) const;
  uint32_t _sizeof() const { return (((Epics::EpicsPvCtrlHeader::_sizeof())+2)+(Epics::dbr_ctrl_long::_sizeof()))+(4*(this->numElements())); }
private:
  int16_t	pad0;
  Epics::dbr_ctrl_long	_dbr;
  //int32_t	_data[this->numElements()];
};

/** @class EpicsPvCtrlDouble

  
*/


class EpicsPvCtrlDouble: public EpicsPvCtrlHeader {
public:
  const Epics::dbr_ctrl_double& dbr() const { return _dbr; }
  ndarray<double, 1> data() const { ptrdiff_t offset=152;
  double* data = (double*)(((const char*)this)+offset);
  return make_ndarray(data, this->numElements()); }
  double value(uint32_t i) const;
  uint32_t _sizeof() const { return (((Epics::EpicsPvCtrlHeader::_sizeof())+2)+(Epics::dbr_ctrl_double::_sizeof()))+(8*(this->numElements())); }
private:
  int16_t	pad0;
  Epics::dbr_ctrl_double	_dbr;
  //double	_data[this->numElements()];
};

/** @class EpicsPvTimeString

  
*/


class EpicsPvTimeString: public EpicsPvTimeHeader {
public:
  const Epics::dbr_time_string& dbr() const { return _dbr; }
  const char* data(uint32_t i0) const { typedef char atype[ MAX_STRING_SIZE];
  ptrdiff_t offset=20;
  const atype* pchar = (const atype*)(((const char*)this)+offset);
  return pchar[i0]; }
  const char* value(uint32_t i) const;
  uint32_t _sizeof() const { return (((Epics::EpicsPvTimeHeader::_sizeof())+2)+(Epics::dbr_time_string::_sizeof()))+(1*(this->numElements())*( MAX_STRING_SIZE)); }
  /** Method which returns the shape (dimensions) of the data returned by data() method. */
  std::vector<int> data_shape() const;
private:
  int16_t	pad0;
  Epics::dbr_time_string	_dbr;
  //char	_data[this->numElements()][ MAX_STRING_SIZE];
};

/** @class EpicsPvTimeShort

  
*/


class EpicsPvTimeShort: public EpicsPvTimeHeader {
public:
  const Epics::dbr_time_short& dbr() const { return _dbr; }
  ndarray<int16_t, 1> data() const { ptrdiff_t offset=22;
  int16_t* data = (int16_t*)(((const char*)this)+offset);
  return make_ndarray(data, this->numElements()); }
  int16_t value(uint32_t i) const;
  uint32_t _sizeof() const { return (((Epics::EpicsPvTimeHeader::_sizeof())+2)+(Epics::dbr_time_short::_sizeof()))+(2*(this->numElements())); }
private:
  int16_t	pad0;
  Epics::dbr_time_short	_dbr;
  //int16_t	_data[this->numElements()];
};

/** @class EpicsPvTimeFloat

  
*/


class EpicsPvTimeFloat: public EpicsPvTimeHeader {
public:
  const Epics::dbr_time_float& dbr() const { return _dbr; }
  ndarray<float, 1> data() const { ptrdiff_t offset=20;
  float* data = (float*)(((const char*)this)+offset);
  return make_ndarray(data, this->numElements()); }
  float value(uint32_t i) const;
  uint32_t _sizeof() const { return (((Epics::EpicsPvTimeHeader::_sizeof())+2)+(Epics::dbr_time_float::_sizeof()))+(4*(this->numElements())); }
private:
  int16_t	pad0;
  Epics::dbr_time_float	_dbr;
  //float	_data[this->numElements()];
};

/** @class EpicsPvTimeEnum

  
*/


class EpicsPvTimeEnum: public EpicsPvTimeHeader {
public:
  const Epics::dbr_time_enum& dbr() const { return _dbr; }
  ndarray<uint16_t, 1> data() const { ptrdiff_t offset=22;
  uint16_t* data = (uint16_t*)(((const char*)this)+offset);
  return make_ndarray(data, this->numElements()); }
  uint16_t value(uint32_t i) const;
  uint32_t _sizeof() const { return (((Epics::EpicsPvTimeHeader::_sizeof())+2)+(Epics::dbr_time_enum::_sizeof()))+(2*(this->numElements())); }
private:
  int16_t	pad0;
  Epics::dbr_time_enum	_dbr;
  //uint16_t	_data[this->numElements()];
};

/** @class EpicsPvTimeChar

  
*/


class EpicsPvTimeChar: public EpicsPvTimeHeader {
public:
  const Epics::dbr_time_char& dbr() const { return _dbr; }
  ndarray<uint8_t, 1> data() const { ptrdiff_t offset=23;
  uint8_t* data = (uint8_t*)(((const char*)this)+offset);
  return make_ndarray(data, this->numElements()); }
  uint8_t value(uint32_t i) const;
  uint32_t _sizeof() const { return (((Epics::EpicsPvTimeHeader::_sizeof())+2)+(Epics::dbr_time_char::_sizeof()))+(1*(this->numElements())); }
private:
  int16_t	pad0;
  Epics::dbr_time_char	_dbr;
  //uint8_t	_data[this->numElements()];
};

/** @class EpicsPvTimeLong

  
*/


class EpicsPvTimeLong: public EpicsPvTimeHeader {
public:
  const Epics::dbr_time_long& dbr() const { return _dbr; }
  ndarray<int32_t, 1> data() const { ptrdiff_t offset=20;
  int32_t* data = (int32_t*)(((const char*)this)+offset);
  return make_ndarray(data, this->numElements()); }
  int32_t value(uint32_t i) const;
  uint32_t _sizeof() const { return (((Epics::EpicsPvTimeHeader::_sizeof())+2)+(Epics::dbr_time_long::_sizeof()))+(4*(this->numElements())); }
private:
  int16_t	pad0;
  Epics::dbr_time_long	_dbr;
  //int32_t	_data[this->numElements()];
};

/** @class EpicsPvTimeDouble

  
*/


class EpicsPvTimeDouble: public EpicsPvTimeHeader {
public:
  const Epics::dbr_time_double& dbr() const { return _dbr; }
  ndarray<double, 1> data() const { ptrdiff_t offset=24;
  double* data = (double*)(((const char*)this)+offset);
  return make_ndarray(data, this->numElements()); }
  double value(uint32_t i) const;
  uint32_t _sizeof() const { return (((Epics::EpicsPvTimeHeader::_sizeof())+2)+(Epics::dbr_time_double::_sizeof()))+(8*(this->numElements())); }
private:
  int16_t	pad0;
  Epics::dbr_time_double	_dbr;
  //double	_data[this->numElements()];
};

/** @class PvConfigV1

  
*/

#pragma pack(push,4)

class PvConfigV1 {
public:
  enum { iMaxPvDescLength = 64 };
  int16_t pvId() const { return iPvId; }
  const char* description() const { return sPvDesc; }
  float interval() const { return fInterval; }
  static uint32_t _sizeof()  { return ((2+(1*(iMaxPvDescLength)))+2)+4; }
private:
  int16_t	iPvId;
  char	sPvDesc[iMaxPvDescLength];
  int16_t	_pad0;
  float	fInterval;
};
#pragma pack(pop)

/** @class ConfigV1

  
*/

#pragma pack(push,4)

class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_EpicsConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  int32_t numPv() const { return _iNumPv; }
  const Epics::PvConfigV1& pvControls(uint32_t i0) const { ptrdiff_t offset=4;
  const Epics::PvConfigV1* memptr = (const Epics::PvConfigV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof();
  return *(const Epics::PvConfigV1*)((const char*)memptr + (i0)*memsize); }
  uint32_t _sizeof() const { return 4+(Epics::PvConfigV1::_sizeof()*(this->_iNumPv)); }
  /** Method which returns the shape (dimensions) of the data returned by pvControls() method. */
  std::vector<int> pvControls_shape() const;
private:
  int32_t	_iNumPv;
  //Epics::PvConfigV1	_pvControls[this->_iNumPv];
};
#pragma pack(pop)
} // namespace Epics
} // namespace PsddlPds
#endif // PSDDLPDS_EPICS_DDL_H
