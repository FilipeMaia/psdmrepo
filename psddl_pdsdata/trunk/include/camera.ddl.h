#ifndef PSDDLPDS_CAMERA_DDL_H
#define PSDDLPDS_CAMERA_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <cstddef>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
namespace PsddlPds {
namespace Camera {

/** @class FrameCoord

  Class representing the coordinates of pixels iside the camera frame.
*/


class FrameCoord {
public:
  FrameCoord()
  {
  }
  FrameCoord(uint16_t arg__column, uint16_t arg__row)
    : _column(arg__column), _row(arg__row)
  {
  }
  /** Column index (x value). */
  uint16_t column() const { return _column; }
  /** Row index (y value). */
  uint16_t row() const { return _row; }
  static uint32_t _sizeof()  { return 4; }
private:
  uint16_t	_column;	/**< Column index (x value). */
  uint16_t	_row;	/**< Row index (y value). */
};

/** @class FrameFccdConfigV1

  This class was never defined/implemented.
*/


class FrameFccdConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_FrameFccdConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  static uint32_t _sizeof()  { return 0; }
};

/** @class FrameFexConfigV1

  Class containing configuration data for online frame feature extraction process.
*/


class FrameFexConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_FrameFexConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum Forwarding {
    NoFrame,
    FullFrame,
    RegionOfInterest,
  };
  enum Processing {
    NoProcessing,
    GssFullFrame,
    GssRegionOfInterest,
    GssThreshold,
  };
  /** Forwarding policy for frame data. */
  Camera::FrameFexConfigV1::Forwarding forwarding() const { return Forwarding(this->_forwarding); }
  /** Prescale of events with forwarded frames */
  uint32_t forward_prescale() const { return _forward_prescale; }
  /** Algorithm to apply to frames to produce processed output. */
  Camera::FrameFexConfigV1::Processing processing() const { return Processing(this->_processing); }
  /** Coordinate of start of rectangular region of interest (inclusive). */
  const Camera::FrameCoord& roiBegin() const { return _roiBegin; }
  /** Coordinate of finish of rectangular region of interest (exclusive). */
  const Camera::FrameCoord& roiEnd() const { return _roiEnd; }
  /** Pixel data threshold value to apply in processing. */
  uint32_t threshold() const { return _threshold; }
  /** Count of masked pixels to exclude from processing. */
  uint32_t number_of_masked_pixels() const { return _masked_pixel_count; }
  /** Location of masked pixel coordinates. */
  ndarray<Camera::FrameCoord, 1> masked_pixel_coordinates() const { ptrdiff_t offset=28;
  Camera::FrameCoord* data = (Camera::FrameCoord*)(((const char*)this)+offset);
  return make_ndarray(data, this->_masked_pixel_count); }
  uint32_t _sizeof() const { return ((((((((12+(Camera::FrameCoord::_sizeof()))+(Camera::FrameCoord::_sizeof()))+4)+4)+(Camera::FrameCoord::_sizeof()*(this->_masked_pixel_count)))+4)-1)/4)*4; }
private:
  uint32_t	_forwarding;	/**< frame forwarding policy */
  uint32_t	_forward_prescale;	/**< Prescale of events with forwarded frames */
  uint32_t	_processing;	/**< algorithm to apply to frames to produce processed output */
  Camera::FrameCoord	_roiBegin;	/**< Coordinate of start of rectangular region of interest (inclusive). */
  Camera::FrameCoord	_roiEnd;	/**< Coordinate of finish of rectangular region of interest (exclusive). */
  uint32_t	_threshold;	/**< Pixel data threshold value to apply in processing. */
  uint32_t	_masked_pixel_count;	/**< Count of masked pixels to exclude from processing. */
  //Camera::FrameCoord	_masked_pixel_coordinates[this->_masked_pixel_count];
};

/** @class FrameV1

  
*/


class FrameV1 {
public:
  enum { TypeId = Pds::TypeId::Id_Frame /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  /** Number of pixels in a row. */
  uint32_t width() const { return _width; }
  /** Number of pixels in a column. */
  uint32_t height() const { return _height; }
  /** Number of bits per pixel. */
  uint32_t depth() const { return _depth; }
  /** Fixed offset/pedestal value of pixel data. */
  uint32_t offset() const { return _offset; }
  /** Pixel data as array of bytes, method is for internal use only, use data8() or 
            data16() for access to the data. */
  ndarray<uint8_t, 1> _int_pixel_data() const { ptrdiff_t offset=16;
  uint8_t* data = (uint8_t*)(((const char*)this)+offset);
  return make_ndarray(data, this->_width*this->_height*((this->_depth+7)/8)); }
  /** Returns pixel data array when stored data type is 8-bit (depth() is less than 9).
                If data type is 16-bit then empty array is returned, use data16() method in this case. */
  ndarray<uint8_t, 2> data8() const;
  /** Returns pixel data array when stored data type is 16-bit (depth() is greater than 8).
                If data type is 8-bit then empty array is returned, use data8() method in this case. */
  ndarray<uint16_t, 2> data16() const;
  uint32_t _sizeof() const { return ((((16+(1*(this->_width*this->_height*((this->_depth+7)/8))))+4)-1)/4)*4; }
private:
  uint32_t	_width;	/**< Number of pixels in a row. */
  uint32_t	_height;	/**< Number of pixels in a column. */
  uint32_t	_depth;	/**< Number of bits per pixel. */
  uint32_t	_offset;	/**< Fixed offset/pedestal value of pixel data. */
  //uint8_t	_pixel_data[this->_width*this->_height*((this->_depth+7)/8)];
};

/** @class TwoDGaussianV1

  
*/


class TwoDGaussianV1 {
public:
  enum { TypeId = Pds::TypeId::Id_TwoDGaussian /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  TwoDGaussianV1();
  TwoDGaussianV1(uint64_t arg__integral, double arg__xmean, double arg__ymean, double arg__major_axis_width, double arg__minor_axis_width, double arg__major_axis_tilt);
  uint64_t integral() const { return _integral; }
  double xmean() const { return _xmean; }
  double ymean() const { return _ymean; }
  double major_axis_width() const { return _major_axis_width; }
  double minor_axis_width() const { return _minor_axis_width; }
  double major_axis_tilt() const { return _major_axis_tilt; }
  static uint32_t _sizeof()  { return 48; }
private:
  uint64_t	_integral;
  double	_xmean;
  double	_ymean;
  double	_major_axis_width;
  double	_minor_axis_width;
  double	_major_axis_tilt;
};
} // namespace Camera
} // namespace PsddlPds
#endif // PSDDLPDS_CAMERA_DDL_H
