#ifndef PSDDLPDS_CAMERA_DDL_H
#define PSDDLPDS_CAMERA_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include "pdsdata/xtc/TypeId.hh"

#include <vector>

#include <cstddef>

namespace PsddlPds {
namespace Camera {

/** @class FrameCoord

  Class representing the coordinates of pixels iside the camera frame.
*/


class FrameCoord {
public:
  FrameCoord()
  {
  }
  FrameCoord(uint16_t arg__column, uint16_t arg__row)
    : _column(arg__column), _row(arg__row)
  {
  }
  /** Column index (x value). */
  uint16_t column() const {return _column;}
  /** Row index (y value). */
  uint16_t row() const {return _row;}
  static uint32_t _sizeof()  {return 4;}
private:
  uint16_t	_column;	/**< Column index (x value). */
  uint16_t	_row;	/**< Row index (y value). */
};

/** @class FrameFccdConfigV1

  This class was never defined/implemented.
*/


class FrameFccdConfigV1 {
public:
  enum {
    Version = 1 /**< XTC type version number */
  };
  enum {
    TypeId = Pds::TypeId::Id_FrameFccdConfig /**< XTC type ID value (from Pds::TypeId class) */
  };
  static uint32_t _sizeof()  {return 0;}
};

/** @class FrameFexConfigV1

  Class containing configuration data for online frame feature extraction process.
*/


class FrameFexConfigV1 {
public:
  enum {
    Version = 1 /**< XTC type version number */
  };
  enum {
    TypeId = Pds::TypeId::Id_FrameFexConfig /**< XTC type ID value (from Pds::TypeId class) */
  };
  enum Forwarding {
    NoFrame,
    FullFrame,
    RegionOfInterest,
  };
  enum Processing {
    NoProcessing,
    GssFullFrame,
    GssRegionOfInterest,
    GssThreshold,
  };
  /** Forwarding policy for frame data. */
  Camera::FrameFexConfigV1::Forwarding forwarding() const;
  /** Prescale of events with forwarded frames */
  uint32_t forward_prescale() const {return _forward_prescale;}
  /** Algorithm to apply to frames to produce processed output. */
  Camera::FrameFexConfigV1::Processing processing() const;
  /** Coordinate of start of rectangular region of interest (inclusive). */
  const Camera::FrameCoord& roiBegin() const {return _roiBegin;}
  /** Coordinate of finish of rectangular region of interest (exclusive). */
  const Camera::FrameCoord& roiEnd() const {return _roiEnd;}
  /** Pixel data threshold value to apply in processing. */
  uint32_t threshold() const {return _threshold;}
  /** Count of masked pixels to exclude from processing. */
  uint32_t number_of_masked_pixels() const {return _masked_pixel_count;}
  /** Location of masked pixel coordinates. */
  const Camera::FrameCoord& masked_pixel_coordinates(uint32_t i0) const {
    ptrdiff_t offset=28;
    const Camera::FrameCoord* memptr = (const Camera::FrameCoord*)(((const char*)this)+offset);
    size_t memsize = memptr->_sizeof();
    return *(const Camera::FrameCoord*)((const char*)memptr + (i0)*memsize);
  }
  uint32_t _sizeof() const {return ((((12+(Camera::FrameCoord::_sizeof()))+(Camera::FrameCoord::_sizeof()))+4)+4)+(Camera::FrameCoord::_sizeof()*(this->_masked_pixel_count));}
  /** Method which returns the shape (dimensions) of the data returned by masked_pixel_coordinates() method. */
  std::vector<int> masked_pixel_shape() const;
private:
  uint32_t	_forwarding;	/**< frame forwarding policy */
  uint32_t	_forward_prescale;	/**< Prescale of events with forwarded frames */
  uint32_t	_processing;	/**< algorithm to apply to frames to produce processed output */
  Camera::FrameCoord	_roiBegin;	/**< Coordinate of start of rectangular region of interest (inclusive). */
  Camera::FrameCoord	_roiEnd;	/**< Coordinate of finish of rectangular region of interest (exclusive). */
  uint32_t	_threshold;	/**< Pixel data threshold value to apply in processing. */
  uint32_t	_masked_pixel_count;	/**< Count of masked pixels to exclude from processing. */
  //Camera::FrameCoord	_masked_pixel_coordinates[this->_masked_pixel_count];
};

/** @class FrameV1

  
*/


class FrameV1 {
public:
  enum {
    Version = 1 /**< XTC type version number */
  };
  enum {
    TypeId = Pds::TypeId::Id_Frame /**< XTC type ID value (from Pds::TypeId class) */
  };
  /** Number of pixels in a row. */
  uint32_t width() const {return _width;}
  /** Number of pixels in a column. */
  uint32_t height() const {return _height;}
  /** Number of bits per pixel. */
  uint32_t depth() const {return _depth;}
  /** Fixed offset/pedestal value of pixel data. */
  uint32_t offset() const {return _offset;}
  /** Pixel data as array of bytes. */
  const uint8_t* data() const {
    ptrdiff_t offset=16;
    return (const uint8_t*)(((const char*)this)+offset);
  }
  uint32_t _sizeof() const {return 16+(1*(this->_width*this->_height*((this->_depth+7)/8)));}
  /** Method which returns the shape (dimensions) of the data returned by data() method. */
  std::vector<int> data_shape() const;
private:
  uint32_t	_width;	/**< Number of pixels in a row. */
  uint32_t	_height;	/**< Number of pixels in a column. */
  uint32_t	_depth;	/**< Number of bits per pixel. */
  uint32_t	_offset;	/**< Fixed offset/pedestal value of pixel data. */
  //uint8_t	_pixel_data[this->_width*this->_height*((this->_depth+7)/8)];
};

/** @class TwoDGaussianV1

  
*/


class TwoDGaussianV1 {
public:
  enum {
    Version = 1 /**< XTC type version number */
  };
  enum {
    TypeId = Pds::TypeId::Id_TwoDGaussian /**< XTC type ID value (from Pds::TypeId class) */
  };
  TwoDGaussianV1();
  TwoDGaussianV1(uint64_t arg__integral, double arg__xmean, double arg__ymean, double arg__major_axis_width, double arg__minor_axis_width, double arg__major_axis_tilt);
  uint64_t integral() const {return _integral;}
  double xmean() const {return _xmean;}
  double ymean() const {return _ymean;}
  double major_axis_width() const {return _major_axis_width;}
  double minor_axis_width() const {return _minor_axis_width;}
  double major_axis_tilt() const {return _major_axis_tilt;}
  static uint32_t _sizeof()  {return 48;}
private:
  uint64_t	_integral;
  double	_xmean;
  double	_ymean;
  double	_major_axis_width;
  double	_minor_axis_width;
  double	_major_axis_tilt;
};
} // namespace Camera
} // namespace PsddlPds
#endif // PSDDLPDS_CAMERA_DDL_H
