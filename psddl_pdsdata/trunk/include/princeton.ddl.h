#ifndef PSDDLPDS_PRINCETON_DDL_H
#define PSDDLPDS_PRINCETON_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
namespace PsddlPds {
namespace Princeton {

/** @class ConfigV1

  
*/

#pragma pack(push,4)

class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_PrincetonConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  uint32_t width() const { return _uWidth; }
  uint32_t height() const { return _uHeight; }
  uint32_t orgX() const { return _uOrgX; }
  uint32_t orgY() const { return _uOrgY; }
  uint32_t binX() const { return _uBinX; }
  uint32_t binY() const { return _uBinY; }
  float exposureTime() const { return _f32ExposureTime; }
  float coolingTemp() const { return _f32CoolingTemp; }
  uint32_t readoutSpeedIndex() const { return _u32ReadoutSpeedIndex; }
  uint16_t readoutEventCode() const { return _u16ReadoutEventCode; }
  uint16_t delayMode() const { return _u16DelayMode; }
  /** Total size in bytes of the Frame object including header and pixel data, 
            this returns the size of FrameV1 object, do not use this config type with FrameV2 */
  uint32_t frameSize() const;
  /** calculate frame X size in pixels based on the current ROI and binning settings */
  uint32_t numPixelsX() const { return (this->width() + this->binX() - 1) / this->binX(); }
  /** calculate frame Y size in pixels based on the current ROI and binning settings */
  uint32_t numPixelsY() const { return (this->height()+ this->binY() - 1) / this->binY(); }
  /** calculate total frame size in pixels based on the current ROI and binning settings */
  uint32_t numPixels() const { return ((this->width() + this->binX()-1)/ this->binX() )*((this->height()+ this->binY()-1)/ this->binY() ); }
  static uint32_t _sizeof()  { return 40; }
private:
  uint32_t	_uWidth;
  uint32_t	_uHeight;
  uint32_t	_uOrgX;
  uint32_t	_uOrgY;
  uint32_t	_uBinX;
  uint32_t	_uBinY;
  float	_f32ExposureTime;
  float	_f32CoolingTemp;
  uint32_t	_u32ReadoutSpeedIndex;
  uint16_t	_u16ReadoutEventCode;
  uint16_t	_u16DelayMode;
};
#pragma pack(pop)

/** @class ConfigV2

  
*/

#pragma pack(push,4)

class ConfigV2 {
public:
  enum { TypeId = Pds::TypeId::Id_PrincetonConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  uint32_t width() const { return _uWidth; }
  uint32_t height() const { return _uHeight; }
  uint32_t orgX() const { return _uOrgX; }
  uint32_t orgY() const { return _uOrgY; }
  uint32_t binX() const { return _uBinX; }
  uint32_t binY() const { return _uBinY; }
  float exposureTime() const { return _f32ExposureTime; }
  float coolingTemp() const { return _f32CoolingTemp; }
  uint16_t gainIndex() const { return _u16GainIndex; }
  uint16_t readoutSpeedIndex() const { return _u16ReadoutSpeedIndex; }
  uint16_t readoutEventCode() const { return _u16ReadoutEventCode; }
  uint16_t delayMode() const { return _u16DelayMode; }
  /** Total size in bytes of the Frame object including header and pixel data, 
            this returns the size of FrameV1 object, do not use this config type with FrameV2 */
  uint32_t frameSize() const;
  /** calculate frame X size in pixels based on the current ROI and binning settings */
  uint32_t numPixelsX() const { return (this->width() + this->binX() - 1) / this->binX(); }
  /** calculate frame Y size in pixels based on the current ROI and binning settings */
  uint32_t numPixelsY() const { return (this->height()+ this->binY() - 1) / this->binY(); }
  /** calculate total frame size in pixels based on the current ROI and binning settings */
  uint32_t numPixels() const { return ((this->width() + this->binX()-1)/ this->binX() )*((this->height()+ this->binY()-1)/ this->binY() ); }
  static uint32_t _sizeof()  { return 40; }
private:
  uint32_t	_uWidth;
  uint32_t	_uHeight;
  uint32_t	_uOrgX;
  uint32_t	_uOrgY;
  uint32_t	_uBinX;
  uint32_t	_uBinY;
  float	_f32ExposureTime;
  float	_f32CoolingTemp;
  uint16_t	_u16GainIndex;
  uint16_t	_u16ReadoutSpeedIndex;
  uint16_t	_u16ReadoutEventCode;
  uint16_t	_u16DelayMode;
};
#pragma pack(pop)

/** @class ConfigV3

  
*/

#pragma pack(push,4)

class ConfigV3 {
public:
  enum { TypeId = Pds::TypeId::Id_PrincetonConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 3 /**< XTC type version number */ };
  uint32_t width() const { return _uWidth; }
  uint32_t height() const { return _uHeight; }
  uint32_t orgX() const { return _uOrgX; }
  uint32_t orgY() const { return _uOrgY; }
  uint32_t binX() const { return _uBinX; }
  uint32_t binY() const { return _uBinY; }
  float exposureTime() const { return _f32ExposureTime; }
  float coolingTemp() const { return _f32CoolingTemp; }
  uint8_t gainIndex() const { return _u8GainIndex; }
  uint8_t readoutSpeedIndex() const { return _u8ReadoutSpeedIndex; }
  uint16_t exposureEventCode() const { return _u16ExposureEventCode; }
  uint32_t numDelayShots() const { return _u32NumDelayShots; }
  /** Total size in bytes of the Frame object including header and pixel data, 
            this returns the size of FrameV1 object, do not use this config type with FrameV2 */
  uint32_t frameSize() const;
  /** calculate frame X size in pixels based on the current ROI and binning settings */
  uint32_t numPixelsX() const { return (this->width() + this->binX() - 1) / this->binX(); }
  /** calculate frame Y size in pixels based on the current ROI and binning settings */
  uint32_t numPixelsY() const { return (this->height()+ this->binY() - 1) / this->binY(); }
  /** calculate total frame size in pixels based on the current ROI and binning settings */
  uint32_t numPixels() const { return ((this->width() + this->binX()-1)/ this->binX() )*((this->height()+ this->binY()-1)/ this->binY() ); }
  static uint32_t _sizeof()  { return 40; }
private:
  uint32_t	_uWidth;
  uint32_t	_uHeight;
  uint32_t	_uOrgX;
  uint32_t	_uOrgY;
  uint32_t	_uBinX;
  uint32_t	_uBinY;
  float	_f32ExposureTime;
  float	_f32CoolingTemp;
  uint8_t	_u8GainIndex;
  uint8_t	_u8ReadoutSpeedIndex;
  uint16_t	_u16ExposureEventCode;
  uint32_t	_u32NumDelayShots;
};
#pragma pack(pop)

/** @class ConfigV4

  
*/

#pragma pack(push,4)

class ConfigV4 {
public:
  enum { TypeId = Pds::TypeId::Id_PrincetonConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 4 /**< XTC type version number */ };
  uint32_t width() const { return _uWidth; }
  uint32_t height() const { return _uHeight; }
  uint32_t orgX() const { return _uOrgX; }
  uint32_t orgY() const { return _uOrgY; }
  uint32_t binX() const { return _uBinX; }
  uint32_t binY() const { return _uBinY; }
  uint32_t maskedHeight() const { return _u32MaskedHeight; }
  uint32_t kineticHeight() const { return _u32KineticHeight; }
  float vsSpeed() const { return _f32VsSpeed; }
  float exposureTime() const { return _f32ExposureTime; }
  float coolingTemp() const { return _f32CoolingTemp; }
  uint8_t gainIndex() const { return _u8GainIndex; }
  uint8_t readoutSpeedIndex() const { return _u8ReadoutSpeedIndex; }
  uint16_t exposureEventCode() const { return _u16ExposureEventCode; }
  uint32_t numDelayShots() const { return _u32NumDelayShots; }
  /** Total size in bytes of the Frame object including header and pixel data, 
            this returns the size of FrameV1 object, do not use this config type with FrameV2 */
  uint32_t frameSize() const;
  /** calculate frame X size in pixels based on the current ROI and binning settings */
  uint32_t numPixelsX() const { return (this->width() + this->binX() - 1) / this->binX(); }
  /** calculate frame Y size in pixels based on the current ROI and binning settings */
  uint32_t numPixelsY() const { return (this->height()+ this->binY() - 1) / this->binY(); }
  /** calculate total frame size in pixels based on the current ROI and binning settings */
  uint32_t numPixels() const { return ((this->width() + this->binX()-1)/ this->binX() )*((this->height()+ this->binY()-1)/ this->binY() ); }
  static uint32_t _sizeof()  { return 52; }
private:
  uint32_t	_uWidth;
  uint32_t	_uHeight;
  uint32_t	_uOrgX;
  uint32_t	_uOrgY;
  uint32_t	_uBinX;
  uint32_t	_uBinY;
  uint32_t	_u32MaskedHeight;
  uint32_t	_u32KineticHeight;
  float	_f32VsSpeed;
  float	_f32ExposureTime;
  float	_f32CoolingTemp;
  uint8_t	_u8GainIndex;
  uint8_t	_u8ReadoutSpeedIndex;
  uint16_t	_u16ExposureEventCode;
  uint32_t	_u32NumDelayShots;
};
#pragma pack(pop)

/** @class ConfigV5

  
*/

#pragma pack(push,4)

class ConfigV5 {
public:
  enum { TypeId = Pds::TypeId::Id_PrincetonConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 5 /**< XTC type version number */ };
  uint32_t width() const { return _uWidth; }
  uint32_t height() const { return _uHeight; }
  uint32_t orgX() const { return _uOrgX; }
  uint32_t orgY() const { return _uOrgY; }
  uint32_t binX() const { return _uBinX; }
  uint32_t binY() const { return _uBinY; }
  float exposureTime() const { return _f32ExposureTime; }
  float coolingTemp() const { return _f32CoolingTemp; }
  uint16_t gainIndex() const { return _u16GainIndex; }
  uint16_t readoutSpeedIndex() const { return _u16ReadoutSpeedIndex; }
  uint32_t maskedHeight() const { return _u32MaskedHeight; }
  uint32_t kineticHeight() const { return _u32KineticHeight; }
  float vsSpeed() const { return _f32VsSpeed; }
  int16_t infoReportInterval() const { return _i16InfoReportInterval; }
  uint16_t exposureEventCode() const { return _u16ExposureEventCode; }
  uint32_t numDelayShots() const { return _u32NumDelayShots; }
  /** Total size in bytes of the Frame object including header and pixel data, 
            this returns the size of FrameV2 object, do not use this config type with FrameV1 */
  uint32_t frameSize() const;
  /** calculate frame X size in pixels based on the current ROI and binning settings */
  uint32_t numPixelsX() const { return (this->width() + this->binX() - 1) / this->binX(); }
  /** calculate frame Y size in pixels based on the current ROI and binning settings */
  uint32_t numPixelsY() const { return (this->height()+ this->binY() - 1) / this->binY(); }
  /** calculate total frame size in pixels based on the current ROI and binning settings */
  uint32_t numPixels() const { return ((this->width() + this->binX()-1)/ this->binX() )*((this->height()+ this->binY()-1)/ this->binY() ); }
  static uint32_t _sizeof()  { return 56; }
private:
  uint32_t	_uWidth;
  uint32_t	_uHeight;
  uint32_t	_uOrgX;
  uint32_t	_uOrgY;
  uint32_t	_uBinX;
  uint32_t	_uBinY;
  float	_f32ExposureTime;
  float	_f32CoolingTemp;
  uint16_t	_u16GainIndex;
  uint16_t	_u16ReadoutSpeedIndex;
  uint32_t	_u32MaskedHeight;
  uint32_t	_u32KineticHeight;
  float	_f32VsSpeed;
  int16_t	_i16InfoReportInterval;
  uint16_t	_u16ExposureEventCode;
  uint32_t	_u32NumDelayShots;
};
#pragma pack(pop)

/** @class FrameV1

  
*/

class ConfigV1;
class ConfigV2;
class ConfigV3;
class ConfigV4;
class ConfigV5;
#pragma pack(push,4)

class FrameV1 {
public:
  enum { TypeId = Pds::TypeId::Id_PrincetonFrame /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  uint32_t shotIdStart() const { return _iShotIdStart; }
  float readoutTime() const { return _fReadoutTime; }
  ndarray<const uint16_t, 2> data(const Princeton::ConfigV1& cfg) const { ptrdiff_t offset=8;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numPixelsY(), cfg.numPixelsX()); }
  ndarray<const uint16_t, 2> data(const Princeton::ConfigV2& cfg) const { ptrdiff_t offset=8;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numPixelsY(), cfg.numPixelsX()); }
  ndarray<const uint16_t, 2> data(const Princeton::ConfigV3& cfg) const { ptrdiff_t offset=8;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numPixelsY(), cfg.numPixelsX()); }
  ndarray<const uint16_t, 2> data(const Princeton::ConfigV4& cfg) const { ptrdiff_t offset=8;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numPixelsY(), cfg.numPixelsX()); }
  ndarray<const uint16_t, 2> data(const Princeton::ConfigV5& cfg) const { ptrdiff_t offset=8;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numPixelsY(), cfg.numPixelsX()); }
  static uint32_t _sizeof(const Princeton::ConfigV1& cfg)  { return ((((8+(2*(cfg.numPixelsY())*(cfg.numPixelsX())))+4)-1)/4)*4; }
  static uint32_t _sizeof(const Princeton::ConfigV2& cfg)  { return ((((8+(2*(cfg.numPixelsY())*(cfg.numPixelsX())))+4)-1)/4)*4; }
  static uint32_t _sizeof(const Princeton::ConfigV3& cfg)  { return ((((8+(2*(cfg.numPixelsY())*(cfg.numPixelsX())))+4)-1)/4)*4; }
  static uint32_t _sizeof(const Princeton::ConfigV4& cfg)  { return ((((8+(2*(cfg.numPixelsY())*(cfg.numPixelsX())))+4)-1)/4)*4; }
  static uint32_t _sizeof(const Princeton::ConfigV5& cfg)  { return ((((8+(2*(cfg.numPixelsY())*(cfg.numPixelsX())))+4)-1)/4)*4; }
private:
  uint32_t	_iShotIdStart;
  float	_fReadoutTime;
  //uint16_t	_data[cfg.numPixelsY()][cfg.numPixelsX()];
};
#pragma pack(pop)

/** @class FrameV2

  
*/

class ConfigV1;
class ConfigV2;
class ConfigV3;
class ConfigV4;
class ConfigV5;
#pragma pack(push,4)

class FrameV2 {
public:
  enum { TypeId = Pds::TypeId::Id_PrincetonFrame /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  uint32_t shotIdStart() const { return _iShotIdStart; }
  float readoutTime() const { return _fReadoutTime; }
  float temperature() const { return _fTemperature; }
  ndarray<const uint16_t, 2> data(const Princeton::ConfigV1& cfg) const { ptrdiff_t offset=12;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numPixelsY(), cfg.numPixelsX()); }
  ndarray<const uint16_t, 2> data(const Princeton::ConfigV2& cfg) const { ptrdiff_t offset=12;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numPixelsY(), cfg.numPixelsX()); }
  ndarray<const uint16_t, 2> data(const Princeton::ConfigV3& cfg) const { ptrdiff_t offset=12;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numPixelsY(), cfg.numPixelsX()); }
  ndarray<const uint16_t, 2> data(const Princeton::ConfigV4& cfg) const { ptrdiff_t offset=12;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numPixelsY(), cfg.numPixelsX()); }
  ndarray<const uint16_t, 2> data(const Princeton::ConfigV5& cfg) const { ptrdiff_t offset=12;
  const uint16_t* data = (const uint16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numPixelsY(), cfg.numPixelsX()); }
  static uint32_t _sizeof(const Princeton::ConfigV1& cfg)  { return ((((12+(2*(cfg.numPixelsY())*(cfg.numPixelsX())))+4)-1)/4)*4; }
  static uint32_t _sizeof(const Princeton::ConfigV2& cfg)  { return ((((12+(2*(cfg.numPixelsY())*(cfg.numPixelsX())))+4)-1)/4)*4; }
  static uint32_t _sizeof(const Princeton::ConfigV3& cfg)  { return ((((12+(2*(cfg.numPixelsY())*(cfg.numPixelsX())))+4)-1)/4)*4; }
  static uint32_t _sizeof(const Princeton::ConfigV4& cfg)  { return ((((12+(2*(cfg.numPixelsY())*(cfg.numPixelsX())))+4)-1)/4)*4; }
  static uint32_t _sizeof(const Princeton::ConfigV5& cfg)  { return ((((12+(2*(cfg.numPixelsY())*(cfg.numPixelsX())))+4)-1)/4)*4; }
private:
  uint32_t	_iShotIdStart;
  float	_fReadoutTime;
  float	_fTemperature;
  //uint16_t	_data[cfg.numPixelsY()][cfg.numPixelsX()];
};
#pragma pack(pop)

/** @class InfoV1

  
*/


class InfoV1 {
public:
  enum { TypeId = Pds::TypeId::Id_PrincetonInfo /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  InfoV1(float arg__fTemperature)
    : _fTemperature(arg__fTemperature)
  {
  }
  float temperature() const { return _fTemperature; }
  static uint32_t _sizeof()  { return 4; }
private:
  float	_fTemperature;
};
} // namespace Princeton
} // namespace PsddlPds
#endif // PSDDLPDS_PRINCETON_DDL_H
