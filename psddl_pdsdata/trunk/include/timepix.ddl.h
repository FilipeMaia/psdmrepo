#ifndef PSDDLPDS_TIMEPIX_DDL_H
#define PSDDLPDS_TIMEPIX_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <cstddef>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
namespace PsddlPds {
namespace Timepix {

/** @class ConfigV1

  
*/

#pragma pack(push,4)

class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_TimepixConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { ChipCount = 4 };
  enum ReadoutSpeed {
    ReadoutSpeed_Slow = 0,
    ReadoutSpeed_Fast = 1,
  };
  enum TriggerMode {
    TriggerMode_ExtPos = 0,
    TriggerMode_ExtNeg = 1,
    TriggerMode_Soft = 2,
  };
  Timepix::ConfigV1::ReadoutSpeed readoutSpeed() const { return ReadoutSpeed(_readoutSpeed); }
  Timepix::ConfigV1::TriggerMode triggerMode() const { return TriggerMode(_triggerMode); }
  int32_t shutterTimeout() const { return _shutterTimeout; }
  int32_t dac0Ikrum() const { return _dac0Ikrum; }
  int32_t dac0Disc() const { return _dac0Disc; }
  int32_t dac0Preamp() const { return _dac0Preamp; }
  int32_t dac0BufAnalogA() const { return _dac0BufAnalogA; }
  int32_t dac0BufAnalogB() const { return _dac0BufAnalogB; }
  int32_t dac0Hist() const { return _dac0Hist; }
  int32_t dac0ThlFine() const { return _dac0ThlFine; }
  int32_t dac0ThlCourse() const { return _dac0ThlCourse; }
  int32_t dac0Vcas() const { return _dac0Vcas; }
  int32_t dac0Fbk() const { return _dac0Fbk; }
  int32_t dac0Gnd() const { return _dac0Gnd; }
  int32_t dac0Ths() const { return _dac0Ths; }
  int32_t dac0BiasLvds() const { return _dac0BiasLvds; }
  int32_t dac0RefLvds() const { return _dac0RefLvds; }
  int32_t dac1Ikrum() const { return _dac1Ikrum; }
  int32_t dac1Disc() const { return _dac1Disc; }
  int32_t dac1Preamp() const { return _dac1Preamp; }
  int32_t dac1BufAnalogA() const { return _dac1BufAnalogA; }
  int32_t dac1BufAnalogB() const { return _dac1BufAnalogB; }
  int32_t dac1Hist() const { return _dac1Hist; }
  int32_t dac1ThlFine() const { return _dac1ThlFine; }
  int32_t dac1ThlCourse() const { return _dac1ThlCourse; }
  int32_t dac1Vcas() const { return _dac1Vcas; }
  int32_t dac1Fbk() const { return _dac1Fbk; }
  int32_t dac1Gnd() const { return _dac1Gnd; }
  int32_t dac1Ths() const { return _dac1Ths; }
  int32_t dac1BiasLvds() const { return _dac1BiasLvds; }
  int32_t dac1RefLvds() const { return _dac1RefLvds; }
  int32_t dac2Ikrum() const { return _dac2Ikrum; }
  int32_t dac2Disc() const { return _dac2Disc; }
  int32_t dac2Preamp() const { return _dac2Preamp; }
  int32_t dac2BufAnalogA() const { return _dac2BufAnalogA; }
  int32_t dac2BufAnalogB() const { return _dac2BufAnalogB; }
  int32_t dac2Hist() const { return _dac2Hist; }
  int32_t dac2ThlFine() const { return _dac2ThlFine; }
  int32_t dac2ThlCourse() const { return _dac2ThlCourse; }
  int32_t dac2Vcas() const { return _dac2Vcas; }
  int32_t dac2Fbk() const { return _dac2Fbk; }
  int32_t dac2Gnd() const { return _dac2Gnd; }
  int32_t dac2Ths() const { return _dac2Ths; }
  int32_t dac2BiasLvds() const { return _dac2BiasLvds; }
  int32_t dac2RefLvds() const { return _dac2RefLvds; }
  int32_t dac3Ikrum() const { return _dac3Ikrum; }
  int32_t dac3Disc() const { return _dac3Disc; }
  int32_t dac3Preamp() const { return _dac3Preamp; }
  int32_t dac3BufAnalogA() const { return _dac3BufAnalogA; }
  int32_t dac3BufAnalogB() const { return _dac3BufAnalogB; }
  int32_t dac3Hist() const { return _dac3Hist; }
  int32_t dac3ThlFine() const { return _dac3ThlFine; }
  int32_t dac3ThlCourse() const { return _dac3ThlCourse; }
  int32_t dac3Vcas() const { return _dac3Vcas; }
  int32_t dac3Fbk() const { return _dac3Fbk; }
  int32_t dac3Gnd() const { return _dac3Gnd; }
  int32_t dac3Ths() const { return _dac3Ths; }
  int32_t dac3BiasLvds() const { return _dac3BiasLvds; }
  int32_t dac3RefLvds() const { return _dac3RefLvds; }
  static uint32_t _sizeof()  { return 232; }
private:
  uint8_t	_readoutSpeed;
  uint8_t	_triggerMode;
  int16_t	_pad;
  int32_t	_shutterTimeout;
  int32_t	_dac0Ikrum;
  int32_t	_dac0Disc;
  int32_t	_dac0Preamp;
  int32_t	_dac0BufAnalogA;
  int32_t	_dac0BufAnalogB;
  int32_t	_dac0Hist;
  int32_t	_dac0ThlFine;
  int32_t	_dac0ThlCourse;
  int32_t	_dac0Vcas;
  int32_t	_dac0Fbk;
  int32_t	_dac0Gnd;
  int32_t	_dac0Ths;
  int32_t	_dac0BiasLvds;
  int32_t	_dac0RefLvds;
  int32_t	_dac1Ikrum;
  int32_t	_dac1Disc;
  int32_t	_dac1Preamp;
  int32_t	_dac1BufAnalogA;
  int32_t	_dac1BufAnalogB;
  int32_t	_dac1Hist;
  int32_t	_dac1ThlFine;
  int32_t	_dac1ThlCourse;
  int32_t	_dac1Vcas;
  int32_t	_dac1Fbk;
  int32_t	_dac1Gnd;
  int32_t	_dac1Ths;
  int32_t	_dac1BiasLvds;
  int32_t	_dac1RefLvds;
  int32_t	_dac2Ikrum;
  int32_t	_dac2Disc;
  int32_t	_dac2Preamp;
  int32_t	_dac2BufAnalogA;
  int32_t	_dac2BufAnalogB;
  int32_t	_dac2Hist;
  int32_t	_dac2ThlFine;
  int32_t	_dac2ThlCourse;
  int32_t	_dac2Vcas;
  int32_t	_dac2Fbk;
  int32_t	_dac2Gnd;
  int32_t	_dac2Ths;
  int32_t	_dac2BiasLvds;
  int32_t	_dac2RefLvds;
  int32_t	_dac3Ikrum;
  int32_t	_dac3Disc;
  int32_t	_dac3Preamp;
  int32_t	_dac3BufAnalogA;
  int32_t	_dac3BufAnalogB;
  int32_t	_dac3Hist;
  int32_t	_dac3ThlFine;
  int32_t	_dac3ThlCourse;
  int32_t	_dac3Vcas;
  int32_t	_dac3Fbk;
  int32_t	_dac3Gnd;
  int32_t	_dac3Ths;
  int32_t	_dac3BiasLvds;
  int32_t	_dac3RefLvds;
};
#pragma pack(pop)

/** @class DataV1

  
*/


class DataV1 {
public:
  enum { TypeId = Pds::TypeId::Id_TimepixData /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { Height = 512 };
  enum { Width = 512 };
  enum { Depth = 14 };
  enum { DepthBytes = 2 };
  enum { MaxPixelValue = 11810 };
  uint32_t timestamp() const { return _timestamp; }
  uint16_t frameCounter() const { return _frameCounter; }
  uint16_t lostRows() const { return _lostRows; }
  ndarray<uint16_t, 2> data() const { return make_ndarray(&_data[0][0], Height, Width); }
  uint32_t width() const { return Width; }
  uint32_t height() const { return Height; }
  uint32_t depth() const { return Depth; }
  uint32_t depth_bytes() const { return DepthBytes; }
  static uint32_t _sizeof()  { return 8+(2*(Height)*(Width)); }
private:
  uint32_t	_timestamp;
  uint16_t	_frameCounter;
  uint16_t	_lostRows;
  uint16_t	_data[Height][Width];
};

/** @class DataV2

  
*/


class DataV2 {
public:
  enum { TypeId = Pds::TypeId::Id_TimepixData /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  enum { Depth = 14 };
  enum { MaxPixelValue = 11810 };
  /** Pixels per row */
  uint16_t width() const { return _width; }
  /** Pixels per column */
  uint16_t height() const { return _height; }
  /** hardware timestamp */
  uint32_t timestamp() const { return _timestamp; }
  /** hardware frame counter */
  uint16_t frameCounter() const { return _frameCounter; }
  /** lost row count */
  uint16_t lostRows() const { return _lostRows; }
  ndarray<uint16_t, 2> data() const { ptrdiff_t offset=12;
  uint16_t* data = (uint16_t*)(((const char*)this)+offset);
  return make_ndarray(data, this->_height, this->_width); }
  uint32_t depth() const { return Depth; }
  uint32_t depth_bytes() const { return (Depth+7)/8; }
  uint32_t _sizeof() const { return 12+(2*(this->_height)*(this->_width)); }
private:
  uint16_t	_width;	/**< Pixels per row */
  uint16_t	_height;	/**< Pixels per column */
  uint32_t	_timestamp;	/**< hardware timestamp */
  uint16_t	_frameCounter;	/**< hardware frame counter */
  uint16_t	_lostRows;	/**< lost row count */
  //uint16_t	_data[this->_height][this->_width];
};
} // namespace Timepix
} // namespace PsddlPds
#endif // PSDDLPDS_TIMEPIX_DDL_H
