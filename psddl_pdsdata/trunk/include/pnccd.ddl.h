#ifndef PSDDLPDS_PNCCD_DDL_H
#define PSDDLPDS_PNCCD_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <cstddef>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
namespace PsddlPds {
namespace PNCCD {

/** @class ConfigV1

  pnCCD configuration class ConfigV1
*/


class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_pnCCDconfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  /** Number of links in the pnCCD. */
  uint32_t numLinks() const { return _numLinks; }
  /** Size of the payload in bytes for single link */
  uint32_t payloadSizePerLink() const { return _payloadSizePerLink; }
  static uint32_t _sizeof()  { return 8; }
private:
  uint32_t	_numLinks;	/**< Number of links in the pnCCD. */
  uint32_t	_payloadSizePerLink;	/**< Size of the payload in bytes for single link */
};

/** @class ConfigV2

  pnCCD configuration class ConfigV2
*/


class ConfigV2 {
public:
  enum { TypeId = Pds::TypeId::Id_pnCCDconfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  /** Number of links in the pnCCD. */
  uint32_t numLinks() const { return _numLinks; }
  /** Size of the payload in bytes for single link */
  uint32_t payloadSizePerLink() const { return _payloadSizePerLink; }
  /** Number of channels */
  uint32_t numChannels() const { return _numChannels; }
  /** Number of rows */
  uint32_t numRows() const { return _numRows; }
  /** Number of submodule channels */
  uint32_t numSubmoduleChannels() const { return _numSubmoduleChannels; }
  /** Number of submodule rows */
  uint32_t numSubmoduleRows() const { return _numSubmoduleRows; }
  /** Number of submodules */
  uint32_t numSubmodules() const { return _numSubmodules; }
  /** Magic word from CAMEX */
  uint32_t camexMagic() const { return _camexMagic; }
  /** Information data string */
  const char* info() const { return _info; }
  /** Timing file name string */
  const char* timingFName() const { return _timingFName; }
  static uint32_t _sizeof()  { return (32+(1*(256)))+(1*(256)); }
  /** Method which returns the shape (dimensions) of the data returned by info() method. */
  std::vector<int> info_shape() const;
  /** Method which returns the shape (dimensions) of the data returned by timingFName() method. */
  std::vector<int> timingFName_shape() const;
private:
  uint32_t	_numLinks;	/**< Number of links in the pnCCD. */
  uint32_t	_payloadSizePerLink;	/**< Size of the payload in bytes for single link */
  uint32_t	_numChannels;	/**< Number of channels */
  uint32_t	_numRows;	/**< Number of rows */
  uint32_t	_numSubmoduleChannels;	/**< Number of submodule channels */
  uint32_t	_numSubmoduleRows;	/**< Number of submodule rows */
  uint32_t	_numSubmodules;	/**< Number of submodules */
  uint32_t	_camexMagic;	/**< Magic word from CAMEX */
  char	_info[256];	/**< Information data string */
  char	_timingFName[256];	/**< Timing file name string */
};

/** @class FrameV1

  pnCCD configuration class FrameV1
*/

class ConfigV1;
class ConfigV2;

class FrameV1 {
public:
  enum { TypeId = Pds::TypeId::Id_pnCCDframe /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  /** Special values */
  uint32_t specialWord() const { return _specialWord; }
  /** Frame number */
  uint32_t frameNumber() const { return _frameNumber; }
  /** Most significant part of timestamp */
  uint32_t timeStampHi() const { return _timeStampHi; }
  /** Least significant part of timestamp */
  uint32_t timeStampLo() const { return _timeStampLo; }
  /** Frame data */
  ndarray<uint16_t, 1> data(const PNCCD::ConfigV1& cfg) const { ptrdiff_t offset=16;
  uint16_t* data = (uint16_t*)(((const char*)this)+offset);
  return make_ndarray(data, (cfg.payloadSizePerLink()-16)/2); }
  /** Frame data */
  ndarray<uint16_t, 1> data(const PNCCD::ConfigV2& cfg) const { ptrdiff_t offset=16;
  uint16_t* data = (uint16_t*)(((const char*)this)+offset);
  return make_ndarray(data, (cfg.payloadSizePerLink()-16)/2); }
  static uint32_t _sizeof(const PNCCD::ConfigV1& cfg)  { return 16+(2*((cfg.payloadSizePerLink()-16)/2)); }
  static uint32_t _sizeof(const PNCCD::ConfigV2& cfg)  { return 16+(2*((cfg.payloadSizePerLink()-16)/2)); }
private:
  uint32_t	_specialWord;	/**< Special values */
  uint32_t	_frameNumber;	/**< Frame number */
  uint32_t	_timeStampHi;	/**< Most significant part of timestamp */
  uint32_t	_timeStampLo;	/**< Least significant part of timestamp */
  //uint16_t	__data[(cfg.payloadSizePerLink()-16)/2];
};
} // namespace PNCCD
} // namespace PsddlPds
#endif // PSDDLPDS_PNCCD_DDL_H
