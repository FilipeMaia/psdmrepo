#ifndef PSDDLPDS_OCEANOPTICS_DDL_H
#define PSDDLPDS_OCEANOPTICS_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
namespace PsddlPds {
namespace OceanOptics {

/** @class ConfigV1

  
*/

#pragma pack(push,4)

class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_OceanOpticsConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  float exposureTime() const { return _f32ExposureTime; }
  ndarray<const double, 1> waveLenCalib() const { return make_ndarray(&_lfWaveLenCalibCoeff[0], 4); }
  ndarray<const double, 1> nonlinCorrect() const { return make_ndarray(&_lfNonlinCorrectCoeff[0], 8); }
  double strayLightConstant() const { return _fStrayLightConstant; }
  static uint32_t _sizeof()  { return ((((((4+(8*(4)))+(8*(8)))+8)+4)-1)/4)*4; }
private:
  float	_f32ExposureTime;
  double	_lfWaveLenCalibCoeff[4];
  double	_lfNonlinCorrectCoeff[8];
  double	_fStrayLightConstant;
};
#pragma pack(pop)

/** @class timespec64

  
*/

#pragma pack(push,4)

class timespec64 {
public:
  timespec64()
  {
  }
  timespec64(uint64_t arg__tv_sec, uint64_t arg__tv_nsec)
    : _tv_sec(arg__tv_sec), _tv_nsec(arg__tv_nsec)
  {
  }
  uint64_t tv_sec() const { return _tv_sec; }
  uint64_t tv_nsec() const { return _tv_nsec; }
  static uint32_t _sizeof()  { return 16; }
private:
  uint64_t	_tv_sec;
  uint64_t	_tv_nsec;
};
#pragma pack(pop)

/** @class DataV1

  
*/

class ConfigV1;
#pragma pack(push,4)

class DataV1 {
public:
  enum { TypeId = Pds::TypeId::Id_OceanOpticsData /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  enum { iDataReadSize = 8192 };
  enum { iNumPixels = 3840 };
  enum { iActivePixelIndex = 22 };
  ndarray<const uint16_t, 1> data() const { return make_ndarray(&lu16Spetra[0], iNumPixels); }
  uint64_t frameCounter() const { return _u64FrameCounter; }
  uint64_t numDelayedFrames() const { return _u64NumDelayedFrames; }
  uint64_t numDiscardFrames() const { return _u64NumDiscardFrames; }
  const OceanOptics::timespec64& timeFrameStart() const { return _tsTimeFrameStart; }
  const OceanOptics::timespec64& timeFrameFirstData() const { return _tsTimeFrameFirstData; }
  const OceanOptics::timespec64& timeFrameEnd() const { return _tsTimeFrameEnd; }
  int8_t numSpectraInData() const { return _i8NumSpectraInData; }
  int8_t numSpectraInQueue() const { return _i8NumSpectraInQueue; }
  int8_t numSpectraUnused() const { return _i8NumSpectraUnused; }
  double durationOfFrame() const { return this->timeFrameEnd().tv_sec() - this->timeFrameStart().tv_sec() + (this->timeFrameEnd().tv_nsec() - this->timeFrameStart().tv_nsec()) * 1e-9; }
  double nonlinerCorrected(const OceanOptics::ConfigV1& cfg, uint32_t iPixel) const;
  static uint32_t _sizeof()  { return (((((((((((((((0+(2*(iNumPixels)))+8)+8)+8)+(OceanOptics::timespec64::_sizeof()))+(OceanOptics::timespec64::_sizeof()))+(OceanOptics::timespec64::_sizeof()))+4)+1)+1)+1)+1)+4)-1)/4)*4; }
private:
  uint16_t	lu16Spetra[iNumPixels];
  uint64_t	_u64FrameCounter;
  uint64_t	_u64NumDelayedFrames;
  uint64_t	_u64NumDiscardFrames;
  OceanOptics::timespec64	_tsTimeFrameStart;
  OceanOptics::timespec64	_tsTimeFrameFirstData;
  OceanOptics::timespec64	_tsTimeFrameEnd;
  int32_t	_i32Version;
  int8_t	_i8NumSpectraInData;
  int8_t	_i8NumSpectraInQueue;
  int8_t	_i8NumSpectraUnused;
  int8_t	_iReserved1;
};
#pragma pack(pop)
} // namespace OceanOptics
} // namespace PsddlPds
#endif // PSDDLPDS_OCEANOPTICS_DDL_H
