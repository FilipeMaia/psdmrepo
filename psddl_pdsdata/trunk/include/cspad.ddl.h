#ifndef PSDDLPDS_CSPAD_DDL_H
#define PSDDLPDS_CSPAD_DDL_H 1

// *** Do not edit this file, it is auto-generated ***

#include <vector>
#include <iosfwd>
#include <cstddef>
#include "pdsdata/xtc/TypeId.hh"
#include "ndarray/ndarray.h"
namespace PsddlPds {
namespace CsPad {
  enum {
    MaxQuadsPerSensor = 4 /**< Defines number of quadrants in a CsPad device. */
  };
  enum {
    ASICsPerQuad = 16 /**< Total number of ASICs in one quadrant. */
  };
  enum {
    RowsPerBank = 26 /**< Number of rows per readout bank? */
  };
  enum {
    FullBanksPerASIC = 7 /**< Number of full readout banks per one ASIC? */
  };
  enum {
    BanksPerASIC = 8 /**< Number of readout banks per one ASIC? */
  };
  enum {
    ColumnsPerASIC = 185 /**< Number of columns readout by single ASIC. */
  };
  enum {
    MaxRowsPerASIC = 194 /**< Maximum number of rows readout by single ASIC. */
  };
  enum {
    PotsPerQuad = 80 /**< Number of POTs? per single quadrant. */
  };
  enum {
    TwoByTwosPerQuad = 4 /**< Total number of 2x2s in single quadrant. */
  };
  enum {
    SectorsPerQuad = 8 /**< Total number of sectors (2x1) per single quadrant. */
  };

  /** Enum specifying different running modes. */
  enum RunModes {
    NoRunning,
    RunButDrop,
    RunAndSendToRCE,
    RunAndSendTriggeredByTTL,
    ExternalTriggerSendToRCE,
    ExternalTriggerDrop,
    NumberOfRunModes,
  };

  /** Enum specifying different data collection modes. */
  enum DataModes {
    normal = 0,
    shiftTest = 1,
    testData = 2,
    reserved = 3,
  };

/** @class CsPadDigitalPotsCfg

  Class defining configuration for CsPad POTs?
*/


class CsPadDigitalPotsCfg {
public:
  ndarray<const uint8_t, 1> pots() const { return make_ndarray(&_pots[0], PotsPerQuad); }
  static uint32_t _sizeof() { return ((((0+(1*(PotsPerQuad)))+1)-1)/1)*1; }
private:
  uint8_t	_pots[PotsPerQuad];
};

/** @class CsPadReadOnlyCfg

  Class defining read-only configuration.
*/


class CsPadReadOnlyCfg {
public:
  CsPadReadOnlyCfg()
  {
  }
  CsPadReadOnlyCfg(uint32_t arg__shiftTest, uint32_t arg__version)
    : _shiftTest(arg__shiftTest), _version(arg__version)
  {
  }
  uint32_t shiftTest() const { return _shiftTest; }
  uint32_t version() const { return _version; }
  static uint32_t _sizeof() { return 8; }
private:
  uint32_t	_shiftTest;
  uint32_t	_version;
};

/** @class ProtectionSystemThreshold

  
*/


class ProtectionSystemThreshold {
public:
  ProtectionSystemThreshold()
  {
  }
  ProtectionSystemThreshold(uint32_t arg__adcThreshold, uint32_t arg__pixelCountThreshold)
    : _adcThreshold(arg__adcThreshold), _pixelCountThreshold(arg__pixelCountThreshold)
  {
  }
  uint32_t adcThreshold() const { return _adcThreshold; }
  uint32_t pixelCountThreshold() const { return _pixelCountThreshold; }
  static uint32_t _sizeof() { return 8; }
private:
  uint32_t	_adcThreshold;
  uint32_t	_pixelCountThreshold;
};

/** @class CsPadGainMapCfg

  Class defining ASIC gain map.
*/


class CsPadGainMapCfg {
public:
  /** Array with the gain map for single ASIC. */
  ndarray<const uint16_t, 2> gainMap() const { return make_ndarray(&_gainMap[0][0], ColumnsPerASIC, MaxRowsPerASIC); }
  static uint32_t _sizeof() { return ((((0+(2*(ColumnsPerASIC)*(MaxRowsPerASIC)))+2)-1)/2)*2; }
private:
  uint16_t	_gainMap[ColumnsPerASIC][MaxRowsPerASIC];	/**< Array with the gain map for single ASIC. */
};

/** @class ConfigV1QuadReg

  Configuration data for single quadrant.
*/


class ConfigV1QuadReg {
public:
  ndarray<const uint32_t, 1> shiftSelect() const { return make_ndarray(&_shiftSelect[0], TwoByTwosPerQuad); }
  ndarray<const uint32_t, 1> edgeSelect() const { return make_ndarray(&_edgeSelect[0], TwoByTwosPerQuad); }
  uint32_t readClkSet() const { return _readClkSet; }
  uint32_t readClkHold() const { return _readClkHold; }
  uint32_t dataMode() const { return _dataMode; }
  uint32_t prstSel() const { return _prstSel; }
  uint32_t acqDelay() const { return _acqDelay; }
  uint32_t intTime() const { return _intTime; }
  uint32_t digDelay() const { return _digDelay; }
  uint32_t ampIdle() const { return _ampIdle; }
  uint32_t injTotal() const { return _injTotal; }
  uint32_t rowColShiftPer() const { return _rowColShiftPer; }
  /** read-only configuration */
  const CsPad::CsPadReadOnlyCfg& ro() const { return _readOnly; }
  const CsPad::CsPadDigitalPotsCfg& dp() const { return _digitalPots; }
  /** Gain map. */
  const CsPad::CsPadGainMapCfg& gm() const { return _gainMap; }
  static uint32_t _sizeof() { return ((((((((((((((((((0+(4*(TwoByTwosPerQuad)))+(4*(TwoByTwosPerQuad)))+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+(CsPad::CsPadReadOnlyCfg::_sizeof()))+(CsPad::CsPadDigitalPotsCfg::_sizeof()))+(CsPad::CsPadGainMapCfg::_sizeof()))+4)-1)/4)*4; }
private:
  uint32_t	_shiftSelect[TwoByTwosPerQuad];
  uint32_t	_edgeSelect[TwoByTwosPerQuad];
  uint32_t	_readClkSet;
  uint32_t	_readClkHold;
  uint32_t	_dataMode;
  uint32_t	_prstSel;
  uint32_t	_acqDelay;
  uint32_t	_intTime;
  uint32_t	_digDelay;
  uint32_t	_ampIdle;
  uint32_t	_injTotal;
  uint32_t	_rowColShiftPer;
  CsPad::CsPadReadOnlyCfg	_readOnly;	/**< read-only configuration */
  CsPad::CsPadDigitalPotsCfg	_digitalPots;
  CsPad::CsPadGainMapCfg	_gainMap;	/**< Gain map. */
};

/** @class ConfigV2QuadReg

  Configuration data for single quadrant.
*/


class ConfigV2QuadReg {
public:
  ndarray<const uint32_t, 1> shiftSelect() const { return make_ndarray(&_shiftSelect[0], TwoByTwosPerQuad); }
  ndarray<const uint32_t, 1> edgeSelect() const { return make_ndarray(&_edgeSelect[0], TwoByTwosPerQuad); }
  uint32_t readClkSet() const { return _readClkSet; }
  uint32_t readClkHold() const { return _readClkHold; }
  uint32_t dataMode() const { return _dataMode; }
  uint32_t prstSel() const { return _prstSel; }
  uint32_t acqDelay() const { return _acqDelay; }
  uint32_t intTime() const { return _intTime; }
  uint32_t digDelay() const { return _digDelay; }
  uint32_t ampIdle() const { return _ampIdle; }
  uint32_t injTotal() const { return _injTotal; }
  uint32_t rowColShiftPer() const { return _rowColShiftPer; }
  uint32_t ampReset() const { return _ampReset; }
  uint32_t digCount() const { return _digCount; }
  uint32_t digPeriod() const { return _digPeriod; }
  /** read-only configuration */
  const CsPad::CsPadReadOnlyCfg& ro() const { return _readOnly; }
  const CsPad::CsPadDigitalPotsCfg& dp() const { return _digitalPots; }
  /** Gain map. */
  const CsPad::CsPadGainMapCfg& gm() const { return _gainMap; }
  static uint32_t _sizeof() { return (((((((((((((((((((((0+(4*(TwoByTwosPerQuad)))+(4*(TwoByTwosPerQuad)))+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+(CsPad::CsPadReadOnlyCfg::_sizeof()))+(CsPad::CsPadDigitalPotsCfg::_sizeof()))+(CsPad::CsPadGainMapCfg::_sizeof()))+4)-1)/4)*4; }
private:
  uint32_t	_shiftSelect[TwoByTwosPerQuad];
  uint32_t	_edgeSelect[TwoByTwosPerQuad];
  uint32_t	_readClkSet;
  uint32_t	_readClkHold;
  uint32_t	_dataMode;
  uint32_t	_prstSel;
  uint32_t	_acqDelay;
  uint32_t	_intTime;
  uint32_t	_digDelay;
  uint32_t	_ampIdle;
  uint32_t	_injTotal;
  uint32_t	_rowColShiftPer;
  uint32_t	_ampReset;
  uint32_t	_digCount;
  uint32_t	_digPeriod;
  CsPad::CsPadReadOnlyCfg	_readOnly;	/**< read-only configuration */
  CsPad::CsPadDigitalPotsCfg	_digitalPots;
  CsPad::CsPadGainMapCfg	_gainMap;	/**< Gain map. */
};

/** @class ConfigV3QuadReg

  Configuration data for single quadrant.
*/


class ConfigV3QuadReg {
public:
  ndarray<const uint32_t, 1> shiftSelect() const { return make_ndarray(&_shiftSelect[0], TwoByTwosPerQuad); }
  ndarray<const uint32_t, 1> edgeSelect() const { return make_ndarray(&_edgeSelect[0], TwoByTwosPerQuad); }
  uint32_t readClkSet() const { return _readClkSet; }
  uint32_t readClkHold() const { return _readClkHold; }
  uint32_t dataMode() const { return _dataMode; }
  uint32_t prstSel() const { return _prstSel; }
  uint32_t acqDelay() const { return _acqDelay; }
  uint32_t intTime() const { return _intTime; }
  uint32_t digDelay() const { return _digDelay; }
  uint32_t ampIdle() const { return _ampIdle; }
  uint32_t injTotal() const { return _injTotal; }
  uint32_t rowColShiftPer() const { return _rowColShiftPer; }
  uint32_t ampReset() const { return _ampReset; }
  uint32_t digCount() const { return _digCount; }
  uint32_t digPeriod() const { return _digPeriod; }
  uint32_t biasTuning() const { return _biasTuning; }
  uint32_t pdpmndnmBalance() const { return _pdpmndnmBalance; }
  /** read-only configuration */
  const CsPad::CsPadReadOnlyCfg& ro() const { return _readOnly; }
  const CsPad::CsPadDigitalPotsCfg& dp() const { return _digitalPots; }
  /** Gain map. */
  const CsPad::CsPadGainMapCfg& gm() const { return _gainMap; }
  static uint32_t _sizeof() { return (((((((((((((((((((((((0+(4*(TwoByTwosPerQuad)))+(4*(TwoByTwosPerQuad)))+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+(CsPad::CsPadReadOnlyCfg::_sizeof()))+(CsPad::CsPadDigitalPotsCfg::_sizeof()))+(CsPad::CsPadGainMapCfg::_sizeof()))+4)-1)/4)*4; }
private:
  uint32_t	_shiftSelect[TwoByTwosPerQuad];
  uint32_t	_edgeSelect[TwoByTwosPerQuad];
  uint32_t	_readClkSet;
  uint32_t	_readClkHold;
  uint32_t	_dataMode;
  uint32_t	_prstSel;
  uint32_t	_acqDelay;
  uint32_t	_intTime;
  uint32_t	_digDelay;
  uint32_t	_ampIdle;
  uint32_t	_injTotal;
  uint32_t	_rowColShiftPer;
  uint32_t	_ampReset;
  uint32_t	_digCount;
  uint32_t	_digPeriod;
  uint32_t	_biasTuning;
  uint32_t	_pdpmndnmBalance;
  CsPad::CsPadReadOnlyCfg	_readOnly;	/**< read-only configuration */
  CsPad::CsPadDigitalPotsCfg	_digitalPots;
  CsPad::CsPadGainMapCfg	_gainMap;	/**< Gain map. */
};

/** @class ConfigV1

  Configuration data for complete CsPad device.
*/


class ConfigV1 {
public:
  enum { TypeId = Pds::TypeId::Id_CspadConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  uint32_t concentratorVersion() const { return _concentratorVersion; }
  uint32_t runDelay() const { return _runDelay; }
  uint32_t eventCode() const { return _eventCode; }
  uint32_t inactiveRunMode() const { return _inactiveRunMode; }
  uint32_t activeRunMode() const { return _activeRunMode; }
  uint32_t tdi() const { return _testDataIndex; }
  uint32_t payloadSize() const { return _payloadPerQuad; }
  uint32_t badAsicMask0() const { return _badAsicMask0; }
  uint32_t badAsicMask1() const { return _badAsicMask1; }
  uint32_t asicMask() const { return _AsicMask; }
  uint32_t quadMask() const { return _quadMask; }
  const CsPad::ConfigV1QuadReg& quads(uint32_t i0) const { return _quads[i0]; }
  uint32_t numAsicsRead() const;
  uint32_t numQuads() const;
  uint32_t numSect() const;
  static uint32_t _sizeof() { return ((((44+(CsPad::ConfigV1QuadReg::_sizeof()*(MaxQuadsPerSensor)))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  std::vector<int> quads_shape() const;
private:
  uint32_t	_concentratorVersion;
  uint32_t	_runDelay;
  uint32_t	_eventCode;
  uint32_t	_inactiveRunMode;
  uint32_t	_activeRunMode;
  uint32_t	_testDataIndex;
  uint32_t	_payloadPerQuad;
  uint32_t	_badAsicMask0;
  uint32_t	_badAsicMask1;
  uint32_t	_AsicMask;
  uint32_t	_quadMask;
  CsPad::ConfigV1QuadReg	_quads[MaxQuadsPerSensor];
};

/** @class ConfigV2

  Configuration data for complete CsPad device.
*/


class ConfigV2 {
public:
  enum { TypeId = Pds::TypeId::Id_CspadConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  uint32_t concentratorVersion() const { return _concentratorVersion; }
  uint32_t runDelay() const { return _runDelay; }
  uint32_t eventCode() const { return _eventCode; }
  uint32_t inactiveRunMode() const { return _inactiveRunMode; }
  uint32_t activeRunMode() const { return _activeRunMode; }
  uint32_t tdi() const { return _testDataIndex; }
  uint32_t payloadSize() const { return _payloadPerQuad; }
  uint32_t badAsicMask0() const { return _badAsicMask0; }
  uint32_t badAsicMask1() const { return _badAsicMask1; }
  uint32_t asicMask() const { return _AsicMask; }
  uint32_t quadMask() const { return _quadMask; }
  uint32_t roiMasks() const { return _roiMask; }
  const CsPad::ConfigV1QuadReg& quads(uint32_t i0) const { return _quads[i0]; }
  uint32_t numAsicsRead() const;
  /** ROI mask for given quadrant */
  uint32_t roiMask(uint32_t iq) const;
  /** Number of ASICs in given quadrant */
  uint32_t numAsicsStored(uint32_t iq) const;
  /** Total number of quadrants in setup */
  uint32_t numQuads() const;
  /** Total number of sections (2x1) in all quadrants */
  uint32_t numSect() const;
  static uint32_t _sizeof() { return ((((48+(CsPad::ConfigV1QuadReg::_sizeof()*(MaxQuadsPerSensor)))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  std::vector<int> quads_shape() const;
private:
  uint32_t	_concentratorVersion;
  uint32_t	_runDelay;
  uint32_t	_eventCode;
  uint32_t	_inactiveRunMode;
  uint32_t	_activeRunMode;
  uint32_t	_testDataIndex;
  uint32_t	_payloadPerQuad;
  uint32_t	_badAsicMask0;
  uint32_t	_badAsicMask1;
  uint32_t	_AsicMask;
  uint32_t	_quadMask;
  uint32_t	_roiMask;
  CsPad::ConfigV1QuadReg	_quads[MaxQuadsPerSensor];
};

/** @class ConfigV3

  Configuration data for complete CsPad device.
*/


class ConfigV3 {
public:
  enum { TypeId = Pds::TypeId::Id_CspadConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 3 /**< XTC type version number */ };
  uint32_t concentratorVersion() const { return _concentratorVersion; }
  uint32_t runDelay() const { return _runDelay; }
  uint32_t eventCode() const { return _eventCode; }
  ndarray<const CsPad::ProtectionSystemThreshold, 1> protectionThresholds() const { return make_ndarray(&_protectionThresholds[0], MaxQuadsPerSensor); }
  uint32_t protectionEnable() const { return _protectionEnable; }
  uint32_t inactiveRunMode() const { return _inactiveRunMode; }
  uint32_t activeRunMode() const { return _activeRunMode; }
  uint32_t tdi() const { return _testDataIndex; }
  uint32_t payloadSize() const { return _payloadPerQuad; }
  uint32_t badAsicMask0() const { return _badAsicMask0; }
  uint32_t badAsicMask1() const { return _badAsicMask1; }
  uint32_t asicMask() const { return _AsicMask; }
  uint32_t quadMask() const { return _quadMask; }
  uint32_t roiMasks() const { return _roiMask; }
  const CsPad::ConfigV1QuadReg& quads(uint32_t i0) const { return _quads[i0]; }
  uint32_t numAsicsRead() const;
  /** ROI mask for given quadrant */
  uint32_t roiMask(uint32_t iq) const;
  /** Number of ASICs in given quadrant */
  uint32_t numAsicsStored(uint32_t iq) const;
  /** Total number of quadrants in setup */
  uint32_t numQuads() const;
  /** Total number of sections (2x1) in all quadrants */
  uint32_t numSect() const;
  static uint32_t _sizeof() { return (((((((((((((((12+(CsPad::ProtectionSystemThreshold::_sizeof()*(MaxQuadsPerSensor)))+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+(CsPad::ConfigV1QuadReg::_sizeof()*(MaxQuadsPerSensor)))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  std::vector<int> quads_shape() const;
private:
  uint32_t	_concentratorVersion;
  uint32_t	_runDelay;
  uint32_t	_eventCode;
  CsPad::ProtectionSystemThreshold	_protectionThresholds[MaxQuadsPerSensor];
  uint32_t	_protectionEnable;
  uint32_t	_inactiveRunMode;
  uint32_t	_activeRunMode;
  uint32_t	_testDataIndex;
  uint32_t	_payloadPerQuad;
  uint32_t	_badAsicMask0;
  uint32_t	_badAsicMask1;
  uint32_t	_AsicMask;
  uint32_t	_quadMask;
  uint32_t	_roiMask;
  CsPad::ConfigV1QuadReg	_quads[MaxQuadsPerSensor];
};

/** @class ConfigV4

  Configuration data for complete CsPad device.
*/


class ConfigV4 {
public:
  enum { TypeId = Pds::TypeId::Id_CspadConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 4 /**< XTC type version number */ };
  uint32_t concentratorVersion() const { return _concentratorVersion; }
  uint32_t runDelay() const { return _runDelay; }
  uint32_t eventCode() const { return _eventCode; }
  ndarray<const CsPad::ProtectionSystemThreshold, 1> protectionThresholds() const { return make_ndarray(&_protectionThresholds[0], MaxQuadsPerSensor); }
  uint32_t protectionEnable() const { return _protectionEnable; }
  uint32_t inactiveRunMode() const { return _inactiveRunMode; }
  uint32_t activeRunMode() const { return _activeRunMode; }
  uint32_t tdi() const { return _testDataIndex; }
  uint32_t payloadSize() const { return _payloadPerQuad; }
  uint32_t badAsicMask0() const { return _badAsicMask0; }
  uint32_t badAsicMask1() const { return _badAsicMask1; }
  uint32_t asicMask() const { return _AsicMask; }
  uint32_t quadMask() const { return _quadMask; }
  uint32_t roiMasks() const { return _roiMask; }
  const CsPad::ConfigV2QuadReg& quads(uint32_t i0) const { return _quads[i0]; }
  uint32_t numAsicsRead() const;
  /** ROI mask for given quadrant */
  uint32_t roiMask(uint32_t iq) const;
  /** Number of ASICs in given quadrant */
  uint32_t numAsicsStored(uint32_t iq) const;
  /** Total number of quadrants in setup */
  uint32_t numQuads() const;
  /** Total number of sections (2x1) in all quadrants */
  uint32_t numSect() const;
  static uint32_t _sizeof() { return (((((((((((((((12+(CsPad::ProtectionSystemThreshold::_sizeof()*(MaxQuadsPerSensor)))+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+(CsPad::ConfigV2QuadReg::_sizeof()*(MaxQuadsPerSensor)))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  std::vector<int> quads_shape() const;
private:
  uint32_t	_concentratorVersion;
  uint32_t	_runDelay;
  uint32_t	_eventCode;
  CsPad::ProtectionSystemThreshold	_protectionThresholds[MaxQuadsPerSensor];
  uint32_t	_protectionEnable;
  uint32_t	_inactiveRunMode;
  uint32_t	_activeRunMode;
  uint32_t	_testDataIndex;
  uint32_t	_payloadPerQuad;
  uint32_t	_badAsicMask0;
  uint32_t	_badAsicMask1;
  uint32_t	_AsicMask;
  uint32_t	_quadMask;
  uint32_t	_roiMask;
  CsPad::ConfigV2QuadReg	_quads[MaxQuadsPerSensor];
};

/** @class ConfigV5

  Configuration data for complete CsPad device.
*/


class ConfigV5 {
public:
  enum { TypeId = Pds::TypeId::Id_CspadConfig /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 5 /**< XTC type version number */ };
  uint32_t concentratorVersion() const { return _concentratorVersion; }
  uint32_t runDelay() const { return _runDelay; }
  uint32_t eventCode() const { return _eventCode; }
  ndarray<const CsPad::ProtectionSystemThreshold, 1> protectionThresholds() const { return make_ndarray(&_protectionThresholds[0], MaxQuadsPerSensor); }
  uint32_t protectionEnable() const { return _protectionEnable; }
  uint32_t inactiveRunMode() const { return _inactiveRunMode; }
  uint32_t activeRunMode() const { return _activeRunMode; }
  uint32_t internalTriggerDelay() const { return _internalTriggerDelay; }
  uint32_t tdi() const { return _testDataIndex; }
  uint32_t payloadSize() const { return _payloadPerQuad; }
  uint32_t badAsicMask0() const { return _badAsicMask0; }
  uint32_t badAsicMask1() const { return _badAsicMask1; }
  uint32_t asicMask() const { return _AsicMask; }
  uint32_t quadMask() const { return _quadMask; }
  uint32_t roiMasks() const { return _roiMask; }
  const CsPad::ConfigV3QuadReg& quads(uint32_t i0) const { return _quads[i0]; }
  uint32_t numAsicsRead() const;
  /** ROI mask for given quadrant */
  uint32_t roiMask(uint32_t iq) const;
  /** Number of ASICs in given quadrant */
  uint32_t numAsicsStored(uint32_t iq) const;
  /** Total number of quadrants in setup */
  uint32_t numQuads() const;
  /** Total number of sections (2x1) in all quadrants */
  uint32_t numSect() const;
  static uint32_t _sizeof() { return ((((((((((((((((12+(CsPad::ProtectionSystemThreshold::_sizeof()*(MaxQuadsPerSensor)))+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+4)+(CsPad::ConfigV3QuadReg::_sizeof()*(MaxQuadsPerSensor)))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  std::vector<int> quads_shape() const;
private:
  uint32_t	_concentratorVersion;
  uint32_t	_runDelay;
  uint32_t	_eventCode;
  CsPad::ProtectionSystemThreshold	_protectionThresholds[MaxQuadsPerSensor];
  uint32_t	_protectionEnable;
  uint32_t	_inactiveRunMode;
  uint32_t	_activeRunMode;
  uint32_t	_internalTriggerDelay;
  uint32_t	_testDataIndex;
  uint32_t	_payloadPerQuad;
  uint32_t	_badAsicMask0;
  uint32_t	_badAsicMask1;
  uint32_t	_AsicMask;
  uint32_t	_quadMask;
  uint32_t	_roiMask;
  CsPad::ConfigV3QuadReg	_quads[MaxQuadsPerSensor];
};

/** @class ElementV1

  CsPad data from single CsPad quadrant.
*/

class ConfigV1;
class ConfigV2;
class ConfigV3;
class ConfigV4;
class ConfigV5;

class ElementV1 {
public:
  enum { Nsbtemp = 4 /**< Number of the elements in _sbtemp array. */ };
  /** Virtual channel number. */
  uint32_t virtual_channel() const { return uint32_t(this->_word0 & 0x3); }
  /** Lane number. */
  uint32_t lane() const { return uint32_t((this->_word0>>6) & 0x3); }
  uint32_t tid() const { return uint32_t((this->_word0>>8) & 0xffffff); }
  uint32_t acq_count() const { return uint32_t(this->_word1 & 0xffff); }
  uint32_t op_code() const { return uint32_t((this->_word1>>16) & 0xff); }
  /** Quadrant number. */
  uint32_t quad() const { return uint32_t((this->_word1>>24) & 0x3); }
  /** Counter incremented on every event. */
  uint32_t seq_count() const { return _seq_count; }
  uint32_t ticks() const { return _ticks; }
  uint32_t fiducials() const { return _fiducials; }
  ndarray<const uint16_t, 1> sb_temp() const { return make_ndarray(&_sbtemp[0], Nsbtemp); }
  uint32_t frame_type() const { return _frame_type; }
  ndarray<const int16_t, 3> data(const CsPad::ConfigV1& cfg) const { ptrdiff_t offset=32;
  const int16_t* data = (const int16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numAsicsRead()/2,  ColumnsPerASIC,  MaxRowsPerASIC*2); }
  ndarray<const int16_t, 3> data(const CsPad::ConfigV2& cfg) const { ptrdiff_t offset=32;
  const int16_t* data = (const int16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numAsicsRead()/2,  ColumnsPerASIC,  MaxRowsPerASIC*2); }
  ndarray<const int16_t, 3> data(const CsPad::ConfigV3& cfg) const { ptrdiff_t offset=32;
  const int16_t* data = (const int16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numAsicsRead()/2,  ColumnsPerASIC,  MaxRowsPerASIC*2); }
  ndarray<const int16_t, 3> data(const CsPad::ConfigV4& cfg) const { ptrdiff_t offset=32;
  const int16_t* data = (const int16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numAsicsRead()/2,  ColumnsPerASIC,  MaxRowsPerASIC*2); }
  ndarray<const int16_t, 3> data(const CsPad::ConfigV5& cfg) const { ptrdiff_t offset=32;
  const int16_t* data = (const int16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numAsicsRead()/2,  ColumnsPerASIC,  MaxRowsPerASIC*2); }
  /** Returns section mask for this quadrant. Mask can contain up to 8 bits in the lower byte, 
                total bit count gives the number of sections active. */
  uint32_t sectionMask(const CsPad::ConfigV1& cfg) const;
  /** Returns section mask for this quadrant. Mask can contain up to 8 bits in the lower byte, 
                total bit count gives the number of sections active. */
  uint32_t sectionMask(const CsPad::ConfigV2& cfg) const;
  /** Returns section mask for this quadrant. Mask can contain up to 8 bits in the lower byte, 
                total bit count gives the number of sections active. */
  uint32_t sectionMask(const CsPad::ConfigV3& cfg) const;
  /** Returns section mask for this quadrant. Mask can contain up to 8 bits in the lower byte, 
                total bit count gives the number of sections active. */
  uint32_t sectionMask(const CsPad::ConfigV4& cfg) const;
  /** Returns section mask for this quadrant. Mask can contain up to 8 bits in the lower byte, 
                total bit count gives the number of sections active. */
  uint32_t sectionMask(const CsPad::ConfigV5& cfg) const;
  /** Common mode value for a given section, section number can be 0 to config.numAsicsRead()/2.
                Will return 0 for data read from XTC, may be non-zero after calibration. */
  float common_mode(uint32_t section) const;
  static uint32_t _sizeof(const CsPad::ConfigV1& cfg) { return (((((((20+(2*(Nsbtemp)))+4)+(2*(cfg.numAsicsRead()/2)*( ColumnsPerASIC)*( MaxRowsPerASIC*2)))+(2*(2)))+4)-1)/4)*4; }
  static uint32_t _sizeof(const CsPad::ConfigV2& cfg) { return (((((((20+(2*(Nsbtemp)))+4)+(2*(cfg.numAsicsRead()/2)*( ColumnsPerASIC)*( MaxRowsPerASIC*2)))+(2*(2)))+4)-1)/4)*4; }
  static uint32_t _sizeof(const CsPad::ConfigV3& cfg) { return (((((((20+(2*(Nsbtemp)))+4)+(2*(cfg.numAsicsRead()/2)*( ColumnsPerASIC)*( MaxRowsPerASIC*2)))+(2*(2)))+4)-1)/4)*4; }
  static uint32_t _sizeof(const CsPad::ConfigV4& cfg) { return (((((((20+(2*(Nsbtemp)))+4)+(2*(cfg.numAsicsRead()/2)*( ColumnsPerASIC)*( MaxRowsPerASIC*2)))+(2*(2)))+4)-1)/4)*4; }
  static uint32_t _sizeof(const CsPad::ConfigV5& cfg) { return (((((((20+(2*(Nsbtemp)))+4)+(2*(cfg.numAsicsRead()/2)*( ColumnsPerASIC)*( MaxRowsPerASIC*2)))+(2*(2)))+4)-1)/4)*4; }
private:
  uint32_t	_word0;
  uint32_t	_word1;
  uint32_t	_seq_count;	/**< Counter incremented on every event. */
  uint32_t	_ticks;
  uint32_t	_fiducials;
  uint16_t	_sbtemp[Nsbtemp];
  uint32_t	_frame_type;
  //int16_t	_data[cfg.numAsicsRead()/2][ ColumnsPerASIC][ MaxRowsPerASIC*2];
  //uint16_t	_extra[2];
};

/** @class DataV1

  CsPad data from whole detector.
*/

class ConfigV1;
class ConfigV2;
class ConfigV3;
class ConfigV4;
class ConfigV5;

class DataV1 {
public:
  enum { TypeId = Pds::TypeId::Id_CspadElement /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 1 /**< XTC type version number */ };
  /** Data objects, one element per quadrant. The size of the array is determined by 
            the numQuads() method of the configuration object. */
  const CsPad::ElementV1& quads(const CsPad::ConfigV1& cfg, uint32_t i0) const { ptrdiff_t offset=0;
  const CsPad::ElementV1* memptr = (const CsPad::ElementV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof(cfg);
  return *(const CsPad::ElementV1*)((const char*)memptr + (i0)*memsize); }
  /** Data objects, one element per quadrant. The size of the array is determined by 
            the numQuads() method of the configuration object. */
  const CsPad::ElementV1& quads(const CsPad::ConfigV2& cfg, uint32_t i0) const { ptrdiff_t offset=0;
  const CsPad::ElementV1* memptr = (const CsPad::ElementV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof(cfg);
  return *(const CsPad::ElementV1*)((const char*)memptr + (i0)*memsize); }
  /** Data objects, one element per quadrant. The size of the array is determined by 
            the numQuads() method of the configuration object. */
  const CsPad::ElementV1& quads(const CsPad::ConfigV3& cfg, uint32_t i0) const { ptrdiff_t offset=0;
  const CsPad::ElementV1* memptr = (const CsPad::ElementV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof(cfg);
  return *(const CsPad::ElementV1*)((const char*)memptr + (i0)*memsize); }
  /** Data objects, one element per quadrant. The size of the array is determined by 
            the numQuads() method of the configuration object. */
  const CsPad::ElementV1& quads(const CsPad::ConfigV4& cfg, uint32_t i0) const { ptrdiff_t offset=0;
  const CsPad::ElementV1* memptr = (const CsPad::ElementV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof(cfg);
  return *(const CsPad::ElementV1*)((const char*)memptr + (i0)*memsize); }
  /** Data objects, one element per quadrant. The size of the array is determined by 
            the numQuads() method of the configuration object. */
  const CsPad::ElementV1& quads(const CsPad::ConfigV5& cfg, uint32_t i0) const { ptrdiff_t offset=0;
  const CsPad::ElementV1* memptr = (const CsPad::ElementV1*)(((const char*)this)+offset);
  size_t memsize = memptr->_sizeof(cfg);
  return *(const CsPad::ElementV1*)((const char*)memptr + (i0)*memsize); }
  static uint32_t _sizeof(const CsPad::ConfigV1& cfg) { return ((((0+(CsPad::ElementV1::_sizeof(cfg)*(cfg.numQuads())))+4)-1)/4)*4; }
  static uint32_t _sizeof(const CsPad::ConfigV2& cfg) { return ((((0+(CsPad::ElementV1::_sizeof(cfg)*(cfg.numQuads())))+4)-1)/4)*4; }
  static uint32_t _sizeof(const CsPad::ConfigV3& cfg) { return ((((0+(CsPad::ElementV1::_sizeof(cfg)*(cfg.numQuads())))+4)-1)/4)*4; }
  static uint32_t _sizeof(const CsPad::ConfigV4& cfg) { return ((((0+(CsPad::ElementV1::_sizeof(cfg)*(cfg.numQuads())))+4)-1)/4)*4; }
  static uint32_t _sizeof(const CsPad::ConfigV5& cfg) { return ((((0+(CsPad::ElementV1::_sizeof(cfg)*(cfg.numQuads())))+4)-1)/4)*4; }
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  std::vector<int> quads_shape(const CsPad::ConfigV1& cfg) const;
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  std::vector<int> quads_shape(const CsPad::ConfigV2& cfg) const;
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  std::vector<int> quads_shape(const CsPad::ConfigV3& cfg) const;
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  std::vector<int> quads_shape(const CsPad::ConfigV4& cfg) const;
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  std::vector<int> quads_shape(const CsPad::ConfigV5& cfg) const;
private:
  //CsPad::ElementV1	_quads[cfg.numQuads()];
};

/** @class ElementV2

  CsPad data from single CsPad quadrant.
*/

class ConfigV2;
class ConfigV3;
class ConfigV4;
class ConfigV5;

class ElementV2 {
public:
  enum { Nsbtemp = 4 /**< Number of the elements in _sbtemp array. */ };
  /** Virtual channel number. */
  uint32_t virtual_channel() const { return uint32_t(this->_word0 & 0x3); }
  /** Lane number. */
  uint32_t lane() const { return uint32_t((this->_word0>>6) & 0x3); }
  uint32_t tid() const { return uint32_t((this->_word0>>8) & 0xffffff); }
  uint32_t acq_count() const { return uint32_t(this->_word1 & 0xffff); }
  uint32_t op_code() const { return uint32_t((this->_word1>>16) & 0xff); }
  /** Quadrant number. */
  uint32_t quad() const { return uint32_t((this->_word1>>24) & 0x3); }
  uint32_t seq_count() const { return _seq_count; }
  uint32_t ticks() const { return _ticks; }
  uint32_t fiducials() const { return _fiducials; }
  ndarray<const uint16_t, 1> sb_temp() const { return make_ndarray(&_sbtemp[0], Nsbtemp); }
  uint32_t frame_type() const { return _frame_type; }
  ndarray<const int16_t, 3> data(const CsPad::ConfigV2& cfg) const { ptrdiff_t offset=32;
  const int16_t* data = (const int16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numAsicsStored(this->quad())/2,  ColumnsPerASIC,  MaxRowsPerASIC*2); }
  ndarray<const int16_t, 3> data(const CsPad::ConfigV3& cfg) const { ptrdiff_t offset=32;
  const int16_t* data = (const int16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numAsicsStored(this->quad())/2,  ColumnsPerASIC,  MaxRowsPerASIC*2); }
  ndarray<const int16_t, 3> data(const CsPad::ConfigV4& cfg) const { ptrdiff_t offset=32;
  const int16_t* data = (const int16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numAsicsStored(this->quad())/2,  ColumnsPerASIC,  MaxRowsPerASIC*2); }
  ndarray<const int16_t, 3> data(const CsPad::ConfigV5& cfg) const { ptrdiff_t offset=32;
  const int16_t* data = (const int16_t*)(((char*)this)+offset);
  return make_ndarray(data, cfg.numAsicsStored(this->quad())/2,  ColumnsPerASIC,  MaxRowsPerASIC*2); }
  /** Returns section mask for this quadrant. Mask can contain up to 8 bits in the lower byte, 
                total bit count gives the number of sections active. */
  uint32_t sectionMask(const CsPad::ConfigV2& cfg) const;
  /** Returns section mask for this quadrant. Mask can contain up to 8 bits in the lower byte, 
                total bit count gives the number of sections active. */
  uint32_t sectionMask(const CsPad::ConfigV3& cfg) const;
  /** Returns section mask for this quadrant. Mask can contain up to 8 bits in the lower byte, 
                total bit count gives the number of sections active. */
  uint32_t sectionMask(const CsPad::ConfigV4& cfg) const;
  /** Returns section mask for this quadrant. Mask can contain up to 8 bits in the lower byte, 
                total bit count gives the number of sections active. */
  uint32_t sectionMask(const CsPad::ConfigV5& cfg) const;
  /** Common mode value for a given section, section number can be 0 to config.numSect().
                Will return 0 for data read from XTC, may be non-zero after calibration. */
  float common_mode(uint32_t section) const;
  uint32_t _sizeof(const CsPad::ConfigV2& cfg) const { return (((((((20+(2*(Nsbtemp)))+4)+(2*(cfg.numAsicsStored(this->quad())/2)*( ColumnsPerASIC)*( MaxRowsPerASIC*2)))+(2*(2)))+4)-1)/4)*4; }
  uint32_t _sizeof(const CsPad::ConfigV3& cfg) const { return (((((((20+(2*(Nsbtemp)))+4)+(2*(cfg.numAsicsStored(this->quad())/2)*( ColumnsPerASIC)*( MaxRowsPerASIC*2)))+(2*(2)))+4)-1)/4)*4; }
  uint32_t _sizeof(const CsPad::ConfigV4& cfg) const { return (((((((20+(2*(Nsbtemp)))+4)+(2*(cfg.numAsicsStored(this->quad())/2)*( ColumnsPerASIC)*( MaxRowsPerASIC*2)))+(2*(2)))+4)-1)/4)*4; }
  uint32_t _sizeof(const CsPad::ConfigV5& cfg) const { return (((((((20+(2*(Nsbtemp)))+4)+(2*(cfg.numAsicsStored(this->quad())/2)*( ColumnsPerASIC)*( MaxRowsPerASIC*2)))+(2*(2)))+4)-1)/4)*4; }
private:
  uint32_t	_word0;
  uint32_t	_word1;
  uint32_t	_seq_count;
  uint32_t	_ticks;
  uint32_t	_fiducials;
  uint16_t	_sbtemp[Nsbtemp];
  uint32_t	_frame_type;
  //int16_t	_data[cfg.numAsicsStored(this->quad())/2][ ColumnsPerASIC][ MaxRowsPerASIC*2];
  //uint16_t	_extra[2];
};

/** @class DataV2

  CsPad data from whole detector.
*/

class ConfigV2;
class ConfigV3;
class ConfigV4;
class ConfigV5;

class DataV2 {
public:
  enum { TypeId = Pds::TypeId::Id_CspadElement /**< XTC type ID value (from Pds::TypeId class) */ };
  enum { Version = 2 /**< XTC type version number */ };
  /** Data objects, one element per quadrant. The size of the array is determined by 
            the numQuads() method of the configuration object. */
  const CsPad::ElementV2& quads(const CsPad::ConfigV2& cfg, uint32_t i0) const { const char* memptr = ((const char*)this)+0;
  for (uint32_t i=0; i != i0; ++ i) {
    memptr += ((const CsPad::ElementV2*)memptr)->_sizeof(cfg);
  }
  return *(const CsPad::ElementV2*)(memptr); }
  /** Data objects, one element per quadrant. The size of the array is determined by 
            the numQuads() method of the configuration object. */
  const CsPad::ElementV2& quads(const CsPad::ConfigV3& cfg, uint32_t i0) const { const char* memptr = ((const char*)this)+0;
  for (uint32_t i=0; i != i0; ++ i) {
    memptr += ((const CsPad::ElementV2*)memptr)->_sizeof(cfg);
  }
  return *(const CsPad::ElementV2*)(memptr); }
  /** Data objects, one element per quadrant. The size of the array is determined by 
            the numQuads() method of the configuration object. */
  const CsPad::ElementV2& quads(const CsPad::ConfigV4& cfg, uint32_t i0) const { const char* memptr = ((const char*)this)+0;
  for (uint32_t i=0; i != i0; ++ i) {
    memptr += ((const CsPad::ElementV2*)memptr)->_sizeof(cfg);
  }
  return *(const CsPad::ElementV2*)(memptr); }
  /** Data objects, one element per quadrant. The size of the array is determined by 
            the numQuads() method of the configuration object. */
  const CsPad::ElementV2& quads(const CsPad::ConfigV5& cfg, uint32_t i0) const { const char* memptr = ((const char*)this)+0;
  for (uint32_t i=0; i != i0; ++ i) {
    memptr += ((const CsPad::ElementV2*)memptr)->_sizeof(cfg);
  }
  return *(const CsPad::ElementV2*)(memptr); }
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  std::vector<int> quads_shape(const CsPad::ConfigV2& cfg) const;
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  std::vector<int> quads_shape(const CsPad::ConfigV3& cfg) const;
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  std::vector<int> quads_shape(const CsPad::ConfigV4& cfg) const;
  /** Method which returns the shape (dimensions) of the data returned by quads() method. */
  std::vector<int> quads_shape(const CsPad::ConfigV5& cfg) const;
private:
  //CsPad::ElementV2	_quads[cfg.numQuads()];
};
} // namespace CsPad
} // namespace PsddlPds
#endif // PSDDLPDS_CSPAD_DDL_H
