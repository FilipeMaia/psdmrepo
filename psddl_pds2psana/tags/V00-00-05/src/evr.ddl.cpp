
// *** Do not edit this file, it is auto-generated ***

#include "psddl_pds2psana/evr.ddl.h"

#include <cstddef>

#include <stdexcept>

namespace psddl_pds2psana {
namespace EvrData {
Psana::EvrData::PulseConfig pds_to_psana(PsddlPds::EvrData::PulseConfig pds)
{
  return Psana::EvrData::PulseConfig(pds.pulse(), pds._input_control_value(), pds._output_control_value(), pds.prescale(), pds.delay(), pds.width());
}

Psana::EvrData::PulseConfigV3 pds_to_psana(PsddlPds::EvrData::PulseConfigV3 pds)
{
  return Psana::EvrData::PulseConfigV3(pds.pulseId(), pds.polarity(), pds.prescale(), pds.delay(), pds.width());
}

Psana::EvrData::EventCodeV3 pds_to_psana(PsddlPds::EvrData::EventCodeV3 pds)
{
  return Psana::EvrData::EventCodeV3(pds.code(), pds._u16MaskEventAttr_value(), pds.maskTrigger(), pds.maskSet(), pds.maskClear());
}

Psana::EvrData::EventCodeV4 pds_to_psana(PsddlPds::EvrData::EventCodeV4 pds)
{
  return Psana::EvrData::EventCodeV4(pds.code(), pds._u16MaskEventAttr_value(), pds.reportDelay(), pds.reportWidth(), pds.maskTrigger(), pds.maskSet(), pds.maskClear());
}

Psana::EvrData::EventCodeV5 pds_to_psana(PsddlPds::EvrData::EventCodeV5 pds)
{
  return Psana::EvrData::EventCodeV5(pds.code(), pds._u16MaskEventAttr_value(), pds.reportDelay(), pds.reportWidth(), pds.maskTrigger(), pds.maskSet(), pds.maskClear(), pds.desc());
}

Psana::EvrData::OutputMap::Source pds_to_psana(PsddlPds::EvrData::OutputMap::Source e)
{
  return Psana::EvrData::OutputMap::Source(e);
}

Psana::EvrData::OutputMap::Conn pds_to_psana(PsddlPds::EvrData::OutputMap::Conn e)
{
  return Psana::EvrData::OutputMap::Conn(e);
}

Psana::EvrData::OutputMap pds_to_psana(PsddlPds::EvrData::OutputMap pds)
{
  return Psana::EvrData::OutputMap(pds.value());
}

ConfigV1::ConfigV1(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::EvrData::ConfigV1()
  , m_xtcObj(xtcPtr)
{
  {
    const std::vector<int>& dims = xtcPtr->_pulses_shape();
    _pulses.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      _pulses.push_back(psddl_pds2psana::EvrData::pds_to_psana(xtcPtr->pulses(i0)));
    }
  }
  {
    const std::vector<int>& dims = xtcPtr->_output_maps_shape();
    _output_maps.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      _output_maps.push_back(psddl_pds2psana::EvrData::pds_to_psana(xtcPtr->output_maps(i0)));
    }
  }
}
ConfigV1::~ConfigV1()
{
}


uint32_t ConfigV1::npulses() const { return m_xtcObj->npulses(); }

uint32_t ConfigV1::noutputs() const { return m_xtcObj->noutputs(); }

const Psana::EvrData::PulseConfig& ConfigV1::pulses(uint32_t i0) const { return _pulses[i0]; }

const Psana::EvrData::OutputMap& ConfigV1::output_maps(uint32_t i0) const { return _output_maps[i0]; }
std::vector<int> ConfigV1::_pulses_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_pulses.size());
  return shape;
}

std::vector<int> ConfigV1::_output_maps_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_output_maps.size());
  return shape;
}

Psana::EvrData::ConfigV2::RateCode pds_to_psana(PsddlPds::EvrData::ConfigV2::RateCode e)
{
  return Psana::EvrData::ConfigV2::RateCode(e);
}

Psana::EvrData::ConfigV2::BeamCode pds_to_psana(PsddlPds::EvrData::ConfigV2::BeamCode e)
{
  return Psana::EvrData::ConfigV2::BeamCode(e);
}

ConfigV2::ConfigV2(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::EvrData::ConfigV2()
  , m_xtcObj(xtcPtr)
{
  {
    const std::vector<int>& dims = xtcPtr->_pulses_shape();
    _pulses.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      _pulses.push_back(psddl_pds2psana::EvrData::pds_to_psana(xtcPtr->pulses(i0)));
    }
  }
  {
    const std::vector<int>& dims = xtcPtr->_output_maps_shape();
    _output_maps.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      _output_maps.push_back(psddl_pds2psana::EvrData::pds_to_psana(xtcPtr->output_maps(i0)));
    }
  }
}
ConfigV2::~ConfigV2()
{
}


uint32_t ConfigV2::opcode() const { return m_xtcObj->opcode(); }

uint32_t ConfigV2::npulses() const { return m_xtcObj->npulses(); }

uint32_t ConfigV2::noutputs() const { return m_xtcObj->noutputs(); }

const Psana::EvrData::PulseConfig& ConfigV2::pulses(uint32_t i0) const { return _pulses[i0]; }

const Psana::EvrData::OutputMap& ConfigV2::output_maps(uint32_t i0) const { return _output_maps[i0]; }

Psana::EvrData::ConfigV2::BeamCode ConfigV2::beam() const { return pds_to_psana(m_xtcObj->beam()); }

Psana::EvrData::ConfigV2::RateCode ConfigV2::rate() const { return pds_to_psana(m_xtcObj->rate()); }
std::vector<int> ConfigV2::_pulses_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_pulses.size());
  return shape;
}

std::vector<int> ConfigV2::_output_maps_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_output_maps.size());
  return shape;
}

ConfigV3::ConfigV3(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::EvrData::ConfigV3()
  , m_xtcObj(xtcPtr)
{
  {
    const std::vector<int>& dims = xtcPtr->_eventcodes_shape();
    _eventcodes.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      _eventcodes.push_back(psddl_pds2psana::EvrData::pds_to_psana(xtcPtr->eventcodes(i0)));
    }
  }
  {
    const std::vector<int>& dims = xtcPtr->_pulses_shape();
    _pulses.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      _pulses.push_back(psddl_pds2psana::EvrData::pds_to_psana(xtcPtr->pulses(i0)));
    }
  }
  {
    const std::vector<int>& dims = xtcPtr->_output_maps_shape();
    _output_maps.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      _output_maps.push_back(psddl_pds2psana::EvrData::pds_to_psana(xtcPtr->output_maps(i0)));
    }
  }
}
ConfigV3::~ConfigV3()
{
}


uint32_t ConfigV3::neventcodes() const { return m_xtcObj->neventcodes(); }

uint32_t ConfigV3::npulses() const { return m_xtcObj->npulses(); }

uint32_t ConfigV3::noutputs() const { return m_xtcObj->noutputs(); }

const Psana::EvrData::EventCodeV3& ConfigV3::eventcodes(uint32_t i0) const { return _eventcodes[i0]; }

const Psana::EvrData::PulseConfigV3& ConfigV3::pulses(uint32_t i0) const { return _pulses[i0]; }

const Psana::EvrData::OutputMap& ConfigV3::output_maps(uint32_t i0) const { return _output_maps[i0]; }
std::vector<int> ConfigV3::_eventcodes_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_eventcodes.size());
  return shape;
}

std::vector<int> ConfigV3::_pulses_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_pulses.size());
  return shape;
}

std::vector<int> ConfigV3::_output_maps_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_output_maps.size());
  return shape;
}

ConfigV4::ConfigV4(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::EvrData::ConfigV4()
  , m_xtcObj(xtcPtr)
{
  {
    const std::vector<int>& dims = xtcPtr->_eventcodes_shape();
    _eventcodes.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      _eventcodes.push_back(psddl_pds2psana::EvrData::pds_to_psana(xtcPtr->eventcodes(i0)));
    }
  }
  {
    const std::vector<int>& dims = xtcPtr->_pulses_shape();
    _pulses.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      _pulses.push_back(psddl_pds2psana::EvrData::pds_to_psana(xtcPtr->pulses(i0)));
    }
  }
  {
    const std::vector<int>& dims = xtcPtr->_output_maps_shape();
    _output_maps.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      _output_maps.push_back(psddl_pds2psana::EvrData::pds_to_psana(xtcPtr->output_maps(i0)));
    }
  }
}
ConfigV4::~ConfigV4()
{
}


uint32_t ConfigV4::neventcodes() const { return m_xtcObj->neventcodes(); }

uint32_t ConfigV4::npulses() const { return m_xtcObj->npulses(); }

uint32_t ConfigV4::noutputs() const { return m_xtcObj->noutputs(); }

const Psana::EvrData::EventCodeV4& ConfigV4::eventcodes(uint32_t i0) const { return _eventcodes[i0]; }

const Psana::EvrData::PulseConfigV3& ConfigV4::pulses(uint32_t i0) const { return _pulses[i0]; }

const Psana::EvrData::OutputMap& ConfigV4::output_maps(uint32_t i0) const { return _output_maps[i0]; }
std::vector<int> ConfigV4::_eventcodes_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_eventcodes.size());
  return shape;
}

std::vector<int> ConfigV4::_pulses_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_pulses.size());
  return shape;
}

std::vector<int> ConfigV4::_output_maps_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_output_maps.size());
  return shape;
}

Psana::EvrData::SequencerEntry pds_to_psana(PsddlPds::EvrData::SequencerEntry pds)
{
  return Psana::EvrData::SequencerEntry(pds.eventcode(), pds.delay());
}

Psana::EvrData::SequencerConfigV1::Source pds_to_psana(PsddlPds::EvrData::SequencerConfigV1::Source e)
{
  return Psana::EvrData::SequencerConfigV1::Source(e);
}

SequencerConfigV1::SequencerConfigV1(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::EvrData::SequencerConfigV1()
  , m_xtcObj(xtcPtr)
{
  {
    const std::vector<int>& dims = xtcPtr->_entries_shape();
    _entries.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      _entries.push_back(psddl_pds2psana::EvrData::pds_to_psana(xtcPtr->entries(i0)));
    }
  }
}
SequencerConfigV1::~SequencerConfigV1()
{
}


Psana::EvrData::SequencerConfigV1::Source SequencerConfigV1::sync_source() const { return pds_to_psana(m_xtcObj->sync_source()); }

Psana::EvrData::SequencerConfigV1::Source SequencerConfigV1::beam_source() const { return pds_to_psana(m_xtcObj->beam_source()); }

uint32_t SequencerConfigV1::length() const { return m_xtcObj->length(); }

uint32_t SequencerConfigV1::cycles() const { return m_xtcObj->cycles(); }

const Psana::EvrData::SequencerEntry& SequencerConfigV1::entries(uint32_t i0) const { return _entries[i0]; }
std::vector<int> SequencerConfigV1::_entries_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_entries.size());
  return shape;
}

ConfigV5::ConfigV5(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::EvrData::ConfigV5()
  , m_xtcObj(xtcPtr)
  , _seq_config(boost::shared_ptr<const PsddlPds::EvrData::SequencerConfigV1>(xtcPtr, &xtcPtr->seq_config()))
{
  {
    const std::vector<int>& dims = xtcPtr->_eventcodes_shape();
    _eventcodes.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      _eventcodes.push_back(psddl_pds2psana::EvrData::pds_to_psana(xtcPtr->eventcodes(i0)));
    }
  }
  {
    const std::vector<int>& dims = xtcPtr->_pulses_shape();
    _pulses.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      _pulses.push_back(psddl_pds2psana::EvrData::pds_to_psana(xtcPtr->pulses(i0)));
    }
  }
  {
    const std::vector<int>& dims = xtcPtr->_output_maps_shape();
    _output_maps.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      _output_maps.push_back(psddl_pds2psana::EvrData::pds_to_psana(xtcPtr->output_maps(i0)));
    }
  }
}
ConfigV5::~ConfigV5()
{
}


uint32_t ConfigV5::neventcodes() const { return m_xtcObj->neventcodes(); }

uint32_t ConfigV5::npulses() const { return m_xtcObj->npulses(); }

uint32_t ConfigV5::noutputs() const { return m_xtcObj->noutputs(); }

const Psana::EvrData::EventCodeV4& ConfigV5::eventcodes(uint32_t i0) const { return _eventcodes[i0]; }

const Psana::EvrData::PulseConfigV3& ConfigV5::pulses(uint32_t i0) const { return _pulses[i0]; }

const Psana::EvrData::OutputMap& ConfigV5::output_maps(uint32_t i0) const { return _output_maps[i0]; }

const Psana::EvrData::SequencerConfigV1& ConfigV5::seq_config() const { return _seq_config; }
std::vector<int> ConfigV5::_eventcodes_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_eventcodes.size());
  return shape;
}

std::vector<int> ConfigV5::_pulses_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_pulses.size());
  return shape;
}

std::vector<int> ConfigV5::_output_maps_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_output_maps.size());
  return shape;
}

Psana::EvrData::FIFOEvent pds_to_psana(PsddlPds::EvrData::FIFOEvent pds)
{
  return Psana::EvrData::FIFOEvent(pds.timestampHigh(), pds.timestampLow(), pds.eventCode());
}

DataV3::DataV3(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::EvrData::DataV3()
  , m_xtcObj(xtcPtr)
{
  {
    const std::vector<int>& dims = xtcPtr->_fifoEvents_shape();
    _fifoEvents.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      _fifoEvents.push_back(psddl_pds2psana::EvrData::pds_to_psana(xtcPtr->fifoEvents(i0)));
    }
  }
}
DataV3::~DataV3()
{
}


uint32_t DataV3::numFifoEvents() const { return m_xtcObj->numFifoEvents(); }

const Psana::EvrData::FIFOEvent& DataV3::fifoEvents(uint32_t i0) const { return _fifoEvents[i0]; }
std::vector<int> DataV3::_fifoEvents_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_fifoEvents.size());
  return shape;
}

IOChannel::IOChannel(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::EvrData::IOChannel()
  , m_xtcObj(xtcPtr)
{
  {
    const std::vector<int>& dims = xtcPtr->_info_shape();
    _info.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      _info.push_back(xtcPtr->infos(i0));
    }
  }
}
IOChannel::~IOChannel()
{
}


const char* IOChannel::name() const { return m_xtcObj->name(); }

uint32_t IOChannel::ninfo() const { return m_xtcObj->ninfo(); }

const Pds::DetInfo& IOChannel::infos(uint32_t i0) const { return _info[i0]; }

std::vector<int> IOChannel::_name_shape() const { return m_xtcObj->_name_shape(); }
std::vector<int> IOChannel::_info_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_info.size());
  return shape;
}

IOConfigV1::IOConfigV1(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::EvrData::IOConfigV1()
  , m_xtcObj(xtcPtr)
{
  {
    const std::vector<int>& dims = xtcPtr->_channels_shape();
    _channels.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      const PsddlPds::EvrData::IOChannel& d = xtcPtr->channels(i0);
      boost::shared_ptr<const PsddlPds::EvrData::IOChannel> dPtr(m_xtcObj, &d);
      _channels.push_back(psddl_pds2psana::EvrData::IOChannel(dPtr));
    }
  }
}
IOConfigV1::~IOConfigV1()
{
}


uint16_t IOConfigV1::nchannels() const { return m_xtcObj->nchannels(); }

const Psana::EvrData::IOChannel& IOConfigV1::channels(uint32_t i0) const { return _channels[i0]; }

Psana::EvrData::OutputMap::Conn IOConfigV1::conn() const { return pds_to_psana(m_xtcObj->conn()); }
std::vector<int> IOConfigV1::_channels_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_channels.size());
  return shape;
}

} // namespace EvrData
} // namespace psddl_pds2psana
