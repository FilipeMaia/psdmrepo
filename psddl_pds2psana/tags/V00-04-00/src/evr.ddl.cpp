
// *** Do not edit this file, it is auto-generated ***

#include "psddl_pds2psana/evr.ddl.h"

#include <cstddef>

#include <stdexcept>

namespace psddl_pds2psana {
namespace EvrData {
Psana::EvrData::PulseConfig pds_to_psana(PsddlPds::EvrData::PulseConfig pds)
{
  return Psana::EvrData::PulseConfig(pds.pulse(), pds.bf_trigger(), pds.bf_set(), pds.bf_clear(), pds.polarity(), pds.map_set_enable(), pds.map_reset_enable(), pds.map_trigger_enable(), pds.prescale(), pds.delay(), pds.width());
}

Psana::EvrData::PulseConfigV3 pds_to_psana(PsddlPds::EvrData::PulseConfigV3 pds)
{
  return Psana::EvrData::PulseConfigV3(pds.pulseId(), pds.polarity(), pds.prescale(), pds.delay(), pds.width());
}

Psana::EvrData::EventCodeV3 pds_to_psana(PsddlPds::EvrData::EventCodeV3 pds)
{
  return Psana::EvrData::EventCodeV3(pds.code(), pds.isReadout(), pds.isTerminator(), pds.maskTrigger(), pds.maskSet(), pds.maskClear());
}

Psana::EvrData::EventCodeV4 pds_to_psana(PsddlPds::EvrData::EventCodeV4 pds)
{
  return Psana::EvrData::EventCodeV4(pds.code(), pds.isReadout(), pds.isTerminator(), pds.reportDelay(), pds.reportWidth(), pds.maskTrigger(), pds.maskSet(), pds.maskClear());
}

Psana::EvrData::EventCodeV5 pds_to_psana(PsddlPds::EvrData::EventCodeV5 pds)
{
  return Psana::EvrData::EventCodeV5(pds.code(), pds.isReadout(), pds.isTerminator(), pds.isLatch(), pds.reportDelay(), pds.reportWidth(), pds.maskTrigger(), pds.maskSet(), pds.maskClear(), pds.desc());
}

Psana::EvrData::OutputMap::Source pds_to_psana(PsddlPds::EvrData::OutputMap::Source e)
{
  return Psana::EvrData::OutputMap::Source(e);
}

Psana::EvrData::OutputMap::Conn pds_to_psana(PsddlPds::EvrData::OutputMap::Conn e)
{
  return Psana::EvrData::OutputMap::Conn(e);
}

Psana::EvrData::OutputMap pds_to_psana(PsddlPds::EvrData::OutputMap pds)
{
  return Psana::EvrData::OutputMap(pds_to_psana(pds.source()), pds.source_id(), pds_to_psana(pds.conn()), pds.conn_id());
}

ConfigV1::ConfigV1(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::EvrData::ConfigV1()
  , m_xtcObj(xtcPtr)
{
  {
    typedef ndarray<PsddlPds::EvrData::PulseConfig, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->pulses();
    _pulses_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::const_iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _pulses_ndarray_storage_.push_back(psddl_pds2psana::EvrData::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _pulses_ndarray_shape_);
  }
  {
    typedef ndarray<PsddlPds::EvrData::OutputMap, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->output_maps();
    _output_maps_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::const_iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _output_maps_ndarray_storage_.push_back(psddl_pds2psana::EvrData::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _output_maps_ndarray_shape_);
  }
}
ConfigV1::~ConfigV1()
{
}


uint32_t ConfigV1::npulses() const { return m_xtcObj->npulses(); }

uint32_t ConfigV1::noutputs() const { return m_xtcObj->noutputs(); }

ndarray<Psana::EvrData::PulseConfig, 1> ConfigV1::pulses() const { return ndarray<Psana::EvrData::PulseConfig, 1>(&_pulses_ndarray_storage_[0], _pulses_ndarray_shape_); }

ndarray<Psana::EvrData::OutputMap, 1> ConfigV1::output_maps() const { return ndarray<Psana::EvrData::OutputMap, 1>(&_output_maps_ndarray_storage_[0], _output_maps_ndarray_shape_); }
Psana::EvrData::ConfigV2::RateCode pds_to_psana(PsddlPds::EvrData::ConfigV2::RateCode e)
{
  return Psana::EvrData::ConfigV2::RateCode(e);
}

Psana::EvrData::ConfigV2::BeamCode pds_to_psana(PsddlPds::EvrData::ConfigV2::BeamCode e)
{
  return Psana::EvrData::ConfigV2::BeamCode(e);
}

ConfigV2::ConfigV2(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::EvrData::ConfigV2()
  , m_xtcObj(xtcPtr)
{
  {
    typedef ndarray<PsddlPds::EvrData::PulseConfig, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->pulses();
    _pulses_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::const_iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _pulses_ndarray_storage_.push_back(psddl_pds2psana::EvrData::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _pulses_ndarray_shape_);
  }
  {
    typedef ndarray<PsddlPds::EvrData::OutputMap, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->output_maps();
    _output_maps_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::const_iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _output_maps_ndarray_storage_.push_back(psddl_pds2psana::EvrData::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _output_maps_ndarray_shape_);
  }
}
ConfigV2::~ConfigV2()
{
}


uint32_t ConfigV2::opcode() const { return m_xtcObj->opcode(); }

uint32_t ConfigV2::npulses() const { return m_xtcObj->npulses(); }

uint32_t ConfigV2::noutputs() const { return m_xtcObj->noutputs(); }

ndarray<Psana::EvrData::PulseConfig, 1> ConfigV2::pulses() const { return ndarray<Psana::EvrData::PulseConfig, 1>(&_pulses_ndarray_storage_[0], _pulses_ndarray_shape_); }

ndarray<Psana::EvrData::OutputMap, 1> ConfigV2::output_maps() const { return ndarray<Psana::EvrData::OutputMap, 1>(&_output_maps_ndarray_storage_[0], _output_maps_ndarray_shape_); }

Psana::EvrData::ConfigV2::BeamCode ConfigV2::beam() const { return pds_to_psana(m_xtcObj->beam()); }

Psana::EvrData::ConfigV2::RateCode ConfigV2::rate() const { return pds_to_psana(m_xtcObj->rate()); }
ConfigV3::ConfigV3(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::EvrData::ConfigV3()
  , m_xtcObj(xtcPtr)
{
  {
    typedef ndarray<PsddlPds::EvrData::EventCodeV3, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->eventcodes();
    _eventcodes_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::const_iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _eventcodes_ndarray_storage_.push_back(psddl_pds2psana::EvrData::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _eventcodes_ndarray_shape_);
  }
  {
    typedef ndarray<PsddlPds::EvrData::PulseConfigV3, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->pulses();
    _pulses_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::const_iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _pulses_ndarray_storage_.push_back(psddl_pds2psana::EvrData::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _pulses_ndarray_shape_);
  }
  {
    typedef ndarray<PsddlPds::EvrData::OutputMap, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->output_maps();
    _output_maps_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::const_iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _output_maps_ndarray_storage_.push_back(psddl_pds2psana::EvrData::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _output_maps_ndarray_shape_);
  }
}
ConfigV3::~ConfigV3()
{
}


uint32_t ConfigV3::neventcodes() const { return m_xtcObj->neventcodes(); }

uint32_t ConfigV3::npulses() const { return m_xtcObj->npulses(); }

uint32_t ConfigV3::noutputs() const { return m_xtcObj->noutputs(); }

ndarray<Psana::EvrData::EventCodeV3, 1> ConfigV3::eventcodes() const { return ndarray<Psana::EvrData::EventCodeV3, 1>(&_eventcodes_ndarray_storage_[0], _eventcodes_ndarray_shape_); }

ndarray<Psana::EvrData::PulseConfigV3, 1> ConfigV3::pulses() const { return ndarray<Psana::EvrData::PulseConfigV3, 1>(&_pulses_ndarray_storage_[0], _pulses_ndarray_shape_); }

ndarray<Psana::EvrData::OutputMap, 1> ConfigV3::output_maps() const { return ndarray<Psana::EvrData::OutputMap, 1>(&_output_maps_ndarray_storage_[0], _output_maps_ndarray_shape_); }
ConfigV4::ConfigV4(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::EvrData::ConfigV4()
  , m_xtcObj(xtcPtr)
{
  {
    typedef ndarray<PsddlPds::EvrData::EventCodeV4, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->eventcodes();
    _eventcodes_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::const_iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _eventcodes_ndarray_storage_.push_back(psddl_pds2psana::EvrData::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _eventcodes_ndarray_shape_);
  }
  {
    typedef ndarray<PsddlPds::EvrData::PulseConfigV3, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->pulses();
    _pulses_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::const_iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _pulses_ndarray_storage_.push_back(psddl_pds2psana::EvrData::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _pulses_ndarray_shape_);
  }
  {
    typedef ndarray<PsddlPds::EvrData::OutputMap, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->output_maps();
    _output_maps_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::const_iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _output_maps_ndarray_storage_.push_back(psddl_pds2psana::EvrData::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _output_maps_ndarray_shape_);
  }
}
ConfigV4::~ConfigV4()
{
}


uint32_t ConfigV4::neventcodes() const { return m_xtcObj->neventcodes(); }

uint32_t ConfigV4::npulses() const { return m_xtcObj->npulses(); }

uint32_t ConfigV4::noutputs() const { return m_xtcObj->noutputs(); }

ndarray<Psana::EvrData::EventCodeV4, 1> ConfigV4::eventcodes() const { return ndarray<Psana::EvrData::EventCodeV4, 1>(&_eventcodes_ndarray_storage_[0], _eventcodes_ndarray_shape_); }

ndarray<Psana::EvrData::PulseConfigV3, 1> ConfigV4::pulses() const { return ndarray<Psana::EvrData::PulseConfigV3, 1>(&_pulses_ndarray_storage_[0], _pulses_ndarray_shape_); }

ndarray<Psana::EvrData::OutputMap, 1> ConfigV4::output_maps() const { return ndarray<Psana::EvrData::OutputMap, 1>(&_output_maps_ndarray_storage_[0], _output_maps_ndarray_shape_); }
Psana::EvrData::SequencerEntry pds_to_psana(PsddlPds::EvrData::SequencerEntry pds)
{
  return Psana::EvrData::SequencerEntry(pds.eventcode(), pds.delay());
}

Psana::EvrData::SequencerConfigV1::Source pds_to_psana(PsddlPds::EvrData::SequencerConfigV1::Source e)
{
  return Psana::EvrData::SequencerConfigV1::Source(e);
}

SequencerConfigV1::SequencerConfigV1(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::EvrData::SequencerConfigV1()
  , m_xtcObj(xtcPtr)
{
  {
    typedef ndarray<PsddlPds::EvrData::SequencerEntry, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->entries();
    _entries_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::const_iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _entries_ndarray_storage_.push_back(psddl_pds2psana::EvrData::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _entries_ndarray_shape_);
  }
}
SequencerConfigV1::~SequencerConfigV1()
{
}


Psana::EvrData::SequencerConfigV1::Source SequencerConfigV1::sync_source() const { return pds_to_psana(m_xtcObj->sync_source()); }

Psana::EvrData::SequencerConfigV1::Source SequencerConfigV1::beam_source() const { return pds_to_psana(m_xtcObj->beam_source()); }

uint32_t SequencerConfigV1::length() const { return m_xtcObj->length(); }

uint32_t SequencerConfigV1::cycles() const { return m_xtcObj->cycles(); }

ndarray<Psana::EvrData::SequencerEntry, 1> SequencerConfigV1::entries() const { return ndarray<Psana::EvrData::SequencerEntry, 1>(&_entries_ndarray_storage_[0], _entries_ndarray_shape_); }
ConfigV5::ConfigV5(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::EvrData::ConfigV5()
  , m_xtcObj(xtcPtr)
  , _seq_config(boost::shared_ptr<const PsddlPds::EvrData::SequencerConfigV1>(xtcPtr, &xtcPtr->seq_config()))
{
  {
    typedef ndarray<PsddlPds::EvrData::EventCodeV5, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->eventcodes();
    _eventcodes_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::const_iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _eventcodes_ndarray_storage_.push_back(psddl_pds2psana::EvrData::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _eventcodes_ndarray_shape_);
  }
  {
    typedef ndarray<PsddlPds::EvrData::PulseConfigV3, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->pulses();
    _pulses_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::const_iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _pulses_ndarray_storage_.push_back(psddl_pds2psana::EvrData::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _pulses_ndarray_shape_);
  }
  {
    typedef ndarray<PsddlPds::EvrData::OutputMap, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->output_maps();
    _output_maps_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::const_iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _output_maps_ndarray_storage_.push_back(psddl_pds2psana::EvrData::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _output_maps_ndarray_shape_);
  }
}
ConfigV5::~ConfigV5()
{
}


uint32_t ConfigV5::neventcodes() const { return m_xtcObj->neventcodes(); }

uint32_t ConfigV5::npulses() const { return m_xtcObj->npulses(); }

uint32_t ConfigV5::noutputs() const { return m_xtcObj->noutputs(); }

ndarray<Psana::EvrData::EventCodeV5, 1> ConfigV5::eventcodes() const { return ndarray<Psana::EvrData::EventCodeV5, 1>(&_eventcodes_ndarray_storage_[0], _eventcodes_ndarray_shape_); }

ndarray<Psana::EvrData::PulseConfigV3, 1> ConfigV5::pulses() const { return ndarray<Psana::EvrData::PulseConfigV3, 1>(&_pulses_ndarray_storage_[0], _pulses_ndarray_shape_); }

ndarray<Psana::EvrData::OutputMap, 1> ConfigV5::output_maps() const { return ndarray<Psana::EvrData::OutputMap, 1>(&_output_maps_ndarray_storage_[0], _output_maps_ndarray_shape_); }

const Psana::EvrData::SequencerConfigV1& ConfigV5::seq_config() const { return _seq_config; }
Psana::EvrData::FIFOEvent pds_to_psana(PsddlPds::EvrData::FIFOEvent pds)
{
  return Psana::EvrData::FIFOEvent(pds.timestampHigh(), pds.timestampLow(), pds.eventCode());
}

DataV3::DataV3(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::EvrData::DataV3()
  , m_xtcObj(xtcPtr)
{
  {
    typedef ndarray<PsddlPds::EvrData::FIFOEvent, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->fifoEvents();
    _fifoEvents_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::const_iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _fifoEvents_ndarray_storage_.push_back(psddl_pds2psana::EvrData::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _fifoEvents_ndarray_shape_);
  }
}
DataV3::~DataV3()
{
}


uint32_t DataV3::numFifoEvents() const { return m_xtcObj->numFifoEvents(); }

ndarray<Psana::EvrData::FIFOEvent, 1> DataV3::fifoEvents() const { return ndarray<Psana::EvrData::FIFOEvent, 1>(&_fifoEvents_ndarray_storage_[0], _fifoEvents_ndarray_shape_); }
Psana::EvrData::IOChannel pds_to_psana(PsddlPds::EvrData::IOChannel pds)
{
  return Psana::EvrData::IOChannel(pds.name(), pds.ninfo(), pds.infos().data());
}

IOConfigV1::IOConfigV1(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::EvrData::IOConfigV1()
  , m_xtcObj(xtcPtr)
{
  {
    typedef ndarray<PsddlPds::EvrData::IOChannel, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->channels();
    _channels_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::const_iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _channels_ndarray_storage_.push_back(psddl_pds2psana::EvrData::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _channels_ndarray_shape_);
  }
}
IOConfigV1::~IOConfigV1()
{
}


uint16_t IOConfigV1::nchannels() const { return m_xtcObj->nchannels(); }

ndarray<Psana::EvrData::IOChannel, 1> IOConfigV1::channels() const { return ndarray<Psana::EvrData::IOChannel, 1>(&_channels_ndarray_storage_[0], _channels_ndarray_shape_); }

Psana::EvrData::OutputMap::Conn IOConfigV1::conn() const { return pds_to_psana(m_xtcObj->conn()); }
} // namespace EvrData
} // namespace psddl_pds2psana
