
// *** Do not edit this file, it is auto-generated ***

#include "psddl_pds2psana/cspad.ddl.h"

#include <cstddef>

#include <stdexcept>

namespace psddl_pds2psana {
namespace CsPad {
Psana::CsPad::RunModes pds_to_psana(PsddlPds::CsPad::RunModes e)
{
  return Psana::CsPad::RunModes(e);
}

Psana::CsPad::DataModes pds_to_psana(PsddlPds::CsPad::DataModes e)
{
  return Psana::CsPad::DataModes(e);
}

CsPadDigitalPotsCfg::CsPadDigitalPotsCfg(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::CsPad::CsPadDigitalPotsCfg()
  , m_xtcObj(xtcPtr)
{
}
CsPadDigitalPotsCfg::~CsPadDigitalPotsCfg()
{
}


const uint8_t* CsPadDigitalPotsCfg::pots() const { return m_xtcObj->pots(); }

std::vector<int> CsPadDigitalPotsCfg::_pots_shape() const { return m_xtcObj->_pots_shape(); }
CsPadReadOnlyCfg::CsPadReadOnlyCfg(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::CsPad::CsPadReadOnlyCfg()
  , m_xtcObj(xtcPtr)
{
}
CsPadReadOnlyCfg::~CsPadReadOnlyCfg()
{
}


uint32_t CsPadReadOnlyCfg::shiftTest() const { return m_xtcObj->shiftTest(); }

uint32_t CsPadReadOnlyCfg::version() const { return m_xtcObj->version(); }
CsPadGainMapCfg::CsPadGainMapCfg(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::CsPad::CsPadGainMapCfg()
  , m_xtcObj(xtcPtr)
{
}
CsPadGainMapCfg::~CsPadGainMapCfg()
{
}


const uint16_t* CsPadGainMapCfg::gainMap() const { return m_xtcObj->gainMap(); }

std::vector<int> CsPadGainMapCfg::_gainMap_shape() const { return m_xtcObj->_gainMap_shape(); }
ConfigV1QuadReg::ConfigV1QuadReg(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::CsPad::ConfigV1QuadReg()
  , m_xtcObj(xtcPtr)
  , _readOnly(boost::shared_ptr<const PsddlPds::CsPad::CsPadReadOnlyCfg>(xtcPtr, &xtcPtr->ro()))
  , _digitalPots(boost::shared_ptr<const PsddlPds::CsPad::CsPadDigitalPotsCfg>(xtcPtr, &xtcPtr->dp()))
  , _gainMap(boost::shared_ptr<const PsddlPds::CsPad::CsPadGainMapCfg>(xtcPtr, &xtcPtr->gm()))
{
}
ConfigV1QuadReg::~ConfigV1QuadReg()
{
}


const uint32_t* ConfigV1QuadReg::shiftSelect() const { return m_xtcObj->shiftSelect(); }

const uint32_t* ConfigV1QuadReg::edgeSelect() const { return m_xtcObj->edgeSelect(); }

uint32_t ConfigV1QuadReg::readClkSet() const { return m_xtcObj->readClkSet(); }

uint32_t ConfigV1QuadReg::readClkHold() const { return m_xtcObj->readClkHold(); }

uint32_t ConfigV1QuadReg::dataMode() const { return m_xtcObj->dataMode(); }

uint32_t ConfigV1QuadReg::prstSel() const { return m_xtcObj->prstSel(); }

uint32_t ConfigV1QuadReg::acqDelay() const { return m_xtcObj->acqDelay(); }

uint32_t ConfigV1QuadReg::intTime() const { return m_xtcObj->intTime(); }

uint32_t ConfigV1QuadReg::digDelay() const { return m_xtcObj->digDelay(); }

uint32_t ConfigV1QuadReg::ampIdle() const { return m_xtcObj->ampIdle(); }

uint32_t ConfigV1QuadReg::injTotal() const { return m_xtcObj->injTotal(); }

uint32_t ConfigV1QuadReg::rowColShiftPer() const { return m_xtcObj->rowColShiftPer(); }

const Psana::CsPad::CsPadReadOnlyCfg& ConfigV1QuadReg::ro() const { return _readOnly; }

const Psana::CsPad::CsPadDigitalPotsCfg& ConfigV1QuadReg::dp() const { return _digitalPots; }

const Psana::CsPad::CsPadGainMapCfg& ConfigV1QuadReg::gm() const { return _gainMap; }

std::vector<int> ConfigV1QuadReg::_shiftSelect_shape() const { return m_xtcObj->_shiftSelect_shape(); }

std::vector<int> ConfigV1QuadReg::_edgeSelect_shape() const { return m_xtcObj->_edgeSelect_shape(); }
ConfigV1::ConfigV1(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::CsPad::ConfigV1()
  , m_xtcObj(xtcPtr)
{
  {
    const std::vector<int>& dims = xtcPtr->_quads_shape();
    _quads.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      const PsddlPds::CsPad::ConfigV1QuadReg& d = xtcPtr->quads(i0);
      boost::shared_ptr<const PsddlPds::CsPad::ConfigV1QuadReg> dPtr(m_xtcObj, &d);
      _quads.push_back(psddl_pds2psana::CsPad::ConfigV1QuadReg(dPtr));
    }
  }
}
ConfigV1::~ConfigV1()
{
}


uint32_t ConfigV1::concentratorVersion() const { return m_xtcObj->concentratorVersion(); }

uint32_t ConfigV1::runDelay() const { return m_xtcObj->runDelay(); }

uint32_t ConfigV1::eventCode() const { return m_xtcObj->eventCode(); }

uint32_t ConfigV1::inactiveRunMode() const { return m_xtcObj->inactiveRunMode(); }

uint32_t ConfigV1::activeRunMode() const { return m_xtcObj->activeRunMode(); }

uint32_t ConfigV1::tdi() const { return m_xtcObj->tdi(); }

uint32_t ConfigV1::payloadSize() const { return m_xtcObj->payloadSize(); }

uint32_t ConfigV1::badAsicMask0() const { return m_xtcObj->badAsicMask0(); }

uint32_t ConfigV1::badAsicMask1() const { return m_xtcObj->badAsicMask1(); }

uint32_t ConfigV1::asicMask() const { return m_xtcObj->asicMask(); }

uint32_t ConfigV1::quadMask() const { return m_xtcObj->quadMask(); }

const Psana::CsPad::ConfigV1QuadReg& ConfigV1::quads(uint32_t i0) const { return _quads[i0]; }

uint32_t ConfigV1::numAsicsRead() const { return m_xtcObj->numAsicsRead(); }

uint32_t ConfigV1::numQuads() const { return m_xtcObj->numQuads(); }

uint32_t ConfigV1::numSect() const { return m_xtcObj->numSect(); }
std::vector<int> ConfigV1::_quads_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_quads.size());
  return shape;
}

ConfigV2::ConfigV2(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::CsPad::ConfigV2()
  , m_xtcObj(xtcPtr)
{
  {
    const std::vector<int>& dims = xtcPtr->_quads_shape();
    _quads.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      const PsddlPds::CsPad::ConfigV1QuadReg& d = xtcPtr->quads(i0);
      boost::shared_ptr<const PsddlPds::CsPad::ConfigV1QuadReg> dPtr(m_xtcObj, &d);
      _quads.push_back(psddl_pds2psana::CsPad::ConfigV1QuadReg(dPtr));
    }
  }
}
ConfigV2::~ConfigV2()
{
}


uint32_t ConfigV2::concentratorVersion() const { return m_xtcObj->concentratorVersion(); }

uint32_t ConfigV2::runDelay() const { return m_xtcObj->runDelay(); }

uint32_t ConfigV2::eventCode() const { return m_xtcObj->eventCode(); }

uint32_t ConfigV2::inactiveRunMode() const { return m_xtcObj->inactiveRunMode(); }

uint32_t ConfigV2::activeRunMode() const { return m_xtcObj->activeRunMode(); }

uint32_t ConfigV2::tdi() const { return m_xtcObj->tdi(); }

uint32_t ConfigV2::payloadSize() const { return m_xtcObj->payloadSize(); }

uint32_t ConfigV2::badAsicMask0() const { return m_xtcObj->badAsicMask0(); }

uint32_t ConfigV2::badAsicMask1() const { return m_xtcObj->badAsicMask1(); }

uint32_t ConfigV2::asicMask() const { return m_xtcObj->asicMask(); }

uint32_t ConfigV2::quadMask() const { return m_xtcObj->quadMask(); }

const Psana::CsPad::ConfigV1QuadReg& ConfigV2::quads(uint32_t i0) const { return _quads[i0]; }

uint32_t ConfigV2::numAsicsRead() const { return m_xtcObj->numAsicsRead(); }

uint32_t ConfigV2::roiMask(uint32_t iq) const { return m_xtcObj->roiMask(iq); }

uint32_t ConfigV2::numAsicsStored(uint32_t iq) const { return m_xtcObj->numAsicsStored(iq); }

uint32_t ConfigV2::numQuads() const { return m_xtcObj->numQuads(); }

uint32_t ConfigV2::numSect() const { return m_xtcObj->numSect(); }
std::vector<int> ConfigV2::_quads_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_quads.size());
  return shape;
}

ElementV1::ElementV1(const boost::shared_ptr<const XtcType>& xtcPtr, const boost::shared_ptr<const PsddlPds::CsPad::ConfigV1>& cfgPtr)
  : Psana::CsPad::ElementV1()
  , m_xtcObj(xtcPtr)
  , m_cfgPtr0(cfgPtr)
{
}
ElementV1::ElementV1(const boost::shared_ptr<const XtcType>& xtcPtr, const boost::shared_ptr<const PsddlPds::CsPad::ConfigV2>& cfgPtr)
  : Psana::CsPad::ElementV1()
  , m_xtcObj(xtcPtr)
  , m_cfgPtr1(cfgPtr)
{
}
ElementV1::~ElementV1()
{
}


uint32_t ElementV1::seq_count() const { return m_xtcObj->seq_count(); }

uint32_t ElementV1::ticks() const { return m_xtcObj->ticks(); }

uint32_t ElementV1::fiducials() const { return m_xtcObj->fiducials(); }

const uint16_t* ElementV1::sb_temp() const { return m_xtcObj->sb_temp(); }

uint32_t ElementV1::frame_type() const { return m_xtcObj->frame_type(); }

const uint16_t* ElementV1::data() const { return m_xtcObj->data(); }

std::vector<int> ElementV1::_sbtemp_shape() const { return m_xtcObj->_sbtemp_shape(); }

std::vector<int> ElementV1::_data_shape() const {
  if (m_cfgPtr0.get()) return m_xtcObj->_data_shape(*m_cfgPtr0);
  if (m_cfgPtr1.get()) return m_xtcObj->_data_shape(*m_cfgPtr1);
  throw std::runtime_error("ElementV1::_data_shape: config object pointer is zero");
}


std::vector<int> ElementV1::_extra_shape() const { return m_xtcObj->_extra_shape(); }
ElementV2::ElementV2(const boost::shared_ptr<const XtcType>& xtcPtr, const boost::shared_ptr<const PsddlPds::CsPad::ConfigV2>& cfgPtr)
  : Psana::CsPad::ElementV2()
  , m_xtcObj(xtcPtr)
  , m_cfgPtr0(cfgPtr)
{
}
ElementV2::~ElementV2()
{
}


uint32_t ElementV2::seq_count() const { return m_xtcObj->seq_count(); }

uint32_t ElementV2::ticks() const { return m_xtcObj->ticks(); }

uint32_t ElementV2::fiducials() const { return m_xtcObj->fiducials(); }

const uint16_t* ElementV2::sb_temp() const { return m_xtcObj->sb_temp(); }

uint32_t ElementV2::frame_type() const { return m_xtcObj->frame_type(); }

const uint16_t* ElementV2::data() const { return m_xtcObj->data(); }

std::vector<int> ElementV2::_sbtemp_shape() const { return m_xtcObj->_sbtemp_shape(); }

std::vector<int> ElementV2::_data_shape() const {
  if (m_cfgPtr0.get()) return m_xtcObj->_data_shape(*m_cfgPtr0);
  throw std::runtime_error("ElementV2::_data_shape: config object pointer is zero");
}


std::vector<int> ElementV2::_extra_shape() const { return m_xtcObj->_extra_shape(); }
} // namespace CsPad
} // namespace psddl_pds2psana
