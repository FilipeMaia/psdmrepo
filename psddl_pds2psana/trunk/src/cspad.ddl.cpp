
// *** Do not edit this file, it is auto-generated ***

#include "psddl_pds2psana/cspad.ddl.h"

#include <cstddef>

#include <stdexcept>

namespace psddl_pds2psana {
namespace CsPad {
Psana::CsPad::RunModes pds_to_psana(PsddlPds::CsPad::RunModes e)
{
  return Psana::CsPad::RunModes(e);
}

Psana::CsPad::DataModes pds_to_psana(PsddlPds::CsPad::DataModes e)
{
  return Psana::CsPad::DataModes(e);
}

CsPadDigitalPotsCfg::CsPadDigitalPotsCfg(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::CsPad::CsPadDigitalPotsCfg()
  , m_xtcObj(xtcPtr)
{
}
CsPadDigitalPotsCfg::~CsPadDigitalPotsCfg()
{
}


ndarray<uint8_t, 1> CsPadDigitalPotsCfg::pots() const { return m_xtcObj->pots(); }
CsPadReadOnlyCfg::CsPadReadOnlyCfg(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::CsPad::CsPadReadOnlyCfg()
  , m_xtcObj(xtcPtr)
{
}
CsPadReadOnlyCfg::~CsPadReadOnlyCfg()
{
}


uint32_t CsPadReadOnlyCfg::shiftTest() const { return m_xtcObj->shiftTest(); }

uint32_t CsPadReadOnlyCfg::version() const { return m_xtcObj->version(); }
ProtectionSystemThreshold::ProtectionSystemThreshold(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::CsPad::ProtectionSystemThreshold()
  , m_xtcObj(xtcPtr)
{
}
ProtectionSystemThreshold::~ProtectionSystemThreshold()
{
}


uint32_t ProtectionSystemThreshold::adcThreshold() const { return m_xtcObj->adcThreshold(); }

uint32_t ProtectionSystemThreshold::pixelCountThreshold() const { return m_xtcObj->pixelCountThreshold(); }
CsPadGainMapCfg::CsPadGainMapCfg(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::CsPad::CsPadGainMapCfg()
  , m_xtcObj(xtcPtr)
{
}
CsPadGainMapCfg::~CsPadGainMapCfg()
{
}


ndarray<uint16_t, 2> CsPadGainMapCfg::gainMap() const { return m_xtcObj->gainMap(); }
ConfigV1QuadReg::ConfigV1QuadReg(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::CsPad::ConfigV1QuadReg()
  , m_xtcObj(xtcPtr)
  , _readOnly(boost::shared_ptr<const PsddlPds::CsPad::CsPadReadOnlyCfg>(xtcPtr, &xtcPtr->ro()))
  , _digitalPots(boost::shared_ptr<const PsddlPds::CsPad::CsPadDigitalPotsCfg>(xtcPtr, &xtcPtr->dp()))
  , _gainMap(boost::shared_ptr<const PsddlPds::CsPad::CsPadGainMapCfg>(xtcPtr, &xtcPtr->gm()))
{
}
ConfigV1QuadReg::~ConfigV1QuadReg()
{
}


ndarray<uint32_t, 1> ConfigV1QuadReg::shiftSelect() const { return m_xtcObj->shiftSelect(); }

ndarray<uint32_t, 1> ConfigV1QuadReg::edgeSelect() const { return m_xtcObj->edgeSelect(); }

uint32_t ConfigV1QuadReg::readClkSet() const { return m_xtcObj->readClkSet(); }

uint32_t ConfigV1QuadReg::readClkHold() const { return m_xtcObj->readClkHold(); }

uint32_t ConfigV1QuadReg::dataMode() const { return m_xtcObj->dataMode(); }

uint32_t ConfigV1QuadReg::prstSel() const { return m_xtcObj->prstSel(); }

uint32_t ConfigV1QuadReg::acqDelay() const { return m_xtcObj->acqDelay(); }

uint32_t ConfigV1QuadReg::intTime() const { return m_xtcObj->intTime(); }

uint32_t ConfigV1QuadReg::digDelay() const { return m_xtcObj->digDelay(); }

uint32_t ConfigV1QuadReg::ampIdle() const { return m_xtcObj->ampIdle(); }

uint32_t ConfigV1QuadReg::injTotal() const { return m_xtcObj->injTotal(); }

uint32_t ConfigV1QuadReg::rowColShiftPer() const { return m_xtcObj->rowColShiftPer(); }

const Psana::CsPad::CsPadReadOnlyCfg& ConfigV1QuadReg::ro() const { return _readOnly; }

const Psana::CsPad::CsPadDigitalPotsCfg& ConfigV1QuadReg::dp() const { return _digitalPots; }

const Psana::CsPad::CsPadGainMapCfg& ConfigV1QuadReg::gm() const { return _gainMap; }
ConfigV1::ConfigV1(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::CsPad::ConfigV1()
  , m_xtcObj(xtcPtr)
{
  {
    const std::vector<int>& dims = xtcPtr->quads_shape();
    _quads.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      const PsddlPds::CsPad::ConfigV1QuadReg& d = xtcPtr->quads(i0);
      boost::shared_ptr<const PsddlPds::CsPad::ConfigV1QuadReg> dPtr(m_xtcObj, &d);
      _quads.push_back(psddl_pds2psana::CsPad::ConfigV1QuadReg(dPtr));
    }
  }
}
ConfigV1::~ConfigV1()
{
}


uint32_t ConfigV1::concentratorVersion() const { return m_xtcObj->concentratorVersion(); }

uint32_t ConfigV1::runDelay() const { return m_xtcObj->runDelay(); }

uint32_t ConfigV1::eventCode() const { return m_xtcObj->eventCode(); }

uint32_t ConfigV1::inactiveRunMode() const { return m_xtcObj->inactiveRunMode(); }

uint32_t ConfigV1::activeRunMode() const { return m_xtcObj->activeRunMode(); }

uint32_t ConfigV1::tdi() const { return m_xtcObj->tdi(); }

uint32_t ConfigV1::payloadSize() const { return m_xtcObj->payloadSize(); }

uint32_t ConfigV1::badAsicMask0() const { return m_xtcObj->badAsicMask0(); }

uint32_t ConfigV1::badAsicMask1() const { return m_xtcObj->badAsicMask1(); }

uint32_t ConfigV1::asicMask() const { return m_xtcObj->asicMask(); }

uint32_t ConfigV1::quadMask() const { return m_xtcObj->quadMask(); }

const Psana::CsPad::ConfigV1QuadReg& ConfigV1::quads(uint32_t i0) const { return _quads[i0]; }

uint32_t ConfigV1::numAsicsRead() const { return m_xtcObj->numAsicsRead(); }

uint32_t ConfigV1::numQuads() const { return m_xtcObj->numQuads(); }

uint32_t ConfigV1::numSect() const { return m_xtcObj->numSect(); }
std::vector<int> ConfigV1::quads_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_quads.size());
  return shape;
}

ConfigV2::ConfigV2(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::CsPad::ConfigV2()
  , m_xtcObj(xtcPtr)
{
  {
    const std::vector<int>& dims = xtcPtr->quads_shape();
    _quads.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      const PsddlPds::CsPad::ConfigV1QuadReg& d = xtcPtr->quads(i0);
      boost::shared_ptr<const PsddlPds::CsPad::ConfigV1QuadReg> dPtr(m_xtcObj, &d);
      _quads.push_back(psddl_pds2psana::CsPad::ConfigV1QuadReg(dPtr));
    }
  }
}
ConfigV2::~ConfigV2()
{
}


uint32_t ConfigV2::concentratorVersion() const { return m_xtcObj->concentratorVersion(); }

uint32_t ConfigV2::runDelay() const { return m_xtcObj->runDelay(); }

uint32_t ConfigV2::eventCode() const { return m_xtcObj->eventCode(); }

uint32_t ConfigV2::inactiveRunMode() const { return m_xtcObj->inactiveRunMode(); }

uint32_t ConfigV2::activeRunMode() const { return m_xtcObj->activeRunMode(); }

uint32_t ConfigV2::tdi() const { return m_xtcObj->tdi(); }

uint32_t ConfigV2::payloadSize() const { return m_xtcObj->payloadSize(); }

uint32_t ConfigV2::badAsicMask0() const { return m_xtcObj->badAsicMask0(); }

uint32_t ConfigV2::badAsicMask1() const { return m_xtcObj->badAsicMask1(); }

uint32_t ConfigV2::asicMask() const { return m_xtcObj->asicMask(); }

uint32_t ConfigV2::quadMask() const { return m_xtcObj->quadMask(); }

const Psana::CsPad::ConfigV1QuadReg& ConfigV2::quads(uint32_t i0) const { return _quads[i0]; }

uint32_t ConfigV2::numAsicsRead() const { return m_xtcObj->numAsicsRead(); }

uint32_t ConfigV2::roiMask(uint32_t iq) const { return m_xtcObj->roiMask(iq); }

uint32_t ConfigV2::numAsicsStored(uint32_t iq) const { return m_xtcObj->numAsicsStored(iq); }

uint32_t ConfigV2::numQuads() const { return m_xtcObj->numQuads(); }

uint32_t ConfigV2::numSect() const { return m_xtcObj->numSect(); }
std::vector<int> ConfigV2::quads_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_quads.size());
  return shape;
}

ConfigV3::ConfigV3(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::CsPad::ConfigV3()
  , m_xtcObj(xtcPtr)
{
  {
    const std::vector<int>& dims = xtcPtr->protectionThresholds_shape();
    _protectionThresholds.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      const PsddlPds::CsPad::ProtectionSystemThreshold& d = xtcPtr->protectionThresholds(i0);
      boost::shared_ptr<const PsddlPds::CsPad::ProtectionSystemThreshold> dPtr(m_xtcObj, &d);
      _protectionThresholds.push_back(psddl_pds2psana::CsPad::ProtectionSystemThreshold(dPtr));
    }
  }
  {
    const std::vector<int>& dims = xtcPtr->quads_shape();
    _quads.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      const PsddlPds::CsPad::ConfigV1QuadReg& d = xtcPtr->quads(i0);
      boost::shared_ptr<const PsddlPds::CsPad::ConfigV1QuadReg> dPtr(m_xtcObj, &d);
      _quads.push_back(psddl_pds2psana::CsPad::ConfigV1QuadReg(dPtr));
    }
  }
}
ConfigV3::~ConfigV3()
{
}


uint32_t ConfigV3::concentratorVersion() const { return m_xtcObj->concentratorVersion(); }

uint32_t ConfigV3::runDelay() const { return m_xtcObj->runDelay(); }

uint32_t ConfigV3::eventCode() const { return m_xtcObj->eventCode(); }

const Psana::CsPad::ProtectionSystemThreshold& ConfigV3::protectionThresholds(uint32_t i0) const { return _protectionThresholds[i0]; }

uint32_t ConfigV3::protectionEnable() const { return m_xtcObj->protectionEnable(); }

uint32_t ConfigV3::inactiveRunMode() const { return m_xtcObj->inactiveRunMode(); }

uint32_t ConfigV3::activeRunMode() const { return m_xtcObj->activeRunMode(); }

uint32_t ConfigV3::tdi() const { return m_xtcObj->tdi(); }

uint32_t ConfigV3::payloadSize() const { return m_xtcObj->payloadSize(); }

uint32_t ConfigV3::badAsicMask0() const { return m_xtcObj->badAsicMask0(); }

uint32_t ConfigV3::badAsicMask1() const { return m_xtcObj->badAsicMask1(); }

uint32_t ConfigV3::asicMask() const { return m_xtcObj->asicMask(); }

uint32_t ConfigV3::quadMask() const { return m_xtcObj->quadMask(); }

const Psana::CsPad::ConfigV1QuadReg& ConfigV3::quads(uint32_t i0) const { return _quads[i0]; }

uint32_t ConfigV3::numAsicsRead() const { return m_xtcObj->numAsicsRead(); }

uint32_t ConfigV3::roiMask(uint32_t iq) const { return m_xtcObj->roiMask(iq); }

uint32_t ConfigV3::numAsicsStored(uint32_t iq) const { return m_xtcObj->numAsicsStored(iq); }

uint32_t ConfigV3::numQuads() const { return m_xtcObj->numQuads(); }

uint32_t ConfigV3::numSect() const { return m_xtcObj->numSect(); }
std::vector<int> ConfigV3::protectionThresholds_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_protectionThresholds.size());
  return shape;
}

std::vector<int> ConfigV3::quads_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_quads.size());
  return shape;
}

ElementV1::ElementV1(const boost::shared_ptr<const XtcType>& xtcPtr, const boost::shared_ptr<const PsddlPds::CsPad::ConfigV1>& cfgPtr)
  : Psana::CsPad::ElementV1()
  , m_xtcObj(xtcPtr)
  , m_cfgPtr0(cfgPtr)
{
}
ElementV1::ElementV1(const boost::shared_ptr<const XtcType>& xtcPtr, const boost::shared_ptr<const PsddlPds::CsPad::ConfigV2>& cfgPtr)
  : Psana::CsPad::ElementV1()
  , m_xtcObj(xtcPtr)
  , m_cfgPtr1(cfgPtr)
{
}
ElementV1::~ElementV1()
{
}


uint32_t ElementV1::virtual_channel() const { return m_xtcObj->virtual_channel(); }

uint32_t ElementV1::lane() const { return m_xtcObj->lane(); }

uint32_t ElementV1::tid() const { return m_xtcObj->tid(); }

uint32_t ElementV1::acq_count() const { return m_xtcObj->acq_count(); }

uint32_t ElementV1::op_code() const { return m_xtcObj->op_code(); }

uint32_t ElementV1::quad() const { return m_xtcObj->quad(); }

uint32_t ElementV1::seq_count() const { return m_xtcObj->seq_count(); }

uint32_t ElementV1::ticks() const { return m_xtcObj->ticks(); }

uint32_t ElementV1::fiducials() const { return m_xtcObj->fiducials(); }

ndarray<uint16_t, 1> ElementV1::sb_temp() const { return m_xtcObj->sb_temp(); }

uint32_t ElementV1::frame_type() const { return m_xtcObj->frame_type(); }

ndarray<int16_t, 3> ElementV1::data() const {
  if (m_cfgPtr0.get()) return m_xtcObj->data(*m_cfgPtr0);
  if (m_cfgPtr1.get()) return m_xtcObj->data(*m_cfgPtr1);
  throw std::runtime_error("ElementV1::data: config object pointer is zero");
}


uint32_t ElementV1::sectionMask() const {
  if (m_cfgPtr0.get()) return m_xtcObj->sectionMask(*m_cfgPtr0);
  if (m_cfgPtr1.get()) return m_xtcObj->sectionMask(*m_cfgPtr1);
  throw std::runtime_error("ElementV1::sectionMask: config object pointer is zero");
}


float ElementV1::common_mode(uint32_t section) const { return m_xtcObj->common_mode(section); }
DataV1::DataV1(const boost::shared_ptr<const XtcType>& xtcPtr, const boost::shared_ptr<const PsddlPds::CsPad::ConfigV1>& cfgPtr)
  : Psana::CsPad::DataV1()
  , m_xtcObj(xtcPtr)
  , m_cfgPtr0(cfgPtr)
{
  {
    const std::vector<int>& dims = xtcPtr->quads_shape(*cfgPtr);
    _quads.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      const PsddlPds::CsPad::ElementV1& d = xtcPtr->quads(*cfgPtr, i0);
      boost::shared_ptr<const PsddlPds::CsPad::ElementV1> dPtr(m_xtcObj, &d);
      _quads.push_back(psddl_pds2psana::CsPad::ElementV1(dPtr, cfgPtr));
    }
  }
}
DataV1::DataV1(const boost::shared_ptr<const XtcType>& xtcPtr, const boost::shared_ptr<const PsddlPds::CsPad::ConfigV2>& cfgPtr)
  : Psana::CsPad::DataV1()
  , m_xtcObj(xtcPtr)
  , m_cfgPtr1(cfgPtr)
{
  {
    const std::vector<int>& dims = xtcPtr->quads_shape(*cfgPtr);
    _quads.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      const PsddlPds::CsPad::ElementV1& d = xtcPtr->quads(*cfgPtr, i0);
      boost::shared_ptr<const PsddlPds::CsPad::ElementV1> dPtr(m_xtcObj, &d);
      _quads.push_back(psddl_pds2psana::CsPad::ElementV1(dPtr, cfgPtr));
    }
  }
}
DataV1::~DataV1()
{
}


const Psana::CsPad::ElementV1& DataV1::quads(uint32_t i0) const { return _quads[i0]; }
std::vector<int> DataV1::quads_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_quads.size());
  return shape;
}

ElementV2::ElementV2(const boost::shared_ptr<const XtcType>& xtcPtr, const boost::shared_ptr<const PsddlPds::CsPad::ConfigV2>& cfgPtr)
  : Psana::CsPad::ElementV2()
  , m_xtcObj(xtcPtr)
  , m_cfgPtr0(cfgPtr)
{
}
ElementV2::ElementV2(const boost::shared_ptr<const XtcType>& xtcPtr, const boost::shared_ptr<const PsddlPds::CsPad::ConfigV3>& cfgPtr)
  : Psana::CsPad::ElementV2()
  , m_xtcObj(xtcPtr)
  , m_cfgPtr1(cfgPtr)
{
}
ElementV2::~ElementV2()
{
}


uint32_t ElementV2::virtual_channel() const { return m_xtcObj->virtual_channel(); }

uint32_t ElementV2::lane() const { return m_xtcObj->lane(); }

uint32_t ElementV2::tid() const { return m_xtcObj->tid(); }

uint32_t ElementV2::acq_count() const { return m_xtcObj->acq_count(); }

uint32_t ElementV2::op_code() const { return m_xtcObj->op_code(); }

uint32_t ElementV2::quad() const { return m_xtcObj->quad(); }

uint32_t ElementV2::seq_count() const { return m_xtcObj->seq_count(); }

uint32_t ElementV2::ticks() const { return m_xtcObj->ticks(); }

uint32_t ElementV2::fiducials() const { return m_xtcObj->fiducials(); }

ndarray<uint16_t, 1> ElementV2::sb_temp() const { return m_xtcObj->sb_temp(); }

uint32_t ElementV2::frame_type() const { return m_xtcObj->frame_type(); }

ndarray<int16_t, 3> ElementV2::data() const {
  if (m_cfgPtr0.get()) return m_xtcObj->data(*m_cfgPtr0);
  if (m_cfgPtr1.get()) return m_xtcObj->data(*m_cfgPtr1);
  throw std::runtime_error("ElementV2::data: config object pointer is zero");
}


uint32_t ElementV2::sectionMask() const {
  if (m_cfgPtr0.get()) return m_xtcObj->sectionMask(*m_cfgPtr0);
  if (m_cfgPtr1.get()) return m_xtcObj->sectionMask(*m_cfgPtr1);
  throw std::runtime_error("ElementV2::sectionMask: config object pointer is zero");
}


float ElementV2::common_mode(uint32_t section) const { return m_xtcObj->common_mode(section); }
DataV2::DataV2(const boost::shared_ptr<const XtcType>& xtcPtr, const boost::shared_ptr<const PsddlPds::CsPad::ConfigV2>& cfgPtr)
  : Psana::CsPad::DataV2()
  , m_xtcObj(xtcPtr)
  , m_cfgPtr0(cfgPtr)
{
  {
    const std::vector<int>& dims = xtcPtr->quads_shape(*cfgPtr);
    _quads.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      const PsddlPds::CsPad::ElementV2& d = xtcPtr->quads(*cfgPtr, i0);
      boost::shared_ptr<const PsddlPds::CsPad::ElementV2> dPtr(m_xtcObj, &d);
      _quads.push_back(psddl_pds2psana::CsPad::ElementV2(dPtr, cfgPtr));
    }
  }
}
DataV2::DataV2(const boost::shared_ptr<const XtcType>& xtcPtr, const boost::shared_ptr<const PsddlPds::CsPad::ConfigV3>& cfgPtr)
  : Psana::CsPad::DataV2()
  , m_xtcObj(xtcPtr)
  , m_cfgPtr1(cfgPtr)
{
  {
    const std::vector<int>& dims = xtcPtr->quads_shape(*cfgPtr);
    _quads.reserve(dims[0]);
    for (int i0=0; i0 != dims[0]; ++i0) {
      const PsddlPds::CsPad::ElementV2& d = xtcPtr->quads(*cfgPtr, i0);
      boost::shared_ptr<const PsddlPds::CsPad::ElementV2> dPtr(m_xtcObj, &d);
      _quads.push_back(psddl_pds2psana::CsPad::ElementV2(dPtr, cfgPtr));
    }
  }
}
DataV2::~DataV2()
{
}


const Psana::CsPad::ElementV2& DataV2::quads(uint32_t i0) const { return _quads[i0]; }
std::vector<int> DataV2::quads_shape() const
{
  std::vector<int> shape;
  shape.reserve(1);
  shape.push_back(_quads.size());
  return shape;
}

} // namespace CsPad
} // namespace psddl_pds2psana
