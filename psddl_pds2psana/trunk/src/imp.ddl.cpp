
// *** Do not edit this file, it is auto-generated ***

#include "psddl_pds2psana/imp.ddl.h"

#include <cstddef>

#include <stdexcept>

namespace psddl_pds2psana {
namespace Imp {
Psana::Imp::ConfigV1::Registers pds_to_psana(PsddlPds::Imp::ConfigV1::Registers e)
{
  return Psana::Imp::ConfigV1::Registers(e);
}

ConfigV1::ConfigV1(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::Imp::ConfigV1()
  , m_xtcObj(xtcPtr)
{
}
ConfigV1::~ConfigV1()
{
}


uint32_t ConfigV1::range() const { return m_xtcObj->range(); }

uint32_t ConfigV1::calRange() const { return m_xtcObj->calRange(); }

uint32_t ConfigV1::reset() const { return m_xtcObj->reset(); }

uint32_t ConfigV1::biasData() const { return m_xtcObj->biasData(); }

uint32_t ConfigV1::calData() const { return m_xtcObj->calData(); }

uint32_t ConfigV1::biasDacData() const { return m_xtcObj->biasDacData(); }

uint32_t ConfigV1::calStrobe() const { return m_xtcObj->calStrobe(); }

uint32_t ConfigV1::numberOfSamples() const { return m_xtcObj->numberOfSamples(); }

uint32_t ConfigV1::trigDelay() const { return m_xtcObj->trigDelay(); }

uint32_t ConfigV1::adcDelay() const { return m_xtcObj->adcDelay(); }
Psana::Imp::Sample pds_to_psana(PsddlPds::Imp::Sample pds)
{
  return Psana::Imp::Sample(pds.channels().data());
}

Psana::Imp::LaneStatus pds_to_psana(PsddlPds::Imp::LaneStatus pds)
{
  return Psana::Imp::LaneStatus(pds.linkErrCount(), pds.linkDownCount(), pds.cellErrCount(), pds.rxCount(), pds.locLinked(), pds.remLinked(), pds.zeros(), pds.powersOkay());
}

ElementV1::ElementV1(const boost::shared_ptr<const XtcType>& xtcPtr, const boost::shared_ptr<const PsddlPds::Imp::ConfigV1>& cfgPtr)
  : Psana::Imp::ElementV1()
  , m_xtcObj(xtcPtr)
  , m_cfgPtr0(cfgPtr)
  , _laneStatus(psddl_pds2psana::Imp::pds_to_psana(xtcPtr->laneStatus()))
{
  {
    typedef ndarray<const PsddlPds::Imp::Sample, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->samples(*cfgPtr);
    _samples_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _samples_ndarray_storage_.push_back(psddl_pds2psana::Imp::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _samples_ndarray_shape_);
  }
}
ElementV1::~ElementV1()
{
}


uint8_t ElementV1::vc() const { return m_xtcObj->vc(); }

uint8_t ElementV1::lane() const { return m_xtcObj->lane(); }

uint32_t ElementV1::frameNumber() const { return m_xtcObj->frameNumber(); }

uint32_t ElementV1::range() const { return m_xtcObj->range(); }

const Psana::Imp::LaneStatus& ElementV1::laneStatus() const { return _laneStatus; }

ndarray<const Psana::Imp::Sample, 1> ElementV1::samples() const { return ndarray<const Psana::Imp::Sample, 1>(&_samples_ndarray_storage_[0], _samples_ndarray_shape_); }
} // namespace Imp
} // namespace psddl_pds2psana
