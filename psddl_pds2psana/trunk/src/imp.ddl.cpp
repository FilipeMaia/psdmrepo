
// *** Do not edit this file, it is auto-generated ***

#include "psddl_pds2psana/imp.ddl.h"

#include <cstddef>

#include <stdexcept>

namespace psddl_pds2psana {
namespace Imp {
Psana::Imp::ConfigV1::Registers pds_to_psana(Pds::Imp::ConfigV1::Registers e)
{
  return Psana::Imp::ConfigV1::Registers(e);
}

ConfigV1::ConfigV1(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::Imp::ConfigV1()
  , m_xtcObj(xtcPtr)
{
}
ConfigV1::~ConfigV1()
{
}


uint32_t ConfigV1::range() const {
  return m_xtcObj->range();
}


uint32_t ConfigV1::calRange() const {
  return m_xtcObj->calRange();
}


uint32_t ConfigV1::reset() const {
  return m_xtcObj->reset();
}


uint32_t ConfigV1::biasData() const {
  return m_xtcObj->biasData();
}


uint32_t ConfigV1::calData() const {
  return m_xtcObj->calData();
}


uint32_t ConfigV1::biasDacData() const {
  return m_xtcObj->biasDacData();
}


uint32_t ConfigV1::calStrobe() const {
  return m_xtcObj->calStrobe();
}


uint32_t ConfigV1::numberOfSamples() const {
  return m_xtcObj->numberOfSamples();
}


uint32_t ConfigV1::trigDelay() const {
  return m_xtcObj->trigDelay();
}


uint32_t ConfigV1::adcDelay() const {
  return m_xtcObj->adcDelay();
}

Psana::Imp::Sample pds_to_psana(Pds::Imp::Sample pds)
{
  return Psana::Imp::Sample(pds.channels().data());
}

Psana::Imp::LaneStatus pds_to_psana(Pds::Imp::LaneStatus pds)
{
  return Psana::Imp::LaneStatus(pds.linkErrCount(), pds.linkDownCount(), pds.cellErrCount(), pds.rxCount(), pds.locLinked(), pds.remLinked(), pds.zeros(), pds.powersOkay());
}

template <typename Config>
ElementV1<Config>::ElementV1(const boost::shared_ptr<const XtcType>& xtcPtr, const boost::shared_ptr<const Config>& cfgPtr)
  : Psana::Imp::ElementV1()
  , m_xtcObj(xtcPtr)
  , m_cfgPtr(cfgPtr)
  , _laneStatus(psddl_pds2psana::Imp::pds_to_psana(xtcPtr->laneStatus()))
{
  {
    typedef ndarray<Psana::Imp::Sample, 1> NDArray;
    typedef ndarray<const Pds::Imp::Sample, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->samples(*cfgPtr);
    _samples_ndarray_storage_ = NDArray(xtc_ndarr.shape());
    NDArray::iterator out = _samples_ndarray_storage_.begin();
    for (XtcNDArray::iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it, ++ out) {
      *out = psddl_pds2psana::Imp::pds_to_psana(*it);
    }
  }
}
template <typename Config>
ElementV1<Config>::~ElementV1()
{
}


template <typename Config>
uint8_t ElementV1<Config>::vc() const {
  return m_xtcObj->vc();
}


template <typename Config>
uint8_t ElementV1<Config>::lane() const {
  return m_xtcObj->lane();
}


template <typename Config>
uint32_t ElementV1<Config>::frameNumber() const {
  return m_xtcObj->frameNumber();
}


template <typename Config>
uint32_t ElementV1<Config>::range() const {
  return m_xtcObj->range();
}

template <typename Config>
const Psana::Imp::LaneStatus& ElementV1<Config>::laneStatus() const { return _laneStatus; }
template <typename Config>
ndarray<const Psana::Imp::Sample, 1> ElementV1<Config>::samples() const { return _samples_ndarray_storage_; }
template class ElementV1<Pds::Imp::ConfigV1>;
} // namespace Imp
} // namespace psddl_pds2psana
