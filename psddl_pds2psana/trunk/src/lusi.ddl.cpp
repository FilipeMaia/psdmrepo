
// *** Do not edit this file, it is auto-generated ***

#include "psddl_pds2psana/lusi.ddl.h"

#include <cstddef>

#include <stdexcept>

namespace psddl_pds2psana {
namespace Lusi {
Psana::Lusi::DiodeFexConfigV1 pds_to_psana(PsddlPds::Lusi::DiodeFexConfigV1 pds)
{
  return Psana::Lusi::DiodeFexConfigV1(pds.base().data(), pds.scale().data());
}

Psana::Lusi::DiodeFexConfigV2 pds_to_psana(PsddlPds::Lusi::DiodeFexConfigV2 pds)
{
  return Psana::Lusi::DiodeFexConfigV2(pds.base().data(), pds.scale().data());
}

Psana::Lusi::DiodeFexV1 pds_to_psana(PsddlPds::Lusi::DiodeFexV1 pds)
{
  return Psana::Lusi::DiodeFexV1(pds.value());
}

IpmFexConfigV1::IpmFexConfigV1(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::Lusi::IpmFexConfigV1()
  , m_xtcObj(xtcPtr)
{
  {
    typedef ndarray<PsddlPds::Lusi::DiodeFexConfigV1, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->diode();
    _diode_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::const_iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _diode_ndarray_storage_.push_back(psddl_pds2psana::Lusi::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _diode_ndarray_shape_);
  }
}
IpmFexConfigV1::~IpmFexConfigV1()
{
}


ndarray<Psana::Lusi::DiodeFexConfigV1, 1> IpmFexConfigV1::diode() const { return ndarray<Psana::Lusi::DiodeFexConfigV1, 1>(&_diode_ndarray_storage_[0], _diode_ndarray_shape_); }

float IpmFexConfigV1::xscale() const { return m_xtcObj->xscale(); }

float IpmFexConfigV1::yscale() const { return m_xtcObj->yscale(); }
IpmFexConfigV2::IpmFexConfigV2(const boost::shared_ptr<const XtcType>& xtcPtr)
  : Psana::Lusi::IpmFexConfigV2()
  , m_xtcObj(xtcPtr)
{
  {
    typedef ndarray<PsddlPds::Lusi::DiodeFexConfigV2, 1> XtcNDArray;
    const XtcNDArray& xtc_ndarr = xtcPtr->diode();
    _diode_ndarray_storage_.reserve(xtc_ndarr.size());
    for (XtcNDArray::const_iterator it = xtc_ndarr.begin(); it != xtc_ndarr.end(); ++ it) {
      _diode_ndarray_storage_.push_back(psddl_pds2psana::Lusi::pds_to_psana(*it));
    }
    const unsigned* shape = xtc_ndarr.shape();
    std::copy(shape, shape+1, _diode_ndarray_shape_);
  }
}
IpmFexConfigV2::~IpmFexConfigV2()
{
}


ndarray<Psana::Lusi::DiodeFexConfigV2, 1> IpmFexConfigV2::diode() const { return ndarray<Psana::Lusi::DiodeFexConfigV2, 1>(&_diode_ndarray_storage_[0], _diode_ndarray_shape_); }

float IpmFexConfigV2::xscale() const { return m_xtcObj->xscale(); }

float IpmFexConfigV2::yscale() const { return m_xtcObj->yscale(); }
Psana::Lusi::IpmFexV1 pds_to_psana(PsddlPds::Lusi::IpmFexV1 pds)
{
  return Psana::Lusi::IpmFexV1(pds.channel().data(), pds.sum(), pds.xpos(), pds.ypos());
}

Psana::Lusi::PimImageConfigV1 pds_to_psana(PsddlPds::Lusi::PimImageConfigV1 pds)
{
  return Psana::Lusi::PimImageConfigV1(pds.xscale(), pds.yscale());
}

} // namespace Lusi
} // namespace psddl_pds2psana
